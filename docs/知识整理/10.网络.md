---
title: 网络
date: 2022-04-28 18:13:20
permalink: /pages/451590/
categories:
  - 知识整理
tags:
  - 网络
author: 
  name: liuwenkai01
---

# 网络

## 1、OSI七层模型

![](/blog/img/media/d113fe5b6903acbf0293305c3024c7c1.png) 

## 2、TCP/IP四层模型

1.应用层 2.传输层 3.网络层 4.网络接口层

![](/blog/img/media/c18c4bce5696f5bd8e918bfb376d59c5.png) 

## 3、HTTPS加解密过程

### 3.1 什么是HTTP？

HTTP（Hypertext Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说HTTP是当代互联网通信的基础。

但是，HTTP 有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露。

### 3.2 什么是HTTPS？

HTTPS其实就是将HTTP的数据包再通过SSL/TLS加密后传输，那么SSL/TLS又是什么呢？

SSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。

### 3.3 什么是对称加密？

对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。

### 3.4 什么是非对称加密？

非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。

### 3.5 HTTPS加解密过程？

1.服务端有非对称加密的公钥A1，私钥A2。

2.客户端有非对称加密的公钥B1，私钥B2。

3.客户端向服务端发起请求，服务端将公钥A1返回给客户端。

4.浏览器收到公钥A1，将自己保存的公钥B1发送给服务端。

5.之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密。

6.客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密。

**此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？**

**最主要的原因是非对称加解密耗时要远大于对称加解密，对性能有很大损耗，大家的使用体验很差。**

**所以，我们才最终选用了上文介绍到非对称加密+对称加密的方案：**

1.服务端有非对称加密的公钥A1，私钥A2。

2.客户端发起请求，服务端将公钥A1返回给客户端。

3.客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端。

4.服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题。

5.之后双方通信都使用密钥K进行对称加解密。

**看起来是一个非常完美的方案，兼顾了安全性和性能，但是，真的就安全了么？**

依然考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。

当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。

而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获。

**出现这一问题的核心原因是客户端无法确认收到的公钥是不是真的是服务端发来的。为了解决这个问题，互联网引入了一个公信机构，这就是CA。**

## 4、TCP三次握手

![](/blog/img/media/103d3cfb5df3aaac8b136c99a1a6c6d6.png)

第一次握手:Client **什么都不能确认**;Server 确认了:**对方发送正常，自己接收正常**。

第二次握手:Client 确认了:**自己发送、接收正常**，**对方发送、接收正常**;Server 确认了:**自己接收正常**，**对方发送正常**。

第三次握手:Client 确认了:**自己发送、接收正常**，**对方发送、接收正常**;Server 确认了:**自己发送、接收正常**，**对方发送、接收正常**。所以三次握手就能确认双发收发功能都正常，缺一不可。

## 5、四次挥手

![](/blog/img/media/798810cd77302dbe4ba13cac20e9da5a.png)

举个例子:A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的 话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道 了”，这样通话才算结束。

## 6、正向代理、反向代理

1.**正向代理其实是客户端代理，帮助客户端访问其无法访问到的服务器资源**。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。  
2.**正向代理一般是客户端架设，比如在自己的机器上安装一个代理软件**。反向代理一般是服务器架设的，比如在自己机器集群中部署一个反向代理服务器。  
3.**正向代理中，服务器不知道真正的客户端到底是谁**。反向代理中客户端不知道真正的服务端是谁。  
4.**正向代理主要用来解决访问限制问题**。反向代理则是提供负载均衡、安全防护等作用。

**nginx**

反向代理：proxy_pass

负载均衡：upstream
