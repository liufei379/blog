(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],u=0,h=[];u<s.length;u++)o=s[u],Object.prototype.hasOwnProperty.call(i,o)&&i[o]&&h.push(i[o][0]),i[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(d&&d(e);h.length;)h.shift()();return a.push.apply(a,c||[]),t()}function t(){for(var n,e=0;e<a.length;e++){for(var t=a[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==i[l]&&(r=!1)}r&&(a.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},i={1:0},a=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=i[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=i[n]=[e,r]}));e.push(t[2]=r);var a,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"8c154ab6",3:"f92fa794",4:"50b426fb",5:"7bba2d9e",6:"cd1f37a4",7:"0b16d3f5",8:"c70712c6",9:"399ed7f8",10:"c86d8629",11:"ad8a2dcc",12:"1f8c179a",13:"fd5f31ed",14:"9789ed1a",15:"6def5229",16:"a770381d",17:"1498548a",18:"e7b2ce58",19:"e80c390c",20:"1cbf28ad",21:"2e1cc8ac",22:"64c63c72",23:"5dffe2fb",24:"6f2dcc2f",25:"41d7d44f",26:"76393601",27:"72446a4c",28:"ab713c3a",29:"0de98ae6",30:"29d1e01e",31:"5f20e6f7",32:"e3bc2f9f",33:"8455902f",34:"251e267f",35:"9130d572",36:"3edaefdf",37:"862dacdc",38:"2ef71e6b",39:"27f8982a",40:"ea5fdbd6",41:"47711c50",42:"2382a942",43:"fce77d84",44:"d70e7c9c",45:"e155530b",46:"08012d83",47:"c14cc9e9",48:"66e68713",49:"c0d6c810",50:"3066ef26",51:"27b01e02",52:"8e3439c1",53:"13fad58b",54:"25df99a7"}[n]+".js"}(n);var l=new Error;a=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=i[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),a=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+a+")",l.name="ChunkLoadError",l.type=r,l.request=a,t[1](l)}i[n]=void 0}};var c=setTimeout((function(){a({type:"timeout",target:s})}),12e4);s.onerror=s.onload=a,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;a.push([237,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var r=t(0),i=t(38).f,a=t(24),o=t(14),s=t(109),l=t(114),c=t(105);n.exports=function(n,e){var t,d,u,h,p,m=n.target,g=n.global,f=n.stat;if(t=g?r:f?r[m]||s(m,{}):(r[m]||{}).prototype)for(d in e){if(h=e[d],u=n.noTargetGet?(p=i(t,d))&&p.value:t[d],!c(g?d:m+(f?".":"#")+d,n.forced)&&void 0!==u){if(typeof h==typeof u)continue;l(h,u)}(n.sham||u&&u.sham)&&a(h,"sham",!0),o(t,d,h,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(59),i=Function.prototype,a=i.bind,o=i.call,s=r&&a.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(0),i=t(46),a=t(9),o=t(82),s=t(47),l=t(149),c=i("wks"),d=r.Symbol,u=d&&d.for,h=l?d:d&&d.withoutSetter||o;n.exports=function(n){if(!a(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&a(d,n)?c[n]=d[n]:c[n]=l&&u?u(e):h(e)}return c[n]}},function(n,e,t){var r=t(117),i=t(14),a=t(259);r||i(Object.prototype,"toString",a,{unsafe:!0})},function(n,e,t){var r=t(59),i=Function.prototype.call;n.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(3),i=t(17),a=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return a(i(n),e)}},function(n,e,t){var r=t(0),i=t(11),a=r.String,o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not an object")}},function(n,e,t){var r=t(4);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(0),i=t(8),a=t(151),o=t(150),s=t(10),l=t(84),c=r.TypeError,d=Object.defineProperty,u=Object.getOwnPropertyDescriptor;e.f=i?o?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=u(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(s(n),e=l(e),s(t),a)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(0),i=t(91),a=r.String;n.exports=function(n){if("Symbol"===i(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var r=t(0),i=t(4),a=t(24),o=t(156),s=t(109);n.exports=function(n,e,t,l){var c=!!l&&!!l.unsafe,d=!!l&&!!l.enumerable,u=!!l&&!!l.noTargetGet,h=l&&void 0!==l.name?l.name:e;return i(t)&&o(t,h,l),n===r?(d?n[e]=t:s(e,t),n):(c?!u&&n[e]&&(d=!0):delete n[e],d?n[e]=t:a(n,e,t),n)}},function(n,e,t){var r=t(0),i=t(4),a=function(n){return i(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?a(r[n]):r[n]&&r[n][e]}},function(n,e){n.exports=!1},function(n,e,t){var r=t(0),i=t(19),a=r.Object;n.exports=function(n){return a(i(n))}},function(n,e,t){"use strict";var r=t(1),i=t(94);r({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(n,e,t){var r=t(0).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e,t){"use strict";function r(n,e,t,r,i,a,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),a&&(c._scopeId="data-v-"+a),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),i&&i.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):i&&(l=s?function(){i.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:i),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var u=c.beforeCreate;c.beforeCreate=u?[].concat(u,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(58),i=t(19);n.exports=function(n){return r(i(n))}},function(n,e,t){var r=t(0),i=t(4),a=t(61),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a function")}},function(n,e,t){var r=t(3),i=r({}.toString),a=r("".slice);n.exports=function(n){return a(i(n),8,-1)}},function(n,e,t){var r=t(8),i=t(12),a=t(51);n.exports=r?function(n,e,t){return i.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var r=t(15);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(50);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(172).charAt,i=t(13),a=t(37),o=t(155),s=a.set,l=a.getterFor("String Iterator");o(String,"String",(function(n){s(this,{type:"String Iterator",string:i(n),index:0})}),(function(){var n,e=l(this),t=e.string,i=e.index;return i>=t.length?{value:void 0,done:!0}:(n=r(t,i),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(14),i=t(280),a=Error.prototype;a.toString!==i&&r(a,"toString",i)},function(n,e,t){var r=t(190),i="object"==typeof self&&self&&self.Object===Object&&self,a=r||i||Function("return this")();n.exports=a},function(n,e,t){"use strict";var r=t(1),i=t(56).filter;r({target:"Array",proto:!0,forced:!t(92)("filter")},{filter:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(3);n.exports=r({}.isPrototypeOf)},function(n,e,t){var r,i=t(10),a=t(140),o=t(112),s=t(63),l=t(154),c=t(83),d=t(86),u=d("IE_PROTO"),h=function(){},p=function(n){return"<script>"+n+"<\/script>"},m=function(n){n.write(p("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&r?m(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(p("document.F=Object")),n.close(),n.F):m(r);for(var t=o.length;t--;)delete g.prototype[o[t]];return g()};s[u]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(h.prototype=i(n),t=new h,h.prototype=null,t[u]=n):t=g(),void 0===e?t:a.f(t,e)}},function(n,e,t){var r=t(0),i=t(173),a=t(174),o=t(148),s=t(24),l=t(5),c=l("iterator"),d=l("toStringTag"),u=o.values,h=function(n,e){if(n){if(n[c]!==u)try{s(n,c,u)}catch(e){n[c]=u}if(n[d]||s(n,d,e),i[e])for(var t in o)if(n[t]!==o[t])try{s(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var p in i)h(r[p]&&r[p].prototype,p);h(a,"DOMTokenList")},function(n,e,t){"use strict";var r=t(1),i=t(179);r({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(n,e,t){var r=t(0),i=t(173),a=t(174),o=t(179),s=t(24),l=function(n){if(n&&n.forEach!==o)try{s(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in i)i[c]&&l(r[c]&&r[c].prototype);l(a)},function(n,e,t){var r,i,a,o=t(239),s=t(0),l=t(3),c=t(11),d=t(24),u=t(9),h=t(108),p=t(86),m=t(63),g=s.TypeError,f=s.WeakMap;if(o||h.state){var v=h.state||(h.state=new f),b=l(v.get),y=l(v.has),x=l(v.set);r=function(n,e){if(y(v,n))throw new g("Object already initialized");return e.facade=n,x(v,n,e),e},i=function(n){return b(v,n)||{}},a=function(n){return y(v,n)}}else{var k=p("state");m[k]=!0,r=function(n,e){if(u(n,k))throw new g("Object already initialized");return e.facade=n,d(n,k,e),e},i=function(n){return u(n,k)?n[k]:{}},a=function(n){return u(n,k)}}n.exports={set:r,get:i,has:a,enforce:function(n){return a(n)?i(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=i(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(8),i=t(7),a=t(113),o=t(51),s=t(21),l=t(84),c=t(9),d=t(151),u=Object.getOwnPropertyDescriptor;e.f=r?u:function(n,e){if(n=s(n),e=l(e),d)try{return u(n,e)}catch(n){}if(c(n,e))return o(!i(a.f,n,e),n[e])}},function(n,e,t){var r=t(59),i=Function.prototype,a=i.apply,o=i.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(a):function(){return o.apply(a,arguments)})},function(n,e,t){var r=t(1),i=t(0),a=t(39),o=t(276),s=i.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,arity:1,forced:l},t)},d=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return a(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return a(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return a(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return a(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return a(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return a(n,this,arguments)}})),c("URIError",(function(n){return function(e){return a(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return a(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return a(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return a(n,this,arguments)}}))},function(n,e,t){var r=t(300),i=t(303);n.exports=function(n,e){var t=i(n,e);return r(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return a})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return u})),t.d(e,"f",(function(){return h})),t.d(e,"l",(function(){return p})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(18),t(44),t(137),t(79),t(104),t(126),t(43),t(35),t(6),t(36),t(31),t(81),t(102),t(211),t(77),t(212),t(29),t(147);var r=/#.*$/,i=/\.(md|html)$/,a=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(i,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function u(n){if(l(n))return n;if(!n)return"404";var e=n.match(r),t=e?e[0]:"",i=s(n);return a.test(i)?n:i+".html"+t}function h(n,e){var t=n.hash,i=function(n){var e=n&&n.match(r);if(e)return e[0]}(e);return(!i||t===i)&&s(n.path)===s(e)}function p(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}""!==i[0]&&i.unshift("");return i.join("/")}(e,t));for(var r=s(e),i=0;i<n.length;i++)if(s(n[i].regularPath)===r)return Object.assign({},n[i],{type:"page",path:u(n[i].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function m(n,e,t,r){var i=t.pages,a=t.themeConfig,o=r&&a.locales&&a.locales[r]||a;if("auto"===(n.frontmatter.sidebar||o.sidebar||a.sidebar))return g(n);var s=o.sidebar||a.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,d=l.config;return"auto"===d?g(n):d?d.map((function(n){return function n(e,t,r){var i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return p(t,e,r);if(Array.isArray(e))return Object.assign(p(t,e[0],r),{title:e[1]});i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var a=e.children||[];return 0===a.length&&e.path?Object.assign(p(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:a.map((function(e){return n(e,t,r,i+1)})),collapsable:!1!==e.collapsable}}(n,i,c)})):[]}return[]}function g(n){var e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function f(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){"use strict";var r=t(1),i=t(56).map;r({target:"Array",proto:!0,forced:!t(92)("map")},{map:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(3),o=t(123),s=t(2),l=t(10),c=t(4),d=t(62),u=t(50),h=t(13),p=t(19),m=t(124),g=t(49),f=t(281),v=t(125),b=t(5)("replace"),y=Math.max,x=Math.min,k=a([].concat),w=a([].push),_=a("".indexOf),E=a("".slice),T="$0"==="a".replace(/./,"$0"),A=!!/./[b]&&""===/./[b]("a","$0");o("replace",(function(n,e,t){var a=A?"$":"$0";return[function(n,t){var r=p(this),a=null==n?void 0:g(n,b);return a?i(a,n,r,t):i(e,h(r),n,t)},function(n,i){var o=l(this),s=h(n);if("string"==typeof i&&-1===_(i,a)&&-1===_(i,"$<")){var p=t(e,o,s,i);if(p.done)return p.value}var g=c(i);g||(i=h(i));var b=o.global;if(b){var T=o.unicode;o.lastIndex=0}for(var A=[];;){var I=v(o,s);if(null===I)break;if(w(A,I),!b)break;""===h(I[0])&&(o.lastIndex=m(s,u(o.lastIndex),T))}for(var j,S="",z=0,C=0;C<A.length;C++){for(var $=h((I=A[C])[0]),O=y(x(d(I.index),s.length),0),P=[],D=1;D<I.length;D++)w(P,void 0===(j=I[D])?j:String(j));var M=I.groups;if(g){var R=k([$],P,O,s);void 0!==M&&w(R,M);var G=h(r(i,void 0,R))}else G=f($,s,O,P,M,i);O>=z&&(S+=E(s,z,O)+G,z=O+$.length)}return S+E(s,z)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!T||A)},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var r=t(16),i=t(108);(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.4",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.4/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(48),i=t(2);n.exports=!!Object.getOwnPropertySymbols&&!i((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,i,a=t(0),o=t(26),s=a.process,l=a.Deno,c=s&&s.versions||l&&l.version,d=c&&c.v8;d&&(i=(r=d.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(i=+r[1]),n.exports=i},function(n,e,t){var r=t(22);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e,t){var r=t(62),i=Math.min;n.exports=function(n){return n>0?i(r(n),9007199254740991):0}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(0);n.exports=r.Promise},function(n,e,t){"use strict";var r=t(2);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(72),o=t(90),s=t(11),l=t(111),c=t(27),d=t(21),u=t(73),h=t(5),p=t(92),m=t(69),g=p("slice"),f=h("species"),v=i.Array,b=Math.max;r({target:"Array",proto:!0,forced:!g},{slice:function(n,e){var t,r,i,h=d(this),p=c(h),g=l(n,p),y=l(void 0===e?p:e,p);if(a(h)&&(t=h.constructor,(o(t)&&(t===v||a(t.prototype))||s(t)&&null===(t=t[f]))&&(t=void 0),t===v||void 0===t))return m(h,g,y);for(r=new(void 0===t?v:t)(b(y-g,0)),i=0;g<y;g++,i++)g in h&&u(r,i,h[g]);return r.length=i,r}})},function(n,e,t){var r=t(153),i=t(112).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,i)}},function(n,e,t){var r=t(68),i=t(3),a=t(58),o=t(17),s=t(27),l=t(175),c=i([].push),d=function(n){var e=1==n,t=2==n,i=3==n,d=4==n,u=6==n,h=7==n,p=5==n||u;return function(m,g,f,v){for(var b,y,x=o(m),k=a(x),w=r(g,f),_=s(k),E=0,T=v||l,A=e?T(m,_):t||h?T(m,0):void 0;_>E;E++)if((p||E in k)&&(y=w(b=k[E],E,x),n))if(e)A[E]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return E;case 2:c(A,b)}else switch(n){case 4:return!1;case 7:c(A,b)}return u?-1:i||d?d:A}};n.exports={forEach:d(0),map:d(1),filter:d(2),some:d(3),every:d(4),find:d(5),findIndex:d(6),filterReject:d(7)}},function(n,e,t){var r=t(74),i=t(285),a=t(286),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?i(n):a(n)}},function(n,e,t){var r=t(0),i=t(3),a=t(2),o=t(23),s=r.Object,l=i("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?l(n,""):s(n)}:s},function(n,e,t){var r=t(2);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(0),i=t(15),a=t(4),o=t(32),s=t(149),l=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=i("Symbol");return a(e)&&o(e.prototype,l(n))}},function(n,e,t){var r=t(0).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(8),i=t(9),a=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=i(a,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(a,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(12).f,i=t(9),a=t(5)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!i(n,a)&&r(n,a,{configurable:!0,value:e})}},function(n,e,t){var r=t(3),i=t(10),a=t(241);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return i(t),a(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(3),i=t(22),a=t(59),o=r(r.bind);n.exports=function(n,e){return i(n),void 0===e?n:a?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(3);n.exports=r([].slice)},function(n,e,t){var r=t(0),i=t(52),a=t(4),o=t(105),s=t(87),l=t(5),c=t(250),d=t(16),u=t(48),h=i&&i.prototype,p=l("species"),m=!1,g=a(r.PromiseRejectionEvent),f=o("Promise",(function(){var n=s(i),e=n!==String(i);if(!e&&66===u)return!0;if(d&&(!h.catch||!h.finally))return!0;if(u>=51&&/native code/.test(n))return!1;var t=new i((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[p]=r,!(m=t.then((function(){}))instanceof r)||!e&&c&&!g}));n.exports={CONSTRUCTOR:f,REJECTION_EVENT:g,SUBCLASSING:m}},function(n,e,t){"use strict";var r=t(22),i=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new i(n)}},function(n,e,t){var r=t(23);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){"use strict";var r=t(84),i=t(12),a=t(51);n.exports=function(n,e,t){var o=r(e);o in n?i.f(n,o,a(0,t)):n[o]=t}},function(n,e,t){var r=t(30).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(81);var r=t(76);t(80),t(93),t(6),t(122),t(28),t(34),t(185);var i=t(100);t(40),t(29);function a(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(i.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(2),o=t(72),s=t(11),l=t(17),c=t(27),d=t(73),u=t(175),h=t(92),p=t(5),m=t(48),g=p("isConcatSpreadable"),f=i.TypeError,v=m>=51||!a((function(){var n=[];return n[g]=!1,n.concat()[0]!==n})),b=h("concat"),y=function(n){if(!s(n))return!1;var e=n[g];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,arity:1,forced:!v||!b},{concat:function(n){var e,t,r,i,a,o=l(this),s=u(o,0),h=0;for(e=-1,r=arguments.length;e<r;e++)if(y(a=-1===e?o:arguments[e])){if(h+(i=c(a))>9007199254740991)throw f("Maximum allowed index exceeded");for(t=0;t<i;t++,h++)t in a&&d(s,h,a[t])}else{if(h>=9007199254740991)throw f("Maximum allowed index exceeded");d(s,h++,a)}return s.length=h,s}})},function(n,e,t){t(376),t(377)},function(n,e,t){"use strict";t(18);var r,i,a=t(1),o=t(0),s=t(7),l=t(3),c=t(4),d=t(11),u=(r=!1,(i=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===i.test("abc")&&r),h=o.Error,p=l(/./.test);a({target:"RegExp",proto:!0,forced:!u},{test:function(n){var e=this.exec;if(!c(e))return p(this,n);var t=s(e,this,n);if(null!==t&&!d(t))throw new h("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){t(268),t(271),t(272),t(121),t(273)},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(72)})},function(n,e,t){var r=t(3),i=0,a=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++i+a,36)}},function(n,e,t){var r=t(0),i=t(11),a=r.document,o=i(a)&&i(a.createElement);n.exports=function(n){return o?a.createElement(n):{}}},function(n,e,t){var r=t(152),i=t(60);n.exports=function(n){var e=r(n,"string");return i(e)?e:e+""}},function(n,e,t){var r=t(153),i=t(112);n.exports=Object.keys||function(n){return r(n,i)}},function(n,e,t){var r=t(46),i=t(82),a=r("keys");n.exports=function(n){return a[n]||(a[n]=i(n))}},function(n,e,t){var r=t(3),i=t(4),a=t(108),o=r(Function.toString);i(a.inspectSource)||(a.inspectSource=function(n){return o(n)}),n.exports=a.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(23),i=t(0);n.exports="process"==r(i.process)},function(n,e,t){var r=t(3),i=t(2),a=t(4),o=t(91),s=t(15),l=t(87),c=function(){},d=[],u=s("Reflect","construct"),h=/^\s*(?:class|function)\b/,p=r(h.exec),m=!h.exec(c),g=function(n){if(!a(n))return!1;try{return u(c,d,n),!0}catch(n){return!1}},f=function(n){if(!a(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return m||!!p(h,l(n))}catch(n){return!0}};f.sham=!0,n.exports=!u||i((function(){var n;return g(g.call)||!g(Object)||!g((function(){n=!0}))||n}))?f:g},function(n,e,t){var r=t(0),i=t(117),a=t(4),o=t(23),s=t(5)("toStringTag"),l=r.Object,c="Arguments"==o(function(){return arguments}());n.exports=i?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?o(e):"Object"==(r=o(e))&&a(e.callee)?"Arguments":r}},function(n,e,t){var r=t(2),i=t(5),a=t(48),o=i("species");n.exports=function(n){return a>=51||!r((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var r=t(1),i=t(8),a=t(0),o=t(3),s=t(9),l=t(4),c=t(32),d=t(13),u=t(12).f,h=t(114),p=a.Symbol,m=p&&p.prototype;if(i&&l(p)&&(!("description"in m)||void 0!==p().description)){var g={},f=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:d(arguments[0]),e=c(m,this)?new p(n):void 0===n?p():p(n);return""===n&&(g[e]=!0),e};h(f,p),f.prototype=m,m.constructor=f;var v="Symbol(test)"==String(p("test")),b=o(m.toString),y=o(m.valueOf),x=/^Symbol\((.*)\)[^)]+$/,k=o("".replace),w=o("".slice);u(m,"description",{configurable:!0,get:function(){var n=y(this),e=b(n);if(s(g,n))return"";var t=v?w(e,7,-1):k(e,x,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:f})}},function(n,e,t){"use strict";var r,i,a=t(7),o=t(3),s=t(13),l=t(186),c=t(107),d=t(46),u=t(33),h=t(37).get,p=t(225),m=t(228),g=d("native-string-replace",String.prototype.replace),f=RegExp.prototype.exec,v=f,b=o("".charAt),y=o("".indexOf),x=o("".replace),k=o("".slice),w=(i=/b*/g,a(f,r=/a/,"a"),a(f,i,"a"),0!==r.lastIndex||0!==i.lastIndex),_=c.BROKEN_CARET,E=void 0!==/()??/.exec("")[1];(w||E||_||p||m)&&(v=function(n){var e,t,r,i,o,c,d,p=this,m=h(p),T=s(n),A=m.raw;if(A)return A.lastIndex=p.lastIndex,e=a(v,A,T),p.lastIndex=A.lastIndex,e;var I=m.groups,j=_&&p.sticky,S=a(l,p),z=p.source,C=0,$=T;if(j&&(S=x(S,"y",""),-1===y(S,"g")&&(S+="g"),$=k(T,p.lastIndex),p.lastIndex>0&&(!p.multiline||p.multiline&&"\n"!==b(T,p.lastIndex-1))&&(z="(?: "+z+")",$=" "+$,C++),t=new RegExp("^(?:"+z+")",S)),E&&(t=new RegExp("^"+z+"$(?!\\s)",S)),w&&(r=p.lastIndex),i=a(f,j?t:p,$),j?i?(i.input=k(i.input,C),i[0]=k(i[0],C),i.index=p.lastIndex,p.lastIndex+=i[0].length):p.lastIndex=0:w&&i&&(p.lastIndex=p.global?i.index+i[0].length:r),E&&i&&i.length>1&&a(g,i[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(i[o]=void 0)})),i&&I)for(i.groups=c=u(null),o=0;o<I.length;o++)c[(d=I[o])[0]]=i[d[1]];return i}),n.exports=v},function(n,e,t){var r=t(290),i=t(291),a=t(292),o=t(293),s=t(294);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(192);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(41)(Object,"create");n.exports=r},function(n,e,t){var r=t(312);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(134);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(54),t(6),t(106),t(185),t(28),t(18),t(79);var r=t(76);function i(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(n,e,t){return n<e?e:n>t?t:n}function a(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=i(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),d=r.speed,u=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+a(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+a(n)+"%,0)"}:{"margin-left":a(n)+"%"}).transition="all "+e+"ms "+t,i}(n,d,u)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*i(Math.random()*e,.1,.95)),e=i(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var i,o=e.querySelector(r.barSelector),l=n?"-100":a(t.status||0),d=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(i=e.querySelector(r.spinnerSelector))&&h(i),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&h(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,i=n.length,a=e.charAt(0).toUpperCase()+e.slice(1);i--;)if((r=n[i]+a)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,i,a=arguments;if(2==a.length)for(t in e)void 0!==(i=e[t])&&e.hasOwnProperty(t)&&r(n,t,i);else r(n,a[1],a[2])}}();function l(n,e){return("string"==typeof n?n:u(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=u(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=u(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function u(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function h(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=i)},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(110).indexOf,o=t(53),s=i([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=o("indexOf");r({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:a(this,n,e)}})},function(n,e,t){var r=t(1),i=t(17),a=t(85);r({target:"Object",stat:!0,forced:t(2)((function(){a(1)}))},{keys:function(n){return a(i(n))}})},function(n,e,t){"use strict";var r=t(39),i=t(7),a=t(3),o=t(123),s=t(141),l=t(10),c=t(19),d=t(116),u=t(124),h=t(50),p=t(13),m=t(49),g=t(120),f=t(125),v=t(94),b=t(107),y=t(2),x=b.UNSUPPORTED_Y,k=Math.min,w=[].push,_=a(/./.exec),E=a(w),T=a("".slice);o("split",(function(n,e,t){var a;return a="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var a=p(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[a];if(!s(n))return i(e,a,n,o);for(var l,d,u,h=[],m=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),f=0,b=new RegExp(n.source,m+"g");(l=i(v,b,a))&&!((d=b.lastIndex)>f&&(E(h,T(a,f,l.index)),l.length>1&&l.index<a.length&&r(w,h,g(l,1)),u=l[0].length,f=d,h.length>=o));)b.lastIndex===l.index&&b.lastIndex++;return f===a.length?!u&&_(b,"")||E(h,""):E(h,T(a,f)),h.length>o?g(h,0,o):h}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:i(e,this,n,t)}:e,[function(e,t){var r=c(this),o=null==e?void 0:m(e,n);return o?i(o,e,r,t):i(a,p(r),e,t)},function(n,r){var i=l(this),o=p(n),s=t(a,i,o,r,a!==e);if(s.done)return s.value;var c=d(i,RegExp),m=i.unicode,g=(i.ignoreCase?"i":"")+(i.multiline?"m":"")+(i.unicode?"u":"")+(x?"g":"y"),v=new c(x?"^(?:"+i.source+")":i,g),b=void 0===r?4294967295:r>>>0;if(0===b)return[];if(0===o.length)return null===f(v,o)?[o]:[];for(var y=0,w=0,_=[];w<o.length;){v.lastIndex=x?0:w;var A,I=f(v,x?T(o,w):o);if(null===I||(A=k(h(v.lastIndex+(x?w:0)),o.length))===y)w=u(o,w,m);else{if(E(_,T(o,y,w)),_.length===b)return _;for(var j=1;j<=I.length-1;j++)if(E(_,I[j]),_.length===b)return _;w=y=A}}return E(_,T(o,y)),_}]}),!!y((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),x)},function(n,e,t){var r=t(2),i=t(4),a=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==d||t!=c&&(i(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",d=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(8),i=t(65).EXISTS,a=t(3),o=t(12).f,s=Function.prototype,l=a(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,d=a(c.exec);r&&!i&&o(s,"name",{configurable:!0,get:function(){try{return d(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(2),i=t(0).RegExp,a=r((function(){var n=i("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=a||r((function(){return!i("a","y").sticky})),s=a||r((function(){var n=i("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:o,UNSUPPORTED_Y:a}},function(n,e,t){var r=t(0),i=t(109),a=r["__core-js_shared__"]||i("__core-js_shared__",{});n.exports=a},function(n,e,t){var r=t(0),i=Object.defineProperty;n.exports=function(n,e){try{i(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(21),i=t(111),a=t(27),o=function(n){return function(e,t,o){var s,l=r(e),c=a(l),d=i(o,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var r=t(62),i=Math.max,a=Math.min;n.exports=function(n,e){var t=r(n);return t<0?i(t+e,0):a(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,a=i&&!r.call({1:2},1);e.f=a?function(n){var e=i(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(9),i=t(157),a=t(38),o=t(12);n.exports=function(n,e,t){for(var s=i(e),l=o.f,c=a.f,d=0;d<s.length;d++){var u=s[d];r(n,u)||t&&r(t,u)||l(n,u,c(e,u))}}},function(n,e,t){var r=t(0),i=t(9),a=t(4),o=t(17),s=t(86),l=t(159),c=s("IE_PROTO"),d=r.Object,u=d.prototype;n.exports=l?d.getPrototypeOf:function(n){var e=o(n);if(i(e,c))return e[c];var t=e.constructor;return a(t)&&e instanceof t?t.prototype:e instanceof d?u:null}},function(n,e,t){var r=t(10),i=t(160),a=t(5)("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[a])?e:i(t)}},function(n,e,t){var r={};r[t(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(91),i=t(49),a=t(64),o=t(5)("iterator");n.exports=function(n){if(null!=n)return i(n,o)||i(n,"@@iterator")||a[r(n)]}},function(n,e,t){var r=t(0),i=t(111),a=t(27),o=t(73),s=r.Array,l=Math.max;n.exports=function(n,e,t){for(var r=a(n),c=i(e,r),d=i(void 0===t?r:t,r),u=s(l(d-c,0)),h=0;c<d;c++,h++)o(u,h,n[c]);return u.length=h,u}},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(7),s=t(3),l=t(2),c=t(72),d=t(4),u=t(11),h=t(60),p=t(69),m=t(47),g=i("JSON","stringify"),f=s(/./.exec),v=s("".charAt),b=s("".charCodeAt),y=s("".replace),x=s(1..toString),k=/[\uD800-\uDFFF]/g,w=/^[\uD800-\uDBFF]$/,_=/^[\uDC00-\uDFFF]$/,E=!m||l((function(){var n=i("Symbol")();return"[null]"!=g([n])||"{}"!=g({a:n})||"{}"!=g(Object(n))})),T=l((function(){return'"\\udf06\\ud834"'!==g("\udf06\ud834")||'"\\udead"'!==g("\udead")})),A=function(n,e){var t=p(arguments),r=e;if((u(e)||void 0!==n)&&!h(n))return c(e)||(e=function(n,e){if(d(r)&&(e=o(r,this,n,e)),!h(e))return e}),t[1]=e,a(g,null,t)},I=function(n,e,t){var r=v(t,e-1),i=v(t,e+1);return f(w,n)&&!f(_,i)||f(_,n)&&!f(w,r)?"\\u"+x(b(n,0),16):n};g&&r({target:"JSON",stat:!0,arity:3,forced:E||T},{stringify:function(n,e,t){var r=p(arguments),i=a(E?A:g,null,r);return T&&"string"==typeof i?y(i,k,I):i}})},function(n,e,t){t(183)("iterator")},function(n,e,t){"use strict";t(18);var r=t(3),i=t(14),a=t(94),o=t(2),s=t(5),l=t(24),c=s("species"),d=RegExp.prototype;n.exports=function(n,e,t,u){var h=s(n),p=!o((function(){var e={};return e[h]=function(){return 7},7!=""[n](e)})),m=p&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[h]=/./[h]),t.exec=function(){return e=!0,null},t[h](""),!e}));if(!p||!m||t){var g=r(/./[h]),f=e(h,""[n],(function(n,e,t,i,o){var s=r(n),l=e.exec;return l===a||l===d.exec?p&&!o?{done:!0,value:g(e,t,i)}:{done:!0,value:s(t,e,i)}:{done:!1}}));i(String.prototype,n,f[0]),i(d,h,f[1])}u&&l(d[h],"sham",!0)}},function(n,e,t){"use strict";var r=t(172).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(0),i=t(7),a=t(10),o=t(4),s=t(23),l=t(94),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var r=i(t,n,e);return null!==r&&a(r),r}if("RegExp"===s(n))return i(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(58),o=t(21),s=t(53),l=i([].join),c=a!=Object,d=s("join",",");r({target:"Array",proto:!0,forced:c||!d},{join:function(n){return l(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(284),i=t(45),a=Object.prototype,o=a.hasOwnProperty,s=a.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return i(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(41)(t(30),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(304),i=t(311),a=t(313),o=t(314),s=t(315);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(25),i=t(134),a=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!i(n))||(o.test(n)||!a.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(57),i=t(45);n.exports=function(n){return"symbol"==typeof n||i(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(1),i=t(56).some;r({target:"Array",proto:!0,forced:!t(53)("some")},{some:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(7),i=t(123),a=t(10),o=t(50),s=t(13),l=t(19),c=t(49),d=t(124),u=t(125);i("match",(function(n,e,t){return[function(e){var t=l(this),i=null==e?void 0:c(e,n);return i?r(i,e,t):new RegExp(e)[n](s(t))},function(n){var r=a(this),i=s(n),l=t(e,r,i);if(l.done)return l.value;if(!r.global)return u(r,i);var c=r.unicode;r.lastIndex=0;for(var h,p=[],m=0;null!==(h=u(r,i));){var g=s(h[0]);p[m]=g,""===g&&(r.lastIndex=d(i,o(r.lastIndex),c)),m++}return 0===m?null:p}]}))},function(n,e,t){var r=t(1),i=t(8),a=t(12).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==a,sham:!i},{defineProperty:a})},function(n,e,t){var r=t(5),i=t(33),a=t(12),o=r("unscopables"),s=Array.prototype;null==s[o]&&a.f(s,o,{configurable:!0,value:i(null)}),n.exports=function(n){s[o][n]=!0}},function(n,e,t){var r=t(8),i=t(150),a=t(12),o=t(10),s=t(21),l=t(85);e.f=r&&!i?Object.defineProperties:function(n,e){o(n);for(var t,r=s(e),i=l(e),c=i.length,d=0;c>d;)a.f(n,t=i[d++],r[t]);return n}},function(n,e,t){var r=t(11),i=t(23),a=t(5)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[a])?!!e:"RegExp"==i(n))}},function(n,e,t){var r=t(4),i=t(11),a=t(67);n.exports=function(n,e,t){var o,s;return a&&r(o=e.constructor)&&o!==t&&i(s=o.prototype)&&s!==t.prototype&&a(n,s),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,a=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),d=Object.prototype.toString,u=Math.max,h=Math.min,p=function(){return c.Date.now()};function m(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(m(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=m(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=i.test(n);return s||a.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,i,a,o,s,l,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=r,a=i;return r=i=void 0,c=e,o=n.apply(a,t)}function y(n){return c=n,s=setTimeout(k,e),d?b(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||f&&n-c>=a}function k(){var n=p();if(x(n))return w(n);s=setTimeout(k,function(n){var t=e-(n-l);return f?h(t,a-(n-c)):t}(n))}function w(n){return s=void 0,v&&r?b(n):(r=i=void 0,o)}function _(){var n=p(),t=x(n);if(r=arguments,i=this,l=n,t){if(void 0===s)return y(l);if(f)return s=setTimeout(k,e),b(l)}return void 0===s&&(s=setTimeout(k,e)),o}return e=g(e)||0,m(t)&&(d=!!t.leading,a=(f="maxWait"in t)?u(g(t.maxWait)||0,e):a,v="trailing"in t?!!t.trailing:v),_.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=i=s=void 0},_.flush=function(){return void 0===s?o:w(p())},_}},function(n,e,t){var r=t(3),i=t(19),a=t(13),o=t(146),s=r("".replace),l="["+o+"]",c=RegExp("^"+l+l+"*"),d=RegExp(l+l+"*$"),u=function(n){return function(e){var t=a(i(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,d,"")),t}};n.exports={start:u(1),end:u(2),trim:u(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){"use strict";var r=t(65).PROPER,i=t(14),a=t(10),o=t(13),s=t(2),l=t(234),c=RegExp.prototype.toString,d=s((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),u=r&&"toString"!=c.name;(d||u)&&i(RegExp.prototype,"toString",(function(){var n=a(this);return"/"+o(n.source)+"/"+o(l(n))}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(21),i=t(139),a=t(64),o=t(37),s=t(12).f,l=t(155),c=t(16),d=t(8),u=o.set,h=o.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){u(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=h(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var p=a.Arguments=a.Array;if(i("keys"),i("values"),i("entries"),!c&&d&&"values"!==p.name)try{s(p,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(47);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(8),i=t(2);n.exports=r&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(8),i=t(2),a=t(83);n.exports=!r&&!i((function(){return 7!=Object.defineProperty(a("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(0),i=t(7),a=t(11),o=t(60),s=t(49),l=t(238),c=t(5),d=r.TypeError,u=c("toPrimitive");n.exports=function(n,e){if(!a(n)||o(n))return n;var t,r=s(n,u);if(r){if(void 0===e&&(e="default"),t=i(r,n,e),!a(t)||o(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var r=t(3),i=t(9),a=t(21),o=t(110).indexOf,s=t(63),l=r([].push);n.exports=function(n,e){var t,r=a(n),c=0,d=[];for(t in r)!i(s,t)&&i(r,t)&&l(d,t);for(;e.length>c;)i(r,t=e[c++])&&(~o(d,t)||l(d,t));return d}},function(n,e,t){var r=t(15);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(16),o=t(65),s=t(4),l=t(240),c=t(115),d=t(67),u=t(66),h=t(24),p=t(14),m=t(5),g=t(64),f=t(158),v=o.PROPER,b=o.CONFIGURABLE,y=f.IteratorPrototype,x=f.BUGGY_SAFARI_ITERATORS,k=m("iterator"),w=function(){return this};n.exports=function(n,e,t,o,m,f,_){l(t,e,o);var E,T,A,I=function(n){if(n===m&&$)return $;if(!x&&n in z)return z[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},j=e+" Iterator",S=!1,z=n.prototype,C=z[k]||z["@@iterator"]||m&&z[m],$=!x&&C||I(m),O="Array"==e&&z.entries||C;if(O&&(E=c(O.call(new n)))!==Object.prototype&&E.next&&(a||c(E)===y||(d?d(E,y):s(E[k])||p(E,k,w)),u(E,j,!0,!0),a&&(g[j]=w)),v&&"values"==m&&C&&"values"!==C.name&&(!a&&b?h(z,"name","values"):(S=!0,$=function(){return i(C,this)})),m)if(T={values:I("values"),keys:f?$:I("keys"),entries:I("entries")},_)for(A in T)(x||S||!(A in z))&&p(z,A,T[A]);else r({target:e,proto:!0,forced:x||S},T);return a&&!_||z[k]===$||p(z,k,$,{name:m}),g[e]=$,T}},function(n,e,t){var r=t(2),i=t(4),a=t(9),o=t(12).f,s=t(65).CONFIGURABLE,l=t(87),c=t(37),d=c.enforce,u=c.get,h=!r((function(){return 8!==o((function(){}),"length",{value:8}).length})),p=String(String).split("String"),m=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!a(n,"name")||s&&n.name!==e)&&o(n,"name",{value:e,configurable:!0}),h&&t&&a(t,"arity")&&n.length!==t.arity&&o(n,"length",{value:t.arity});var r=d(n);return a(r,"source")||(r.source=p.join("string"==typeof e?e:"")),n};Function.prototype.toString=m((function(){return i(this)&&u(this).source||l(this)}),"toString")},function(n,e,t){var r=t(15),i=t(3),a=t(55),o=t(88),s=t(10),l=i([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r,i,a,o=t(2),s=t(4),l=t(33),c=t(115),d=t(14),u=t(5),h=t(16),p=u("iterator"),m=!1;[].keys&&("next"in(a=[].keys())?(i=c(c(a)))!==Object.prototype&&(r=i):m=!0),null==r||o((function(){var n={};return r[p].call(n)!==n}))?r={}:h&&(r=l(r)),s(r[p])||d(r,p,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:m}},function(n,e,t){var r=t(2);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(0),i=t(90),a=t(61),o=r.TypeError;n.exports=function(n){if(i(n))return n;throw o(a(n)+" is not a constructor")}},function(n,e,t){var r,i,a,o,s=t(0),l=t(39),c=t(68),d=t(4),u=t(9),h=t(2),p=t(154),m=t(69),g=t(83),f=t(162),v=t(163),b=t(89),y=s.setImmediate,x=s.clearImmediate,k=s.process,w=s.Dispatch,_=s.Function,E=s.MessageChannel,T=s.String,A=0,I={};try{r=s.location}catch(n){}var j=function(n){if(u(I,n)){var e=I[n];delete I[n],e()}},S=function(n){return function(){j(n)}},z=function(n){j(n.data)},C=function(n){s.postMessage(T(n),r.protocol+"//"+r.host)};y&&x||(y=function(n){f(arguments.length,1);var e=d(n)?n:_(n),t=m(arguments,1);return I[++A]=function(){l(e,void 0,t)},i(A),A},x=function(n){delete I[n]},b?i=function(n){k.nextTick(S(n))}:w&&w.now?i=function(n){w.now(S(n))}:E&&!v?(o=(a=new E).port2,a.port1.onmessage=z,i=c(o.postMessage,o)):s.addEventListener&&d(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!h(C)?(i=C,s.addEventListener("message",z,!1)):i="onreadystatechange"in g("script")?function(n){p.appendChild(g("script")).onreadystatechange=function(){p.removeChild(this),j(n)}}:function(n){setTimeout(S(n),0)}),n.exports={set:y,clear:x}},function(n,e,t){var r=t(0).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(26);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(0),i=t(68),a=t(7),o=t(10),s=t(61),l=t(165),c=t(27),d=t(32),u=t(166),h=t(119),p=t(167),m=r.TypeError,g=function(n,e){this.stopped=n,this.result=e},f=g.prototype;n.exports=function(n,e,t){var r,v,b,y,x,k,w,_=t&&t.that,E=!(!t||!t.AS_ENTRIES),T=!(!t||!t.IS_ITERATOR),A=!(!t||!t.INTERRUPTED),I=i(e,_),j=function(n){return r&&p(r,"normal",n),new g(!0,n)},S=function(n){return E?(o(n),A?I(n[0],n[1],j):I(n[0],n[1])):A?I(n,j):I(n)};if(T)r=n;else{if(!(v=h(n)))throw m(s(n)+" is not iterable");if(l(v)){for(b=0,y=c(n);y>b;b++)if((x=S(n[b]))&&d(f,x))return x;return new g(!1)}r=u(n,v)}for(k=r.next;!(w=a(k,r)).done;){try{x=S(w.value)}catch(n){p(r,"throw",n)}if("object"==typeof x&&x&&d(f,x))return x}return new g(!1)}},function(n,e,t){var r=t(5),i=t(64),a=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(i.Array===n||o[a]===n)}},function(n,e,t){var r=t(0),i=t(7),a=t(22),o=t(10),s=t(61),l=t(119),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(a(t))return o(i(t,n));throw c(s(n)+" is not iterable")}},function(n,e,t){var r=t(7),i=t(10),a=t(49);n.exports=function(n,e,t){var o,s;i(n);try{if(!(o=a(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return i(o),t}},function(n,e,t){var r=t(52),i=t(169),a=t(70).CONSTRUCTOR;n.exports=a||!i((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,e,t){var r=t(5)("iterator"),i=!1;try{var a=0,o={next:function(){return{done:!!a++}},return:function(){i=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!i)return!1;var t=!1;try{var a={};a[r]=function(){return{next:function(){return{done:t=!0}}}},n(a)}catch(n){}return t}},function(n,e,t){var r=t(10),i=t(11),a=t(71);n.exports=function(n,e){if(r(n),i(e)&&e.constructor===n)return e;var t=a.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var r=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,r="function"==typeof Symbol?Symbol:{},i=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",o=r.toStringTag||"@@toStringTag";function s(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{s({},"")}catch(n){s=function(n,e,t){return n[e]=t}}function l(n,e,t,r){var i=e&&e.prototype instanceof u?e:u,a=Object.create(i.prototype),o=new _(r||[]);return a._invoke=function(n,e,t){var r="suspendedStart";return function(i,a){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===i)throw a;return T()}for(t.method=i,t.arg=a;;){var o=t.delegate;if(o){var s=x(o,t);if(s){if(s===d)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=c(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===d)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),a}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var d={};function u(){}function h(){}function p(){}var m={};s(m,i,(function(){return this}));var g=Object.getPrototypeOf,f=g&&g(g(E([])));f&&f!==e&&t.call(f,i)&&(m=f);var v=p.prototype=u.prototype=Object.create(m);function b(n){["next","throw","return"].forEach((function(e){s(n,e,(function(n){return this._invoke(e,n)}))}))}function y(n,e){var r;this._invoke=function(i,a){function o(){return new e((function(r,o){!function r(i,a,o,s){var l=c(n[i],n,a);if("throw"!==l.type){var d=l.arg,u=d.value;return u&&"object"==typeof u&&t.call(u,"__await")?e.resolve(u.__await).then((function(n){r("next",n,o,s)}),(function(n){r("throw",n,o,s)})):e.resolve(u).then((function(n){d.value=n,o(d)}),(function(n){return r("throw",n,o,s)}))}s(l.arg)}(i,a,r,o)}))}return r=r?r.then(o,o):o()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var r=c(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,d;var i=r.arg;return i?i.done?(e[n.resultName]=i.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function k(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function _(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(k,this),this.reset(!0)}function E(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:T}}function T(){return{value:void 0,done:!0}}return h.prototype=p,s(v,"constructor",p),s(p,"constructor",h),h.displayName=s(p,o,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===h||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,p):(n.__proto__=p,s(n,o,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},b(y.prototype),s(y.prototype,a,(function(){return this})),n.AsyncIterator=y,n.async=function(e,t,r,i,a){void 0===a&&(a=Promise);var o=new y(l(e,t,r,i),a);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},b(v),s(v,o,"Generator"),s(v,i,(function(){return this})),s(v,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=E,_.prototype={constructor:_,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],o=a.completion;if("root"===a.tryLoc)return r("end");if(a.tryLoc<=this.prev){var s=t.call(a,"catchLoc"),l=t.call(a,"finallyLoc");if(s&&l){if(this.prev<a.catchLoc)return r(a.catchLoc,!0);if(this.prev<a.finallyLoc)return r(a.finallyLoc)}else if(s){if(this.prev<a.catchLoc)return r(a.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return r(a.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r];if(i.tryLoc<=this.prev&&t.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var a=i;break}}a&&("break"===n||"continue"===n)&&a.tryLoc<=e&&e<=a.finallyLoc&&(a=null);var o=a?a.completion:{};return o.type=n,o.arg=e,a?(this.method="next",this.next=a.finallyLoc,d):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var i=r.arg;w(t)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:E(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=r}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=r:Function("r","regeneratorRuntime = r")(r)}},function(n,e,t){var r=t(3),i=t(62),a=t(13),o=t(19),s=r("".charAt),l=r("".charCodeAt),c=r("".slice),d=function(n){return function(e,t){var r,d,u=a(o(e)),h=i(t),p=u.length;return h<0||h>=p?n?"":void 0:(r=l(u,h))<55296||r>56319||h+1===p||(d=l(u,h+1))<56320||d>57343?n?s(u,h):r:n?c(u,h,h+2):d-56320+(r-55296<<10)+65536}};n.exports={codeAt:d(!1),charAt:d(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(83)("span").classList,i=r&&r.constructor&&r.constructor.prototype;n.exports=i===Object.prototype?void 0:i},function(n,e,t){var r=t(260);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){var r=t(1),i=t(2),a=t(17),o=t(115),s=t(159);r({target:"Object",stat:!0,forced:i((function(){o(1)})),sham:!s},{getPrototypeOf:function(n){return o(a(n))}})},function(n,e,t){var r=t(0),i=t(141),a=r.TypeError;n.exports=function(n){if(i(n))throw a("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var r=t(56).forEach,i=t(53)("forEach");n.exports=i?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(2);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(23),i=t(21),a=t(55).f,o=t(120),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return a(n)}catch(n){return o(s)}}(n):a(i(n))}},function(n,e,t){var r=t(5);e.f=r},function(n,e,t){var r=t(269),i=t(9),a=t(182),o=t(12).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});i(e,n)||o(e,n,{value:a.f(n)})}},function(n,e,t){var r=t(47);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var r=t(1),i=t(274);r({target:"Array",stat:!0,forced:!t(169)((function(n){Array.from(n)}))},{from:i})},function(n,e,t){"use strict";var r=t(10);n.exports=function(){var n=r(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(13);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(8)},{create:t(33)})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,i=n.length;++t<r;)n[i+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(95),i=t(295),a=t(296),o=t(297),s=t(298),l=t(299);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=i,c.prototype.delete=a,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(57),i=t(129);n.exports=function(n){if(!i(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(316),i=t(45);n.exports=function n(e,t,a,o,s){return e===t||(null==e||null==t||!i(e)&&!i(t)?e!=e&&t!=t:r(e,t,a,o,n,s))}},function(n,e,t){var r=t(197),i=t(319),a=t(198);n.exports=function(n,e,t,o,s,l){var c=1&t,d=n.length,u=e.length;if(d!=u&&!(c&&u>d))return!1;var h=l.get(n),p=l.get(e);if(h&&p)return h==e&&p==n;var m=-1,g=!0,f=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++m<d;){var v=n[m],b=e[m];if(o)var y=c?o(b,v,m,e,n,l):o(v,b,m,n,e,l);if(void 0!==y){if(y)continue;g=!1;break}if(f){if(!i(e,(function(n,e){if(!a(f,e)&&(v===n||s(v,n,t,o,l)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!s(v,b,t,o,l)){g=!1;break}}return l.delete(n),l.delete(e),g}},function(n,e,t){var r=t(130),i=t(317),a=t(318);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=i,o.prototype.has=a,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(329),i=t(335),a=t(203);n.exports=function(n){return a(n)?r(n):i(n)}},function(n,e,t){(function(n){var r=t(30),i=t(331),a=e&&!e.nodeType&&e,o=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===a?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||i;n.exports=l}).call(this,t(143)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(332),i=t(333),a=t(334),o=a&&a.isTypedArray,s=o?i(o):r;n.exports=s},function(n,e,t){var r=t(193),i=t(132);n.exports=function(n){return null!=n&&i(n.length)&&!r(n)}},function(n,e,t){var r=t(41)(t(30),"Set");n.exports=r},function(n,e,t){var r=t(129);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(208),i=t(99);n.exports=function(n,e){for(var t=0,a=(e=r(e,n)).length;null!=n&&t<a;)n=n[i(e[t++])];return t&&t==a?n:void 0}},function(n,e,t){var r=t(25),i=t(133),a=t(346),o=t(349);n.exports=function(n,e){return r(n)?n:i(n,e)?[n]:a(o(n))}},function(n,e,t){var r=t(0),i=t(39),a=t(4),o=t(26),s=t(69),l=t(162),c=/MSIE .\./.test(o),d=r.Function,u=function(n){return c?function(e,t){var r=l(arguments.length,1)>2,o=a(e)?e:d(e),c=r?s(arguments,2):void 0;return n(r?function(){i(o,this,c)}:o,t)}:n};n.exports={setTimeout:u(r.setTimeout),setInterval:u(r.setInterval)}},function(n,e,t){"use strict";var r=t(0),i=t(3),a=t(22),o=t(11),s=t(9),l=t(69),c=t(59),d=r.Function,u=i([].concat),h=i([].join),p={},m=function(n,e,t){if(!s(p,e)){for(var r=[],i=0;i<e;i++)r[i]="a["+i+"]";p[e]=d("C,a","return new C("+h(r,",")+")")}return p[e](n,t)};n.exports=c?d.bind:function(n){var e=a(this),t=e.prototype,r=l(arguments,1),i=function(){var t=u(r,l(arguments));return this instanceof i?m(e,t.length,t):e.apply(n,t)};return o(t)&&(i.prototype=t),i}},function(n,e,t){var r=t(3),i=t(14),a=Date.prototype,o=r(a.toString),s=r(a.getTime);"Invalid Date"!=String(new Date(NaN))&&i(a,"toString",(function(){var n=s(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){"use strict";var r=t(1),i=t(383).start;r({target:"String",proto:!0,forced:t(385)},{padStart:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(67)})},function(n,e,t){var r=t(1),i=t(15),a=t(39),o=t(210),s=t(160),l=t(10),c=t(11),d=t(33),u=t(2),h=i("Reflect","construct"),p=Object.prototype,m=[].push,g=u((function(){function n(){}return!(h((function(){}),[],n)instanceof n)})),f=!u((function(){h((function(){}))})),v=g||f;r({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(f&&!g)return h(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return a(m,r,e),new(a(o,n,r))}var i=t.prototype,u=d(c(i)?i:p),v=a(n,u,e);return c(v)?v:u}})},function(n,e,t){var r=t(1),i=t(0),a=t(66);r({global:!0},{Reflect:{}}),a(i.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(282),i=t(287),a=t(358),o=t(366),s=t(375),l=t(232),c=a((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),i(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,i=r.exec(t);if(!i)return t;var a="",o=0,s=0;for(o=i.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(a+=t.substring(s,o)),s=o+1,a+=e}return s!==o?a+t.substring(s,o):a}},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(386),t(20)),a=Object(i.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=a.exports},function(n,e,t){"use strict";t.r(e);t(35),t(6),t(36),t(43),t(31);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},i=(t(387),t(20)),a=Object(i.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=a.exports},function(n,e,t){"use strict";var r=t(8),i=t(0),a=t(3),o=t(105),s=t(14),l=t(9),c=t(142),d=t(32),u=t(60),h=t(152),p=t(2),m=t(55).f,g=t(38).f,f=t(12).f,v=t(382),b=t(145).trim,y=i.Number,x=y.prototype,k=i.TypeError,w=a("".slice),_=a("".charCodeAt),E=function(n){var e=h(n,"number");return"bigint"==typeof e?e:T(e)},T=function(n){var e,t,r,i,a,o,s,l,c=h(n,"number");if(u(c))throw k("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=_(c,0))||45===e){if(88===(t=_(c,2))||120===t)return NaN}else if(48===e){switch(_(c,1)){case 66:case 98:r=2,i=49;break;case 79:case 111:r=8,i=55;break;default:return+c}for(o=(a=w(c,2)).length,s=0;s<o;s++)if((l=_(a,s))<48||l>i)return NaN;return parseInt(a,r)}return+c};if(o("Number",!y(" 0o1")||!y("0b1")||y("+0x1"))){for(var A,I=function(n){var e=arguments.length<1?0:y(E(n)),t=this;return d(x,t)&&p((function(){v(t)}))?c(Object(e),t,I):e},j=r?m(y):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),S=0;j.length>S;S++)l(y,A=j[S])&&!l(I,A)&&f(I,A,g(y,A));I.prototype=x,x.constructor=I,s(i,"Number",I)}},function(n,e,t){var r=t(2),i=t(0).RegExp;n.exports=r((function(){var n=i(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(15),i=t(12),a=t(5),o=t(8),s=a("species");n.exports=function(n){var e=r(n),t=i.f;o&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(1),i=t(8),a=t(157),o=t(21),s=t(38),l=t(73);r({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(n){for(var e,t,r=o(n),i=s.f,c=a(r),d={},u=0;c.length>u;)void 0!==(t=i(r,e=c[u++]))&&l(d,e,t);return d}})},function(n,e,t){var r=t(2),i=t(0).RegExp;n.exports=r((function(){var n=i("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var r=t(12).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var r=t(1),i=t(110).includes,a=t(2),o=t(139);r({target:"Array",proto:!0,forced:a((function(){return!Array(1).includes()}))},{includes:function(n){return i(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(177),o=t(19),s=t(13),l=t(178),c=i("".indexOf);r({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(o(this)),s(a(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var r=t(1),i=t(145).trim;r({target:"String",proto:!0,forced:t(380)("trim")},{trim:function(){return i(this)}})},function(n,e,t){var r=t(7),i=t(9),a=t(32),o=t(186),s=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in s||i(n,"flags")||!a(s,n)?e:r(o,n)}},function(n,e,t){var r=t(0),i=t(8),a=t(107).MISSED_STICKY,o=t(23),s=t(236),l=t(37).get,c=RegExp.prototype,d=r.TypeError;i&&a&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!l(this).sticky;throw d("Incompatible receiver, RegExp required")}}})},function(n,e,t){var r=t(156),i=t(12);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),i.f(n,e,t)}},function(n,e,t){n.exports=t(397)},function(n,e,t){var r=t(0),i=t(7),a=t(4),o=t(11),s=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&a(t=n.toString)&&!o(r=i(t,n)))return r;if(a(t=n.valueOf)&&!o(r=i(t,n)))return r;if("string"!==e&&a(t=n.toString)&&!o(r=i(t,n)))return r;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(0),i=t(4),a=t(87),o=r.WeakMap;n.exports=i(o)&&/native code/.test(a(o))},function(n,e,t){"use strict";var r=t(158).IteratorPrototype,i=t(33),a=t(51),o=t(66),s=t(64),l=function(){return this};n.exports=function(n,e,t,c){var d=e+" Iterator";return n.prototype=i(r,{next:a(+!c,t)}),o(n,d,!1,!0),s[d]=l,n}},function(n,e,t){var r=t(0),i=t(4),a=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||i(n))return n;throw o("Can't set "+a(n)+" as a prototype")}},function(n,e,t){t(243),t(251),t(252),t(253),t(254),t(255)},function(n,e,t){"use strict";var r,i,a,o=t(1),s=t(16),l=t(89),c=t(0),d=t(7),u=t(14),h=t(67),p=t(66),m=t(226),g=t(22),f=t(4),v=t(11),b=t(244),y=t(116),x=t(161).set,k=t(245),w=t(248),_=t(118),E=t(249),T=t(37),A=t(52),I=t(70),j=t(71),S=I.CONSTRUCTOR,z=I.REJECTION_EVENT,C=I.SUBCLASSING,$=T.getterFor("Promise"),O=T.set,P=A&&A.prototype,D=A,M=P,R=c.TypeError,G=c.document,B=c.process,L=j.f,q=L,H=!!(G&&G.createEvent&&c.dispatchEvent),N=function(n){var e;return!(!v(n)||!f(e=n.then))&&e},F=function(n,e){var t,r,i,a=e.value,o=1==e.state,s=o?n.ok:n.fail,l=n.resolve,c=n.reject,u=n.domain;try{s?(o||(2===e.rejection&&Q(e),e.rejection=1),!0===s?t=a:(u&&u.enter(),t=s(a),u&&(u.exit(),i=!0)),t===n.promise?c(R("Promise-chain cycle")):(r=N(t))?d(r,t,l,c):l(t)):c(a)}catch(n){u&&!i&&u.exit(),c(n)}},U=function(n,e){n.notified||(n.notified=!0,k((function(){for(var t,r=n.reactions;t=r.get();)F(t,n);n.notified=!1,e&&!n.rejection&&J(n)})))},V=function(n,e,t){var r,i;H?((r=G.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!z&&(i=c["on"+n])?i(r):"unhandledrejection"===n&&w("Unhandled promise rejection",t)},J=function(n){d(x,c,(function(){var e,t=n.facade,r=n.value;if(W(n)&&(e=_((function(){l?B.emit("unhandledRejection",r,t):V("unhandledrejection",t,r)})),n.rejection=l||W(n)?2:1,e.error))throw e.value}))},W=function(n){return 1!==n.rejection&&!n.parent},Q=function(n){d(x,c,(function(){var e=n.facade;l?B.emit("rejectionHandled",e):V("rejectionhandled",e,n.value)}))},K=function(n,e,t){return function(r){n(e,r,t)}},Y=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,U(n,!0))},X=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw R("Promise can't be resolved itself");var r=N(e);r?k((function(){var t={done:!1};try{d(r,e,K(X,t,n),K(Y,t,n))}catch(e){Y(t,e,n)}})):(n.value=e,n.state=1,U(n,!1))}catch(e){Y({done:!1},e,n)}}};if(S&&(M=(D=function(n){b(this,M),g(n),d(r,this);var e=$(this);try{n(K(X,e),K(Y,e))}catch(n){Y(e,n)}}).prototype,(r=function(n){O(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new E,rejection:!1,state:0,value:void 0})}).prototype=u(M,"then",(function(n,e){var t=$(this),r=L(y(this,D));return t.parent=!0,r.ok=!f(n)||n,r.fail=f(e)&&e,r.domain=l?B.domain:void 0,0==t.state?t.reactions.add(r):k((function(){F(r,t)})),r.promise})),i=function(){var n=new r,e=$(n);this.promise=n,this.resolve=K(X,e),this.reject=K(Y,e)},j.f=L=function(n){return n===D||void 0===n?new i(n):q(n)},!s&&f(A)&&P!==Object.prototype)){a=P.then,C||u(P,"then",(function(n,e){var t=this;return new D((function(n,e){d(a,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete P.constructor}catch(n){}h&&h(P,M)}o({global:!0,wrap:!0,forced:S},{Promise:D}),p(D,"Promise",!1,!0),m("Promise")},function(n,e,t){var r=t(0),i=t(32),a=r.TypeError;n.exports=function(n,e){if(i(e,n))return n;throw a("Incorrect invocation")}},function(n,e,t){var r,i,a,o,s,l,c,d,u=t(0),h=t(68),p=t(38).f,m=t(161).set,g=t(163),f=t(246),v=t(247),b=t(89),y=u.MutationObserver||u.WebKitMutationObserver,x=u.document,k=u.process,w=u.Promise,_=p(u,"queueMicrotask"),E=_&&_.value;E||(r=function(){var n,e;for(b&&(n=k.domain)&&n.exit();i;){e=i.fn,i=i.next;try{e()}catch(n){throw i?o():a=void 0,n}}a=void 0,n&&n.enter()},g||b||v||!y||!x?!f&&w&&w.resolve?((c=w.resolve(void 0)).constructor=w,d=h(c.then,c),o=function(){d(r)}):b?o=function(){k.nextTick(r)}:(m=h(m,u),o=function(){m(r)}):(s=!0,l=x.createTextNode(""),new y(r).observe(l,{characterData:!0}),o=function(){l.data=s=!s})),n.exports=E||function(n){var e={fn:n,next:void 0};a&&(a.next=e),i||(i=e,o()),a=e}},function(n,e,t){var r=t(26),i=t(0);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==i.Pebble},function(n,e,t){var r=t(26);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(0);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(22),o=t(71),s=t(118),l=t(164);r({target:"Promise",stat:!0,forced:t(168)},{all:function(n){var e=this,t=o.f(e),r=t.resolve,c=t.reject,d=s((function(){var t=a(e.resolve),o=[],s=0,d=1;l(n,(function(n){var a=s++,l=!1;d++,i(t,e,n).then((function(n){l||(l=!0,o[a]=n,--d||r(o))}),c)})),--d||r(o)}));return d.error&&c(d.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(16),a=t(70).CONSTRUCTOR,o=t(52),s=t(15),l=t(4),c=t(14),d=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:a,real:!0},{catch:function(n){return this.then(void 0,n)}}),!i&&l(o)){var u=s("Promise").prototype.catch;d.catch!==u&&c(d,"catch",u,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(22),o=t(71),s=t(118),l=t(164);r({target:"Promise",stat:!0,forced:t(168)},{race:function(n){var e=this,t=o.f(e),r=t.reject,c=s((function(){var o=a(e.resolve);l(n,(function(n){i(o,e,n).then(t.resolve,r)}))}));return c.error&&r(c.value),t.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(7),a=t(71);r({target:"Promise",stat:!0,forced:t(70).CONSTRUCTOR},{reject:function(n){var e=a.f(this);return i(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var r=t(1),i=t(15),a=t(16),o=t(52),s=t(70).CONSTRUCTOR,l=t(170),c=i("Promise"),d=a&&!s;r({target:"Promise",stat:!0,forced:a||s},{resolve:function(n){return l(d&&this===c?o:this,n)}})},function(n,e,t){var r=t(1),i=t(257);r({target:"Object",stat:!0,arity:2,forced:Object.assign!==i},{assign:i})},function(n,e,t){"use strict";var r=t(8),i=t(3),a=t(7),o=t(2),s=t(85),l=t(88),c=t(113),d=t(17),u=t(58),h=Object.assign,p=Object.defineProperty,m=i([].concat);n.exports=!h||o((function(){if(r&&1!==h({b:1},h(p({},"a",{enumerable:!0,get:function(){p(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=h({},n)[t]||"abcdefghijklmnopqrst"!=s(h({},e)).join("")}))?function(n,e){for(var t=d(n),i=arguments.length,o=1,h=l.f,p=c.f;i>o;)for(var g,f=u(arguments[o++]),v=h?m(s(f),h(f)):s(f),b=v.length,y=0;b>y;)g=v[y++],r&&!a(p,f,g)||(t[g]=f[g]);return t}:h},function(n,e,t){"use strict";var r=t(1),i=t(16),a=t(52),o=t(2),s=t(15),l=t(4),c=t(116),d=t(170),u=t(14),h=a&&a.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!a&&o((function(){h.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return d(e,n()).then((function(){return t}))}:n,t?function(t){return d(e,n()).then((function(){throw t}))}:n)}}),!i&&l(a)){var p=s("Promise").prototype.finally;h.finally!==p&&u(h,"finally",p,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(117),i=t(91);n.exports=r?{}.toString:function(){return"[object "+i(this)+"]"}},function(n,e,t){var r=t(0),i=t(72),a=t(90),o=t(11),s=t(5)("species"),l=r.Array;n.exports=function(n){var e;return i(n)&&(e=n.constructor,(a(e)&&(e===l||i(e.prototype))||o(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){"use strict";var r=t(1),i=t(262).left,a=t(53),o=t(48),s=t(89);r({target:"Array",proto:!0,forced:!a("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return i(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(0),i=t(22),a=t(17),o=t(58),s=t(27),l=r.TypeError,c=function(n){return function(e,t,r,c){i(t);var d=a(e),u=o(d),h=s(d),p=n?h-1:0,m=n?-1:1;if(r<2)for(;;){if(p in u){c=u[p],p+=m;break}if(p+=m,n?p<0:h<=p)throw l("Reduce of empty array with no initial value")}for(;n?p>=0:h>p;p+=m)p in u&&(c=t(c,u[p],p,d));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r,i=t(1),a=t(3),o=t(38).f,s=t(50),l=t(13),c=t(177),d=t(19),u=t(178),h=t(16),p=a("".startsWith),m=a("".slice),g=Math.min,f=u("startsWith");i({target:"String",proto:!0,forced:!!(h||f||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!f},{startsWith:function(n){var e=l(d(this));c(n);var t=s(g(arguments.length>1?arguments[1]:void 0,e.length)),r=l(n);return p?p(e,r,t):m(e,t,t+r.length)===r}})},function(n,e,t){var r=t(1),i=t(180),a=t(2),o=t(11),s=t(265).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:a((function(){l(1)})),sham:!i},{freeze:function(n){return l&&o(n)?l(s(n)):n}})},function(n,e,t){var r=t(1),i=t(3),a=t(63),o=t(11),s=t(9),l=t(12).f,c=t(55),d=t(181),u=t(266),h=t(82),p=t(180),m=!1,g=h("meta"),f=0,v=function(n){l(n,g,{value:{objectID:"O"+f++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},m=!0;var n=c.f,e=i([].splice),t={};t[g]=1,n(t).length&&(c.f=function(t){for(var r=n(t),i=0,a=r.length;i<a;i++)if(r[i]===g){e(r,i,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:d.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,g)){if(!u(n))return"F";if(!e)return"E";v(n)}return n[g].objectID},getWeakData:function(n,e){if(!s(n,g)){if(!u(n))return!0;if(!e)return!1;v(n)}return n[g].weakData},onFreeze:function(n){return p&&m&&u(n)&&!s(n,g)&&v(n),n}};a[g]=!0},function(n,e,t){var r=t(2),i=t(11),a=t(23),o=t(267),s=Object.isExtensible,l=r((function(){s(1)}));n.exports=l||o?function(n){return!!i(n)&&((!o||"ArrayBuffer"!=a(n))&&(!s||s(n)))}:s},function(n,e,t){var r=t(2);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var r=t(1),i=t(0),a=t(7),o=t(3),s=t(16),l=t(8),c=t(47),d=t(2),u=t(9),h=t(32),p=t(10),m=t(21),g=t(84),f=t(13),v=t(51),b=t(33),y=t(85),x=t(55),k=t(181),w=t(88),_=t(38),E=t(12),T=t(140),A=t(113),I=t(14),j=t(46),S=t(86),z=t(63),C=t(82),$=t(5),O=t(182),P=t(183),D=t(270),M=t(66),R=t(37),G=t(56).forEach,B=S("hidden"),L=R.set,q=R.getterFor("Symbol"),H=Object.prototype,N=i.Symbol,F=N&&N.prototype,U=i.TypeError,V=i.QObject,J=_.f,W=E.f,Q=k.f,K=A.f,Y=o([].push),X=j("symbols"),Z=j("op-symbols"),nn=j("wks"),en=!V||!V.prototype||!V.prototype.findChild,tn=l&&d((function(){return 7!=b(W({},"a",{get:function(){return W(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=J(H,e);r&&delete H[e],W(n,e,t),r&&n!==H&&W(H,e,r)}:W,rn=function(n,e){var t=X[n]=b(F);return L(t,{type:"Symbol",tag:n,description:e}),l||(t.description=e),t},an=function(n,e,t){n===H&&an(Z,e,t),p(n);var r=g(e);return p(t),u(X,r)?(t.enumerable?(u(n,B)&&n[B][r]&&(n[B][r]=!1),t=b(t,{enumerable:v(0,!1)})):(u(n,B)||W(n,B,v(1,{})),n[B][r]=!0),tn(n,r,t)):W(n,r,t)},on=function(n,e){p(n);var t=m(e),r=y(t).concat(dn(t));return G(r,(function(e){l&&!a(sn,t,e)||an(n,e,t[e])})),n},sn=function(n){var e=g(n),t=a(K,this,e);return!(this===H&&u(X,e)&&!u(Z,e))&&(!(t||!u(this,e)||!u(X,e)||u(this,B)&&this[B][e])||t)},ln=function(n,e){var t=m(n),r=g(e);if(t!==H||!u(X,r)||u(Z,r)){var i=J(t,r);return!i||!u(X,r)||u(t,B)&&t[B][r]||(i.enumerable=!0),i}},cn=function(n){var e=Q(m(n)),t=[];return G(e,(function(n){u(X,n)||u(z,n)||Y(t,n)})),t},dn=function(n){var e=n===H,t=Q(e?Z:m(n)),r=[];return G(t,(function(n){!u(X,n)||e&&!u(H,n)||Y(r,X[n])})),r};c||(I(F=(N=function(){if(h(F,this))throw U("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?f(arguments[0]):void 0,e=C(n),t=function(n){this===H&&a(t,Z,n),u(this,B)&&u(this[B],e)&&(this[B][e]=!1),tn(this,e,v(1,n))};return l&&en&&tn(H,e,{configurable:!0,set:t}),rn(e,n)}).prototype,"toString",(function(){return q(this).tag})),I(N,"withoutSetter",(function(n){return rn(C(n),n)})),A.f=sn,E.f=an,T.f=on,_.f=ln,x.f=k.f=cn,w.f=dn,O.f=function(n){return rn($(n),n)},l&&(W(F,"description",{configurable:!0,get:function(){return q(this).description}}),s||I(H,"propertyIsEnumerable",sn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:N}),G(y(nn),(function(n){P(n)})),r({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!l},{create:function(n,e){return void 0===e?b(n):on(b(n),e)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:ln}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),D(),M(N,"Symbol"),z[B]=!0},function(n,e,t){var r=t(0);n.exports=r},function(n,e,t){var r=t(7),i=t(15),a=t(5),o=t(14);n.exports=function(){var n=i("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,s=a("toPrimitive");e&&!e[s]&&o(e,s,(function(n){return r(t,this)}),{arity:1})}},function(n,e,t){var r=t(1),i=t(15),a=t(9),o=t(13),s=t(46),l=t(184),c=s("string-to-symbol-registry"),d=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=o(n);if(a(c,e))return c[e];var t=i("Symbol")(e);return c[e]=t,d[t]=e,t}})},function(n,e,t){var r=t(1),i=t(9),a=t(60),o=t(61),s=t(46),l=t(184),c=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{keyFor:function(n){if(!a(n))throw TypeError(o(n)+" is not a symbol");if(i(c,n))return c[n]}})},function(n,e,t){var r=t(1),i=t(47),a=t(2),o=t(88),s=t(17);r({target:"Object",stat:!0,forced:!i||a((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(s(n)):[]}})},function(n,e,t){"use strict";var r=t(0),i=t(68),a=t(7),o=t(17),s=t(275),l=t(165),c=t(90),d=t(27),u=t(73),h=t(166),p=t(119),m=r.Array;n.exports=function(n){var e=o(n),t=c(this),r=arguments.length,g=r>1?arguments[1]:void 0,f=void 0!==g;f&&(g=i(g,r>2?arguments[2]:void 0));var v,b,y,x,k,w,_=p(e),E=0;if(!_||this==m&&l(_))for(v=d(e),b=t?new this(v):m(v);v>E;E++)w=f?g(e[E],E):e[E],u(b,E,w);else for(k=(x=h(e,_)).next,b=t?new this:[];!(y=a(k,x)).done;E++)w=f?s(x,g,[y.value,E],!0):y.value,u(b,E,w);return b.length=E,b}},function(n,e,t){var r=t(10),i=t(167);n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){i(n,"throw",e)}}},function(n,e,t){"use strict";var r=t(15),i=t(9),a=t(24),o=t(32),s=t(67),l=t(114),c=t(229),d=t(142),u=t(187),h=t(277),p=t(278),m=t(279),g=t(8),f=t(16);n.exports=function(n,e,t,v){var b=v?2:1,y=n.split("."),x=y[y.length-1],k=r.apply(null,y);if(k){var w=k.prototype;if(!f&&i(w,"cause")&&delete w.cause,!t)return k;var _=r("Error"),E=e((function(n,e){var t=u(v?e:n,void 0),r=v?new k(n):new k;return void 0!==t&&a(r,"message",t),m&&a(r,"stack",p(r.stack,2)),this&&o(w,this)&&d(r,this,E),arguments.length>b&&h(r,arguments[b]),r}));if(E.prototype=w,"Error"!==x?s?s(E,_):l(E,_,{name:!0}):g&&"stackTraceLimit"in k&&(c(E,k,"stackTraceLimit"),c(E,k,"prepareStackTrace")),l(E,k),!f)try{w.name!==x&&a(w,"name",x),w.constructor=E}catch(n){}return E}}},function(n,e,t){var r=t(11),i=t(24);n.exports=function(n,e){r(e)&&"cause"in e&&i(n,"cause",e.cause)}},function(n,e,t){var r=t(3),i=Error,a=r("".replace),o=String(i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!i.prepareStackTrace)for(;e--;)n=a(n,s,"");return n}},function(n,e,t){var r=t(2),i=t(51);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",i(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(8),i=t(2),a=t(10),o=t(33),s=t(187),l=Error.prototype.toString,c=i((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=a(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){var r=t(3),i=t(17),a=Math.floor,o=r("".charAt),s=r("".replace),l=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,d=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,u,h){var p=t+n.length,m=r.length,g=d;return void 0!==u&&(u=i(u),g=c),s(h,g,(function(i,s){var c;switch(o(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,p);case"<":c=u[l(s,1,-1)];break;default:var d=+s;if(0===d)return i;if(d>m){var h=a(d/10);return 0===h?i:h<=m?void 0===r[h-1]?o(s,1):r[h-1]+o(s,1):i}c=r[d-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(189),i=t(283);n.exports=function n(e,t,a,o,s){var l=-1,c=e.length;for(a||(a=i),s||(s=[]);++l<c;){var d=e[l];t>0&&a(d)?t>1?n(d,t-1,a,o,s):r(s,d):o||(s[s.length]=d)}return s}},function(n,e,t){var r=t(74),i=t(127),a=t(25),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return a(n)||i(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(57),i=t(45);n.exports=function(n){return i(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(74),i=Object.prototype,a=i.hasOwnProperty,o=i.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=a.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var i=o.call(n);return r&&(e?n[s]=t:delete n[s]),i}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(288),i=t(344),a=t(135),o=t(25),s=t(355);n.exports=function(n){return"function"==typeof n?n:null==n?a:"object"==typeof n?o(n)?i(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(289),i=t(343),a=t(206);n.exports=function(n){var e=i(n);return 1==e.length&&e[0][2]?a(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(191),i=t(195);n.exports=function(n,e,t,a){var o=t.length,s=o,l=!a;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var d=(c=t[o])[0],u=n[d],h=c[1];if(l&&c[2]){if(void 0===u&&!(d in n))return!1}else{var p=new r;if(a)var m=a(u,h,d,n,e,p);if(!(void 0===m?i(h,u,3,a,p):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(96),i=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():i.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(96);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(96);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(96);n.exports=function(n,e){var t=this.__data__,i=r(t,n);return i<0?(++this.size,t.push([n,e])):t[i][1]=e,this}},function(n,e,t){var r=t(95);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(95),i=t(128),a=t(130);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!i||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new a(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(193),i=t(301),a=t(129),o=t(194),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,u=c.hasOwnProperty,h=RegExp("^"+d.call(u).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!a(n)||i(n))&&(r(n)?h:s).test(o(n))}},function(n,e,t){var r,i=t(302),a=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!a&&a in n}},function(n,e,t){var r=t(30)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(305),i=t(95),a=t(128);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(a||i),string:new r}}},function(n,e,t){var r=t(306),i=t(307),a=t(308),o=t(309),s=t(310);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=i,l.prototype.get=a,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(97);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(97),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(97),i=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:i.call(e,n)}},function(n,e,t){var r=t(97);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(98);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(98);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(98);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(98);n.exports=function(n,e){var t=r(this,n),i=t.size;return t.set(n,e),this.size+=t.size==i?0:1,this}},function(n,e,t){var r=t(191),i=t(196),a=t(320),o=t(323),s=t(339),l=t(25),c=t(200),d=t(202),u="[object Object]",h=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,p,m,g){var f=l(n),v=l(e),b=f?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?u:b)==u,k=(y="[object Arguments]"==y?u:y)==u,w=b==y;if(w&&c(n)){if(!c(e))return!1;f=!0,x=!1}if(w&&!x)return g||(g=new r),f||d(n)?i(n,e,t,p,m,g):a(n,e,b,t,p,m,g);if(!(1&t)){var _=x&&h.call(n,"__wrapped__"),E=k&&h.call(e,"__wrapped__");if(_||E){var T=_?n.value():n,A=E?e.value():e;return g||(g=new r),m(T,A,t,p,g)}}return!!w&&(g||(g=new r),o(n,e,t,p,m,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(74),i=t(321),a=t(192),o=t(196),s=t(322),l=t(131),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,u,h){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!u(new i(n),new i(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return a(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var p=s;case"[object Set]":var m=1&r;if(p||(p=l),n.size!=e.size&&!m)return!1;var g=h.get(n);if(g)return g==e;r|=2,h.set(n,e);var f=o(p(n),p(e),r,c,u,h);return h.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(30).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(324),i=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,a,o,s){var l=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!l)return!1;for(var u=d;u--;){var h=c[u];if(!(l?h in e:i.call(e,h)))return!1}var p=s.get(n),m=s.get(e);if(p&&m)return p==e&&m==n;var g=!0;s.set(n,e),s.set(e,n);for(var f=l;++u<d;){var v=n[h=c[u]],b=e[h];if(a)var y=l?a(b,v,h,e,n,s):a(v,b,h,n,e,s);if(!(void 0===y?v===b||o(v,b,t,a,s):y)){g=!1;break}f||(f="constructor"==h)}if(g&&!f){var x=n.constructor,k=e.constructor;x==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof k&&k instanceof k||(g=!1)}return s.delete(n),s.delete(e),g}},function(n,e,t){var r=t(325),i=t(326),a=t(199);n.exports=function(n){return r(n,a,i)}},function(n,e,t){var r=t(189),i=t(25);n.exports=function(n,e,t){var a=e(n);return i(n)?a:r(a,t(n))}},function(n,e,t){var r=t(327),i=t(328),a=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return a.call(n,e)})))}:i;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=0,a=[];++t<r;){var o=n[t];e(o,t,n)&&(a[i++]=o)}return a}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(330),i=t(127),a=t(25),o=t(200),s=t(201),l=t(202),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=a(n),d=!t&&i(n),u=!t&&!d&&o(n),h=!t&&!d&&!u&&l(n),p=t||d||u||h,m=p?r(n.length,String):[],g=m.length;for(var f in n)!e&&!c.call(n,f)||p&&("length"==f||u&&("offset"==f||"parent"==f)||h&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||s(f,g))||m.push(f);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(57),i=t(132),a=t(45),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return a(n)&&i(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(190),i=e&&!e.nodeType&&e,a=i&&"object"==typeof n&&n&&!n.nodeType&&n,o=a&&a.exports===i&&r.process,s=function(){try{var n=a&&a.require&&a.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(143)(n))},function(n,e,t){var r=t(336),i=t(337),a=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return i(n);var e=[];for(var t in Object(n))a.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(338)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(340),i=t(128),a=t(341),o=t(204),s=t(342),l=t(57),c=t(194),d=c(r),u=c(i),h=c(a),p=c(o),m=c(s),g=l;(r&&"[object DataView]"!=g(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=g(new i)||a&&"[object Promise]"!=g(a.resolve())||o&&"[object Set]"!=g(new o)||s&&"[object WeakMap]"!=g(new s))&&(g=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case u:return"[object Map]";case h:return"[object Promise]";case p:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var r=t(41)(t(30),"DataView");n.exports=r},function(n,e,t){var r=t(41)(t(30),"Promise");n.exports=r},function(n,e,t){var r=t(41)(t(30),"WeakMap");n.exports=r},function(n,e,t){var r=t(205),i=t(199);n.exports=function(n){for(var e=i(n),t=e.length;t--;){var a=e[t],o=n[a];e[t]=[a,o,r(o)]}return e}},function(n,e,t){var r=t(195),i=t(345),a=t(352),o=t(133),s=t(205),l=t(206),c=t(99);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=i(t,n);return void 0===o&&o===e?a(t,n):r(e,o,3)}}},function(n,e,t){var r=t(207);n.exports=function(n,e,t){var i=null==n?void 0:r(n,e);return void 0===i?t:i}},function(n,e,t){var r=t(347),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,a=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(i,(function(n,t,r,i){e.push(r?i.replace(a,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(348);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(130);function i(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=e?e.apply(this,r):r[0],a=t.cache;if(a.has(i))return a.get(i);var o=n.apply(this,r);return t.cache=a.set(i,o)||a,o};return t.cache=new(i.Cache||r),t}i.Cache=r,n.exports=i},function(n,e,t){var r=t(350);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(74),i=t(351),a=t(25),o=t(134),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(a(e))return i(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,i=Array(r);++t<r;)i[t]=e(n[t],t,n);return i}},function(n,e,t){var r=t(353),i=t(354);n.exports=function(n,e){return null!=n&&i(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(208),i=t(127),a=t(25),o=t(201),s=t(132),l=t(99);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,u=!1;++c<d;){var h=l(e[c]);if(!(u=null!=n&&t(n,h)))break;n=n[h]}return u||++c!=d?u:!!(d=null==n?0:n.length)&&s(d)&&o(h,d)&&(a(n)||i(n))}},function(n,e,t){var r=t(356),i=t(357),a=t(133),o=t(99);n.exports=function(n){return a(n)?r(o(n)):i(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(207);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(135),i=t(359),a=t(361);n.exports=function(n,e){return a(i(n,e,r),n+"")}},function(n,e,t){var r=t(360),i=Math.max;n.exports=function(n,e,t){return e=i(void 0===e?n.length-1:e,0),function(){for(var a=arguments,o=-1,s=i(a.length-e,0),l=Array(s);++o<s;)l[o]=a[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=a[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(362),i=t(365)(r);n.exports=i},function(n,e,t){var r=t(363),i=t(364),a=t(135),o=i?function(n,e){return i(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:a;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(41),i=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=i},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var i=t(),a=16-(i-r);if(r=i,a>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(197),i=t(367),a=t(372),o=t(198),s=t(373),l=t(131);n.exports=function(n,e,t){var c=-1,d=i,u=n.length,h=!0,p=[],m=p;if(t)h=!1,d=a;else if(u>=200){var g=e?null:s(n);if(g)return l(g);h=!1,d=o,m=new r}else m=e?[]:p;n:for(;++c<u;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,h&&v==v){for(var b=m.length;b--;)if(m[b]===v)continue n;e&&m.push(v),p.push(f)}else d(m,v,t)||(m!==p&&m.push(v),p.push(f))}return p}},function(n,e,t){var r=t(368);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(369),i=t(370),a=t(371);n.exports=function(n,e,t){return e==e?a(n,e,t):r(n,i,t)}},function(n,e){n.exports=function(n,e,t,r){for(var i=n.length,a=t+(r?1:-1);r?a--:++a<i;)if(e(n[a],a,n))return a;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,i=n.length;++r<i;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,i=null==n?0:n.length;++r<i;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(204),i=t(374),a=t(131),o=r&&1/a(new r([,-0]))[1]==1/0?function(n){return new r(n)}:i;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(203),i=t(45);n.exports=function(n){return i(n)&&r(n)}},function(n,e,t){var r=t(1),i=t(0),a=t(209).setInterval;r({global:!0,bind:!0,forced:i.setInterval!==a},{setInterval:a})},function(n,e,t){var r=t(1),i=t(0),a=t(209).setTimeout;r({global:!0,bind:!0,forced:i.setTimeout!==a},{setTimeout:a})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(65).PROPER,i=t(2),a=t(146);n.exports=function(n){return i((function(){return!!a[n]()||"​᠎"!=="​᠎"[n]()||r&&a[n].name!==n}))}},function(n,e,t){var r=t(1),i=t(210);r({target:"Function",proto:!0,forced:Function.bind!==i},{bind:i})},function(n,e,t){var r=t(3);n.exports=r(1..valueOf)},function(n,e,t){var r=t(3),i=t(50),a=t(13),o=t(384),s=t(19),l=r(o),c=r("".slice),d=Math.ceil,u=function(n){return function(e,t,r){var o,u,h=a(s(e)),p=i(t),m=h.length,g=void 0===r?" ":a(r);return p<=m||""==g?h:((u=l(g,d((o=p-m)/g.length))).length>o&&(u=c(u,0,o)),n?h+u:u+h)}};n.exports={start:u(!1),end:u(!0)}},function(n,e,t){"use strict";var r=t(0),i=t(62),a=t(13),o=t(19),s=r.RangeError;n.exports=function(n){var e=a(o(this)),t="",r=i(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(26);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){"use strict";t(213)},function(n,e,t){"use strict";t(214)},function(n,e,t){"use strict";var r=t(1),i=t(3),a=t(22),o=t(17),s=t(27),l=t(13),c=t(2),d=t(389),u=t(53),h=t(390),p=t(391),m=t(48),g=t(392),f=[],v=i(f.sort),b=i(f.push),y=c((function(){f.sort(void 0)})),x=c((function(){f.sort(null)})),k=u("sort"),w=!c((function(){if(m)return m<70;if(!(h&&h>3)){if(p)return!0;if(g)return g<603;var n,e,t,r,i="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)f.push({k:e+r,v:t})}for(f.sort((function(n,e){return e.v-n.v})),r=0;r<f.length;r++)e=f[r].k.charAt(0),i.charAt(i.length-1)!==e&&(i+=e);return"DGBEFHACIJK"!==i}}));r({target:"Array",proto:!0,forced:y||!x||!k||!w},{sort:function(n){void 0!==n&&a(n);var e=o(this);if(w)return void 0===n?v(e):v(e,n);var t,r,i=[],c=s(e);for(r=0;r<c;r++)r in e&&b(i,e[r]);for(d(i,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=i.length,r=0;r<t;)e[r]=i[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(120),i=Math.floor,a=function(n,e){var t=n.length,l=i(t/2);return t<8?o(n,e):s(n,a(r(n,0,l),e),a(r(n,l),e),e)},o=function(n,e){for(var t,r,i=n.length,a=1;a<i;){for(r=a,t=n[a];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==a++&&(n[r]=t)}return n},s=function(n,e,t,r){for(var i=e.length,a=t.length,o=0,s=0;o<i||s<a;)n[o+s]=o<i&&s<a?r(e[o],t[s])<=0?e[o++]:t[s++]:o<i?e[o++]:t[s++];return n};n.exports=a},function(n,e,t){var r=t(26).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(26);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(26).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(218)},function(n,e,t){"use strict";t(219)},function(n,e,t){"use strict";t.r(e);t(148),t(242),t(256),t(258),t(6);function r(n,e,t,r,i,a,o){try{var s=n[a](o),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,i)}function i(n){return function(){var e=this,t=arguments;return new Promise((function(i,a){var o=n.apply(e,t);function s(n){r(o,i,a,s,l,"next",n)}function l(n){r(o,i,a,s,l,"throw",n)}s(void 0)}))}}t(171),t(54),t(28),t(34),t(43),t(31);var a=Object.freeze({});function o(n){return null==n}function s(n){return null!=n}function l(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function d(n){return null!==n&&"object"==typeof n}var u=Object.prototype.toString;function h(n){return"[object Object]"===u.call(n)}function p(n){return"[object RegExp]"===u.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function g(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||h(n)&&n.toString===u?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var k=Object.prototype.hasOwnProperty;function w(n,e){return k.call(n,e)}function _(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,T=_((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),A=_((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,j=_((function(n){return n.replace(I,"-$1").toLowerCase()}));var S=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function z(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function C(n,e){for(var t in e)n[t]=e[t];return n}function $(n){for(var e={},t=0;t<n.length;t++)n[t]&&C(e,n[t]);return e}function O(n,e,t){}var P=function(n,e,t){return!1},D=function(n){return n};function M(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var i=Array.isArray(n),a=Array.isArray(e);if(i&&a)return n.length===e.length&&n.every((function(n,t){return M(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(i||a)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return M(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(M(n[t],e))return t;return-1}function G(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var B=["component","directive","filter"],L=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:O,parsePlatformTagName:D,mustUseProp:P,async:!0,_lifecycleHooks:L},H=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function N(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var F=new RegExp("[^"+H.source+".$_\\d]");var U,V="__proto__"in{},J="undefined"!=typeof window,W="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,Q=W&&WXEnvironment.platform.toLowerCase(),K=J&&window.navigator.userAgent.toLowerCase(),Y=K&&/msie|trident/.test(K),X=K&&K.indexOf("msie 9.0")>0,Z=K&&K.indexOf("edge/")>0,nn=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===Q),en=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),tn={}.watch,rn=!1;if(J)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===U&&(U=!J&&!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),U},sn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var un=O,hn=0,pn=function(){this.id=hn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){x(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var mn=[];function gn(n){mn.push(n),pn.target=n}function fn(){mn.pop(),pn.target=mn[mn.length-1]}var vn=function(n,e,t,r,i,a,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=a,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},bn={child:{configurable:!0}};bn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,bn);var yn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function xn(n){return new vn(void 0,void 0,void 0,String(n))}function kn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,_n=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];N(_n,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var i,a=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&o.observeArray(i),o.dep.notify(),a}))}));var En=Object.getOwnPropertyNames(_n),Tn=!0;function An(n){Tn=n}var In=function(n){this.value=n,this.dep=new pn,this.vmCount=0,N(n,"__ob__",this),Array.isArray(n)?(V?function(n,e){n.__proto__=e}(n,_n):function(n,e,t){for(var r=0,i=t.length;r<i;r++){var a=t[r];N(n,a,e[a])}}(n,_n,En),this.observeArray(n)):this.walk(n)};function jn(n,e){var t;if(d(n)&&!(n instanceof vn))return w(n,"__ob__")&&n.__ob__ instanceof In?t=n.__ob__:Tn&&!on()&&(Array.isArray(n)||h(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new In(n)),e&&t&&t.vmCount++,t}function Sn(n,e,t,r,i){var a=new pn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var s=o&&o.get,l=o&&o.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!i&&jn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return pn.target&&(a.depend(),c&&(c.dep.depend(),Array.isArray(e)&&$n(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!i&&jn(e),a.notify())}})}}function zn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Sn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Cn(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function $n(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&$n(e)}In.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Sn(n,e[t])},In.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)jn(n[e])};var On=q.optionMergeStrategies;function Pn(n,e){if(!e)return n;for(var t,r,i,a=dn?Reflect.ownKeys(e):Object.keys(e),o=0;o<a.length;o++)"__ob__"!==(t=a[o])&&(r=n[t],i=e[t],w(n,t)?r!==i&&h(r)&&h(i)&&Pn(r,i):zn(n,t,i));return n}function Dn(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,i="function"==typeof n?n.call(t,t):n;return r?Pn(r,i):i}:e?n?function(){return Pn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Mn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,r){var i=Object.create(n||null);return e?C(i,e):i}On.data=function(n,e,t){return t?Dn(n,e,t):e&&"function"!=typeof e?n:Dn(n,e)},L.forEach((function(n){On[n]=Mn})),B.forEach((function(n){On[n+"s"]=Rn})),On.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var a in C(i,n),e){var o=i[a],s=e[a];o&&!Array.isArray(o)&&(o=[o]),i[a]=o?o.concat(s):Array.isArray(s)?s:[s]}return i},On.props=On.methods=On.inject=On.computed=function(n,e,t,r){if(!n)return e;var i=Object.create(null);return C(i,n),e&&C(i,e),i},On.provide=Dn;var Gn=function(n,e){return void 0===e?n:e};function Bn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,i,a={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(i=t[r])&&(a[T(i)]={type:null});else if(h(t))for(var o in t)i=t[o],a[T(o)]=h(i)?i:{type:i};else 0;n.props=a}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var i=0;i<t.length;i++)r[t[i]]={from:t[i]};else if(h(t))for(var a in t){var o=t[a];r[a]=h(o)?C({from:a},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Bn(n,e.extends,t)),e.mixins))for(var r=0,i=e.mixins.length;r<i;r++)n=Bn(n,e.mixins[r],t);var a,o={};for(a in n)s(a);for(a in e)w(n,a)||s(a);function s(r){var i=On[r]||Gn;o[r]=i(n[r],e[r],t,r)}return o}function Ln(n,e,t,r){if("string"==typeof t){var i=n[e];if(w(i,t))return i[t];var a=T(t);if(w(i,a))return i[a];var o=A(a);return w(i,o)?i[o]:i[t]||i[a]||i[o]}}function qn(n,e,t,r){var i=e[n],a=!w(t,n),o=t[n],s=Un(Boolean,i.type);if(s>-1)if(a&&!w(i,"default"))o=!1;else if(""===o||o===j(n)){var l=Un(String,i.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Nn(e.type)?r.call(n):r}(r,i,n);var c=Tn;An(!0),jn(o),An(c)}return o}var Hn=/^\s*function (\w+)/;function Nn(n){var e=n&&n.toString().match(Hn);return e?e[1]:""}function Fn(n,e){return Nn(n)===Nn(e)}function Un(n,e){if(!Array.isArray(e))return Fn(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Fn(e[t],n))return t;return-1}function Vn(n,e,t){gn();try{if(e)for(var r=e;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var a=0;a<i.length;a++)try{if(!1===i[a].call(r,n,e,t))return}catch(n){Wn(n,r,"errorCaptured hook")}}Wn(n,e,t)}finally{fn()}}function Jn(n,e,t,r,i){var a;try{(a=t?n.apply(e,t):n.call(e))&&!a._isVue&&g(a)&&!a._handled&&(a.catch((function(n){return Vn(n,r,i+" (Promise/async)")})),a._handled=!0)}catch(n){Vn(n,r,i)}return a}function Wn(n,e,t){if(q.errorHandler)try{return q.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Qn(e,null,"config.errorHandler")}Qn(n,e,t)}function Qn(n,e,t){if(!J&&!W||"undefined"==typeof console)throw n;console.error(n)}var Kn,Yn=!1,Xn=[],Zn=!1;function ne(){Zn=!1;var n=Xn.slice(0);Xn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ee=Promise.resolve();Kn=function(){ee.then(ne),nn&&setTimeout(O)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Kn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(ne)}:function(){setTimeout(ne,0)};else{var te=1,re=new MutationObserver(ne),ie=document.createTextNode(String(te));re.observe(ie,{characterData:!0}),Kn=function(){te=(te+1)%2,ie.data=String(te)},Yn=!0}function ae(n,e){var t;if(Xn.push((function(){if(n)try{n.call(e)}catch(n){Vn(n,e,"nextTick")}else t&&t(e)})),Zn||(Zn=!0,Kn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var oe=new cn;function se(n){!function n(e,t){var r,i,a=Array.isArray(e);if(!a&&!d(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(a)for(r=e.length;r--;)n(e[r],t);else for(i=Object.keys(e),r=i.length;r--;)n(e[i[r]],t)}(n,oe),oe.clear()}var le=_((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function ce(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Jn(r,null,arguments,e,"v-on handler");for(var i=r.slice(),a=0;a<i.length;a++)Jn(i[a],null,n,e,"v-on handler")}return t.fns=n,t}function de(n,e,t,r,i,a){var s,c,d,u;for(s in n)c=n[s],d=e[s],u=le(s),o(c)||(o(d)?(o(c.fns)&&(c=n[s]=ce(c,a)),l(u.once)&&(c=n[s]=i(u.name,c,u.capture)),t(u.name,c,u.capture,u.passive,u.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)o(n[s])&&r((u=le(s)).name,e[s],u.capture)}function ue(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function a(){t.apply(this,arguments),x(r.fns,a)}o(i)?r=ce([a]):s(i.fns)&&l(i.merged)?(r=i).fns.push(a):r=ce([i,a]),r.merged=!0,n[e]=r}function he(n,e,t,r,i){if(s(e)){if(w(e,t))return n[t]=e[t],i||delete e[t],!0;if(w(e,r))return n[t]=e[r],i||delete e[r],!0}return!1}function pe(n){return c(n)?[xn(n)]:Array.isArray(n)?function n(e,t){var r,i,a,d,u=[];for(r=0;r<e.length;r++)o(i=e[r])||"boolean"==typeof i||(a=u.length-1,d=u[a],Array.isArray(i)?i.length>0&&(me((i=n(i,(t||"")+"_"+r))[0])&&me(d)&&(u[a]=xn(d.text+i[0].text),i.shift()),u.push.apply(u,i)):c(i)?me(d)?u[a]=xn(d.text+i):""!==i&&u.push(xn(i)):me(i)&&me(d)?u[a]=xn(d.text+i.text):(l(e._isVList)&&s(i.tag)&&o(i.key)&&s(t)&&(i.key="__vlist"+t+"_"+r+"__"),u.push(i)));return u}(n):void 0}function me(n){return s(n)&&s(n.text)&&!1===n.isComment}function ge(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),i=0;i<r.length;i++){var a=r[i];if("__ob__"!==a){for(var o=n[a].from,s=e;s;){if(s._provided&&w(s._provided,o)){t[a]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[a]){var l=n[a].default;t[a]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,i=n.length;r<i;r++){var a=n[r],o=a.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,a.context!==e&&a.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(a);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===a.tag?l.push.apply(l,a.children||[]):l.push(a)}}for(var c in t)t[c].every(ve)&&delete t[c];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function be(n){return n.isComment&&n.asyncFactory}function ye(n,e,t){var r,i=Object.keys(e).length>0,o=n?!!n.$stable:!i,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==a&&s===t.$key&&!i&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=xe(e,l,n[l]))}else r={};for(var c in e)c in r||(r[c]=ke(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),N(r,"$stable",o),N(r,"$key",s),N(r,"$hasNormal",i),r}function xe(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!be(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function ke(n,e){return function(){return n[e]}}function we(n,e){var t,r,i,a,o;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,i=n.length;r<i;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(d(n))if(dn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),c=l.next();!c.done;)t.push(e(c.value,t.length)),c=l.next()}else for(a=Object.keys(n),t=new Array(a.length),r=0,i=a.length;r<i;r++)o=a[r],t[r]=e(n[o],o,r);return s(t)||(t=[]),t._isVList=!0,t}function _e(n,e,t,r){var i,a=this.$scopedSlots[n];a?(t=t||{},r&&(t=C(C({},r),t)),i=a(t)||("function"==typeof e?e():e)):i=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},i):i}function Ee(n){return Ln(this.$options,"filters",n)||D}function Te(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ae(n,e,t,r,i){var a=q.keyCodes[e]||t;return i&&r&&!q.keyCodes[e]?Te(i,r):a?Te(a,n):r?j(r)!==e:void 0===n}function Ie(n,e,t,r,i){if(t)if(d(t)){var a;Array.isArray(t)&&(t=$(t));var o=function(o){if("class"===o||"style"===o||y(o))a=n;else{var s=n.attrs&&n.attrs.type;a=r||q.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(o),c=j(o);l in a||c in a||(a[o]=t[o],i&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var s in t)o(s)}else;return n}function je(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||ze(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Se(n,e,t){return ze(n,"__once__"+e+(t?"_"+t:""),!0),n}function ze(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Ce(n[r],e+"_"+r,t);else Ce(n,e,t)}function Ce(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function $e(n,e){if(e)if(h(e)){var t=n.on=n.on?C({},n.on):{};for(var r in e){var i=t[r],a=e[r];t[r]=i?[].concat(i,a):a}}else;return n}function Oe(n,e,t,r){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var a=n[i];Array.isArray(a)?Oe(a,e,t):a&&(a.proxy&&(a.fn.proxy=!0),e[a.key]=a.fn)}return r&&(e.$key=r),e}function Pe(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function De(n,e){return"string"==typeof n?e+n:n}function Me(n){n._o=Se,n._n=v,n._s=f,n._l=we,n._t=_e,n._q=M,n._i=R,n._m=je,n._f=Ee,n._k=Ae,n._b=Ie,n._v=xn,n._e=yn,n._u=Oe,n._g=$e,n._d=Pe,n._p=De}function Re(n,e,t,r,i){var o,s=this,c=i.options;w(r,"_uid")?(o=Object.create(r))._original=r:(o=r,r=r._original);var d=l(c._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||a,this.injections=ge(c.inject,r),this.slots=function(){return s.$slots||ye(n.scopedSlots,s.$slots=fe(t,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ye(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ye(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,i){var a=Fe(o,n,e,t,i,u);return a&&!Array.isArray(a)&&(a.fnScopeId=c._scopeId,a.fnContext=r),a}:this._c=function(n,e,t,r){return Fe(o,n,e,t,r,u)}}function Ge(n,e,t,r,i){var a=kn(n);return a.fnContext=t,a.fnOptions=r,e.slot&&((a.data||(a.data={})).slot=e.slot),a}function Be(n,e){for(var t in e)n[T(t)]=e[t]}Me(Re.prototype);var Le={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Le.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;s(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){0;var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=i,n.$attrs=r.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){An(!1);for(var d=n._props,u=n.$options._propKeys||[],h=0;h<u.length;h++){var p=u[h],m=n.$options.props;d[p]=qn(p,m,e,n)}An(!0),n.$options.propsData=e}t=t||a;var g=n.$options._parentListeners;n.$options._parentListeners=t,Xe(n,t,g),c&&(n.$slots=fe(i,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,rt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,at.push(e)):tt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,et(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);rt(e,"deactivated")}}(e,!0):e.$destroy())}},qe=Object.keys(Le);function He(n,e,t,r,i){if(!o(n)){var c=t.$options._base;if(d(n)&&(n=c.extend(n)),"function"==typeof n){var u;if(o(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=Ve;t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var r=n.owners=[t],i=!0,a=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var u=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==a&&(clearTimeout(a),a=null),null!==c&&(clearTimeout(c),c=null))},h=G((function(t){n.resolved=Je(t,e),i?r.length=0:u(!0)})),p=G((function(e){s(n.errorComp)&&(n.error=!0,u(!0))})),m=n(h,p);return d(m)&&(g(m)?o(n.resolved)&&m.then(h,p):g(m.component)&&(m.component.then(h,p),s(m.error)&&(n.errorComp=Je(m.error,e)),s(m.loading)&&(n.loadingComp=Je(m.loading,e),0===m.delay?n.loading=!0:a=setTimeout((function(){a=null,o(n.resolved)&&o(n.error)&&(n.loading=!0,u(!1))}),m.delay||200)),s(m.timeout)&&(c=setTimeout((function(){c=null,o(n.resolved)&&p(null)}),m.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(u=n,c)))return function(n,e,t,r,i){var a=yn();return a.asyncFactory=n,a.asyncMeta={data:e,context:t,children:r,tag:i},a}(u,e,t,r,i);e=e||{},Tt(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),a=i[r],o=e.model.callback;s(a)?(Array.isArray(a)?-1===a.indexOf(o):a!==o)&&(i[r]=[o].concat(a)):i[r]=o}(n.options,e);var h=function(n,e,t){var r=e.options.props;if(!o(r)){var i={},a=n.attrs,l=n.props;if(s(a)||s(l))for(var c in r){var d=j(c);he(i,l,c,d,!0)||he(i,a,c,d,!1)}return i}}(e,n);if(l(n.options.functional))return function(n,e,t,r,i){var o=n.options,l={},c=o.props;if(s(c))for(var d in c)l[d]=qn(d,c,e||a);else s(t.attrs)&&Be(l,t.attrs),s(t.props)&&Be(l,t.props);var u=new Re(t,l,i,r,n),h=o.render.call(null,u._c,u);if(h instanceof vn)return Ge(h,t,u.parent,o,u);if(Array.isArray(h)){for(var p=pe(h)||[],m=new Array(p.length),g=0;g<p.length;g++)m[g]=Ge(p[g],t,u.parent,o,u);return m}}(n,h,e,t,r);var p=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<qe.length;t++){var r=qe[t],i=e[r],a=Le[r];i===a||i&&i._merged||(e[r]=i?Ne(a,i):a)}}(e);var f=n.options.name||i;return new vn("vue-component-"+n.cid+(f?"-"+f:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:h,listeners:p,tag:i,children:r},u)}}}function Ne(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Fe(n,e,t,r,i,a){return(Array.isArray(t)||c(t))&&(i=r,r=t,t=void 0),l(a)&&(i=2),function(n,e,t,r,i){if(s(t)&&s(t.__ob__))return yn();s(t)&&s(t.is)&&(e=t.is);if(!e)return yn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===i?r=pe(r):1===i&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var a,c;if("string"==typeof e){var u;c=n.$vnode&&n.$vnode.ns||q.getTagNamespace(e),a=q.isReservedTag(e)?new vn(q.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!s(u=Ln(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):He(u,t,n,r,e)}else a=He(e,t,n,r);return Array.isArray(a)?a:s(a)?(s(c)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(s(e.children))for(var i=0,a=e.children.length;i<a;i++){var c=e.children[i];s(c.tag)&&(o(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(a,c),s(t)&&function(n){d(n.style)&&se(n.style);d(n.class)&&se(n.class)}(t),a):yn()}(n,e,t,r,i)}var Ue,Ve=null;function Je(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||be(t)))return t}}function Qe(n,e){Ue.$on(n,e)}function Ke(n,e){Ue.$off(n,e)}function Ye(n,e){var t=Ue;return function r(){var i=e.apply(null,arguments);null!==i&&t.$off(n,r)}}function Xe(n,e,t){Ue=n,de(e,t||{},Qe,Ke,Ye,n),Ue=void 0}var Ze=null;function nt(n){var e=Ze;return Ze=n,function(){Ze=e}}function et(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function tt(n,e){if(e){if(n._directInactive=!1,et(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)tt(n.$children[t]);rt(n,"activated")}}function rt(n,e){gn();var t=n.$options[e],r=e+" hook";if(t)for(var i=0,a=t.length;i<a;i++)Jn(t[i],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var it=[],at=[],ot={},st=!1,lt=!1,ct=0;var dt=0,ut=Date.now;if(J&&!Y){var ht=window.performance;ht&&"function"==typeof ht.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return ht.now()})}function pt(){var n,e;for(dt=ut(),lt=!0,it.sort((function(n,e){return n.id-e.id})),ct=0;ct<it.length;ct++)(n=it[ct]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=at.slice(),r=it.slice();ct=it.length=at.length=0,ot={},st=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,tt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&rt(r,"updated")}}(r),sn&&q.devtools&&sn.emit("flush")}var mt=0,gt=function(n,e,t,r,i){this.vm=n,i&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!F.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=O)),this.value=this.lazy?void 0:this.get()};gt.prototype.get=function(){var n;gn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Vn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&se(n),fn(),this.cleanupDeps()}return n},gt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},gt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},gt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==ot[e]){if(ot[e]=!0,lt){for(var t=it.length-1;t>ct&&it[t].id>n.id;)t--;it.splice(t+1,0,n)}else it.push(n);st||(st=!0,ae(pt))}}(this)},gt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Jn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},gt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},gt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},gt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||x(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:O,set:O};function vt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function bt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},i=n.$options._propKeys=[];n.$parent&&An(!1);var a=function(a){i.push(a);var o=qn(a,e,t,n);Sn(r,a,o),a in n||vt(n,"_props",a)};for(var o in e)a(o);An(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?O:S(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;h(e=n._data="function"==typeof e?function(n,e){gn();try{return n.call(e,e)}catch(n){return Vn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,i=(n.$options.methods,t.length);for(;i--;){var a=t[i];0,r&&w(r,a)||(o=void 0,36!==(o=(a+"").charCodeAt(0))&&95!==o&&vt(n,"_data",a))}var o;jn(e,!0)}(n):jn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var i in e){var a=e[i],o="function"==typeof a?a:a.get;0,r||(t[i]=new gt(n,o||O,O,yt)),i in n||xt(n,i,a)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var i=0;i<r.length;i++)_t(n,t,r[i]);else _t(n,t,r)}}(n,e.watch)}var yt={lazy:!0};function xt(n,e,t){var r=!on();"function"==typeof t?(ft.get=r?kt(e):wt(t),ft.set=O):(ft.get=t.get?r&&!1!==t.cache?kt(e):wt(t.get):O,ft.set=t.set||O),Object.defineProperty(n,e,ft)}function kt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function _t(n,e,t,r){return h(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var Et=0;function Tt(n){var e=n.options;if(n.super){var t=Tt(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var i in t)t[i]!==r[i]&&(e||(e={}),e[i]=t[i]);return e}(n);r&&C(n.extendOptions,r),(e=n.options=Bn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function At(n){this._init(n)}function It(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,i=n._Ctor||(n._Ctor={});if(i[r])return i[r];var a=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Bn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)xt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,B.forEach((function(n){o[n]=t[n]})),a&&(o.options.components[a]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=C({},o.options),i[r]=o,o}}function jt(n){return n&&(n.Ctor.options.name||n.tag)}function St(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function zt(n,e){var t=n.cache,r=n.keys,i=n._vnode;for(var a in t){var o=t[a];if(o){var s=o.name;s&&!e(s)&&Ct(t,a,r,i)}}}function Ct(n,e,t,r){var i=n[e];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=Et++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Bn(Tt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=fe(e._renderChildren,r),n.$scopedSlots=a,n._c=function(e,t,r,i){return Fe(n,e,t,r,i,!1)},n.$createElement=function(e,t,r,i){return Fe(n,e,t,r,i,!0)};var i=t&&t.data;Sn(n,"$attrs",i&&i.attrs||a,null,!0),Sn(n,"$listeners",e._parentListeners||a,null,!0)}(e),rt(e,"beforeCreate"),function(n){var e=ge(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Sn(n,t,e[t])})),An(!0))}(e),bt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),rt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(At),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=zn,n.prototype.$delete=Cn,n.prototype.$watch=function(n,e,t){if(h(e))return _t(this,n,e,t);(t=t||{}).user=!0;var r=new gt(this,n,e,t);if(t.immediate){var i='callback for immediate watcher "'+r.expression+'"';gn(),Jn(e,this,[r.value],this,i),fn()}return function(){r.teardown()}}}(At),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var i=0,a=n.length;i<a;i++)r.$on(n[i],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,i=n.length;r<i;r++)t.$off(n[r],e);return t}var a,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var s=o.length;s--;)if((a=o[s])===e||a.fn===e){o.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?z(t):t;for(var r=z(arguments,1),i='event handler for "'+n+'"',a=0,o=t.length;a<o;a++)Jn(t[a],e,r,e,i)}return e}}(At),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,i=t._vnode,a=nt(t);t._vnode=n,t.$el=i?t.__patch__(i,n):t.__patch__(t.$el,n,e,!1),a(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){rt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),rt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(At),function(n){Me(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,i=t._parentVnode;i&&(e.$scopedSlots=ye(i.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=i;try{Ve=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Vn(t,e,"render"),n=e._vnode}finally{Ve=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=yn()),n.parent=i,n}}(At);var $t=[String,RegExp,Array],Ot={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:$t,exclude:$t,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,a=t.componentInstance,o=t.componentOptions;n[r]={name:jt(o),tag:i,componentInstance:a},e.push(r),this.max&&e.length>parseInt(this.max)&&Ct(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ct(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){zt(n,(function(n){return St(e,n)}))})),this.$watch("exclude",(function(e){zt(n,(function(n){return!St(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var r=jt(t),i=this.include,a=this.exclude;if(i&&(!r||!St(i,r))||a&&r&&St(a,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return q}};Object.defineProperty(n,"config",e),n.util={warn:un,extend:C,mergeOptions:Bn,defineReactive:Sn},n.set=zn,n.delete=Cn,n.nextTick=ae,n.observable=function(n){return jn(n),n},n.options=Object.create(null),B.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,C(n.options.components,Ot),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=z(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Bn(this.options,n),this}}(n),It(n),function(n){B.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&h(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(At),Object.defineProperty(At.prototype,"$isServer",{get:on}),Object.defineProperty(At.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(At,"FunctionalRenderContext",{value:Re}),At.version="2.6.14";var Pt=b("style,class"),Dt=b("input,textarea,option,select,progress"),Mt=b("contenteditable,draggable,spellcheck"),Rt=b("events,caret,typing,plaintext-only"),Gt=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Bt="http://www.w3.org/1999/xlink",Lt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},qt=function(n){return Lt(n)?n.slice(6,n.length):""},Ht=function(n){return null==n||!1===n};function Nt(n){for(var e=n.data,t=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ft(r.data,e));for(;s(t=t.parent);)t&&t.data&&(e=Ft(e,t.data));return function(n,e){if(s(n)||s(e))return Ut(n,Vt(e));return""}(e.staticClass,e.class)}function Ft(n,e){return{staticClass:Ut(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function Ut(n,e){return n?e?n+" "+e:n:e||""}function Vt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,i=n.length;r<i;r++)s(e=Vt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Jt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Qt=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Kt=function(n){return Wt(n)||Qt(n)};var Yt=Object.create(null);var Xt=b("text,number,password,search,email,tel,url");var Zt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Jt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),nr={create:function(n,e){er(e)},update:function(n,e){n.data.ref!==e.data.ref&&(er(n,!0),er(e))},destroy:function(n){er(n,!0)}};function er(n,e){var t=n.data.ref;if(s(t)){var r=n.context,i=n.componentInstance||n.elm,a=r.$refs;e?Array.isArray(a[t])?x(a[t],i):a[t]===i&&(a[t]=void 0):n.data.refInFor?Array.isArray(a[t])?a[t].indexOf(i)<0&&a[t].push(i):a[t]=[i]:a[t]=i}}var tr=new vn("",{},[]),rr=["create","activate","update","remove","destroy"];function ir(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=s(t=n.data)&&s(t=t.attrs)&&t.type,i=s(t=e.data)&&s(t=t.attrs)&&t.type;return r===i||Xt(r)&&Xt(i)}(n,e)||l(n.isAsyncPlaceholder)&&o(e.asyncFactory.error))}function ar(n,e,t){var r,i,a={};for(r=e;r<=t;++r)s(i=n[r].key)&&(a[i]=r);return a}var or={create:sr,update:sr,destroy:function(n){sr(n,tr)}};function sr(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,i,a=n===tr,o=e===tr,s=cr(n.data.directives,n.context),l=cr(e.data.directives,e.context),c=[],d=[];for(t in l)r=s[t],i=l[t],r?(i.oldValue=r.value,i.oldArg=r.arg,ur(i,"update",e,n),i.def&&i.def.componentUpdated&&d.push(i)):(ur(i,"bind",e,n),i.def&&i.def.inserted&&c.push(i));if(c.length){var u=function(){for(var t=0;t<c.length;t++)ur(c[t],"inserted",e,n)};a?ue(e,"insert",u):u()}d.length&&ue(e,"postpatch",(function(){for(var t=0;t<d.length;t++)ur(d[t],"componentUpdated",e,n)}));if(!a)for(t in s)l[t]||ur(s[t],"unbind",n,n,o)}(n,e)}var lr=Object.create(null);function cr(n,e){var t,r,i=Object.create(null);if(!n)return i;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=lr),i[dr(r)]=r,r.def=Ln(e.$options,"directives",r.name);return i}function dr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function ur(n,e,t,r,i){var a=n.def&&n.def[e];if(a)try{a(t.elm,n,t,r,i)}catch(r){Vn(r,t.context,"directive "+n.name+" "+e+" hook")}}var hr=[nr,or];function pr(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||o(n.data.attrs)&&o(e.data.attrs))){var r,i,a=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in s(c.__ob__)&&(c=e.data.attrs=C({},c)),c)i=c[r],l[r]!==i&&mr(a,r,i,e.data.pre);for(r in(Y||Z)&&c.value!==l.value&&mr(a,"value",c.value),l)o(c[r])&&(Lt(r)?a.removeAttributeNS(Bt,qt(r)):Mt(r)||a.removeAttribute(r))}}function mr(n,e,t,r){r||n.tagName.indexOf("-")>-1?gr(n,e,t):Gt(e)?Ht(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Mt(e)?n.setAttribute(e,function(n,e){return Ht(e)||"false"===e?"false":"contenteditable"===n&&Rt(e)?e:"true"}(e,t)):Lt(e)?Ht(t)?n.removeAttributeNS(Bt,qt(e)):n.setAttributeNS(Bt,e,t):gr(n,e,t)}function gr(n,e,t){if(Ht(t))n.removeAttribute(e);else{if(Y&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:pr,update:pr};function vr(n,e){var t=e.elm,r=e.data,i=n.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var a=Nt(e),l=t._transitionClasses;s(l)&&(a=Ut(a,Vt(l))),a!==t._prevClass&&(t.setAttribute("class",a),t._prevClass=a)}}var br,yr={create:vr,update:vr};function xr(n,e,t){var r=br;return function i(){var a=e.apply(null,arguments);null!==a&&_r(n,i,t,r)}}var kr=Yn&&!(en&&Number(en[1])<=53);function wr(n,e,t,r){if(kr){var i=dt,a=e;e=a._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=i||n.timeStamp<=0||n.target.ownerDocument!==document)return a.apply(this,arguments)}}br.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function _r(n,e,t,r){(r||br).removeEventListener(n,e._wrapper||e,t)}function Er(n,e){if(!o(n.data.on)||!o(e.data.on)){var t=e.data.on||{},r=n.data.on||{};br=e.elm,function(n){if(s(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),de(t,r,wr,_r,xr,e.context),br=void 0}}var Tr,Ar={create:Er,update:Er};function Ir(n,e){if(!o(n.data.domProps)||!o(e.data.domProps)){var t,r,i=e.elm,a=n.data.domProps||{},l=e.data.domProps||{};for(t in s(l.__ob__)&&(l=e.data.domProps=C({},l)),a)t in l||(i[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===a[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var c=o(r)?"":String(r);jr(i,c)&&(i.value=c)}else if("innerHTML"===t&&Qt(i.tagName)&&o(i.innerHTML)){(Tr=Tr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=Tr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==a[t])try{i[t]=r}catch(n){}}}}function jr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(s(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Sr={create:Ir,update:Ir},zr=_((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Cr(n){var e=$r(n.style);return n.staticStyle?C(n.staticStyle,e):e}function $r(n){return Array.isArray(n)?$(n):"string"==typeof n?zr(n):n}var Or,Pr=/^--/,Dr=/\s*!important$/,Mr=function(n,e,t){if(Pr.test(e))n.style.setProperty(e,t);else if(Dr.test(t))n.style.setProperty(j(e),t.replace(Dr,""),"important");else{var r=Gr(e);if(Array.isArray(t))for(var i=0,a=t.length;i<a;i++)n.style[r]=t[i];else n.style[r]=t}},Rr=["Webkit","Moz","ms"],Gr=_((function(n){if(Or=Or||document.createElement("div").style,"filter"!==(n=T(n))&&n in Or)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Rr.length;t++){var r=Rr[t]+e;if(r in Or)return r}}));function Br(n,e){var t=e.data,r=n.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var i,a,l=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},u=c||d,h=$r(e.data.style)||{};e.data.normalizedStyle=s(h.__ob__)?C({},h):h;var p=function(n,e){var t,r={};if(e)for(var i=n;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=Cr(i.data))&&C(r,t);(t=Cr(n.data))&&C(r,t);for(var a=n;a=a.parent;)a.data&&(t=Cr(a.data))&&C(r,t);return r}(e,!0);for(a in u)o(p[a])&&Mr(l,a,"");for(a in p)(i=p[a])!==u[a]&&Mr(l,a,null==i?"":i)}}var Lr={create:Br,update:Br},qr=/\s+/;function Hr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(qr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Nr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(qr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Fr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&C(e,Ur(n.name||"v")),C(e,n),e}return"string"==typeof n?Ur(n):void 0}}var Ur=_((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Vr=J&&!X,Jr="transition",Wr="transitionend",Qr="animation",Kr="animationend";Vr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Jr="WebkitTransition",Wr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Qr="WebkitAnimation",Kr="webkitAnimationEnd"));var Yr=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Xr(n){Yr((function(){Yr(n)}))}function Zr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Hr(n,e))}function ni(n,e){n._transitionClasses&&x(n._transitionClasses,e),Nr(n,e)}function ei(n,e,t){var r=ri(n,e),i=r.type,a=r.timeout,o=r.propCount;if(!i)return t();var s="transition"===i?Wr:Kr,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),a+1),n.addEventListener(s,d)}var ti=/\b(transform|all)(,|$)/;function ri(n,e){var t,r=window.getComputedStyle(n),i=(r[Jr+"Delay"]||"").split(", "),a=(r[Jr+"Duration"]||"").split(", "),o=ii(i,a),s=(r[Qr+"Delay"]||"").split(", "),l=(r[Qr+"Duration"]||"").split(", "),c=ii(s,l),d=0,u=0;return"transition"===e?o>0&&(t="transition",d=o,u=a.length):"animation"===e?c>0&&(t="animation",d=c,u=l.length):u=(t=(d=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?a.length:l.length:0,{type:t,timeout:d,propCount:u,hasTransform:"transition"===t&&ti.test(r[Jr+"Property"])}}function ii(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ai(e)+ai(n[t])})))}function ai(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oi(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Fr(n.data.transition);if(!o(r)&&!s(t._enterCb)&&1===t.nodeType){for(var i=r.css,a=r.type,l=r.enterClass,c=r.enterToClass,u=r.enterActiveClass,h=r.appearClass,p=r.appearToClass,m=r.appearActiveClass,g=r.beforeEnter,f=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,k=r.appear,w=r.afterAppear,_=r.appearCancelled,E=r.duration,T=Ze,A=Ze.$vnode;A&&A.parent;)T=A.context,A=A.parent;var I=!T._isMounted||!n.isRootInsert;if(!I||k||""===k){var j=I&&h?h:l,S=I&&m?m:u,z=I&&p?p:c,C=I&&x||g,$=I&&"function"==typeof k?k:f,O=I&&w||b,P=I&&_||y,D=v(d(E)?E.enter:E);0;var M=!1!==i&&!X,R=ci($),B=t._enterCb=G((function(){M&&(ni(t,z),ni(t,S)),B.cancelled?(M&&ni(t,j),P&&P(t)):O&&O(t),t._enterCb=null}));n.data.show||ue(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),$&&$(t,B)})),C&&C(t),M&&(Zr(t,j),Zr(t,S),Xr((function(){ni(t,j),B.cancelled||(Zr(t,z),R||(li(D)?setTimeout(B,D):ei(t,a,B)))}))),n.data.show&&(e&&e(),$&&$(t,B)),M||R||B()}}}function si(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Fr(n.data.transition);if(o(r)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var i=r.css,a=r.type,l=r.leaveClass,c=r.leaveToClass,u=r.leaveActiveClass,h=r.beforeLeave,p=r.leave,m=r.afterLeave,g=r.leaveCancelled,f=r.delayLeave,b=r.duration,y=!1!==i&&!X,x=ci(p),k=v(d(b)?b.leave:b);0;var w=t._leaveCb=G((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(ni(t,c),ni(t,u)),w.cancelled?(y&&ni(t,l),g&&g(t)):(e(),m&&m(t)),t._leaveCb=null}));f?f(_):_()}function _(){w.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),h&&h(t),y&&(Zr(t,l),Zr(t,u),Xr((function(){ni(t,l),w.cancelled||(Zr(t,c),x||(li(k)?setTimeout(w,k):ei(t,a,w)))}))),p&&p(t,w),y||x||w())}}function li(n){return"number"==typeof n&&!isNaN(n)}function ci(n){if(o(n))return!1;var e=n.fns;return s(e)?ci(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function di(n,e){!0!==e.data.show&&oi(e)}var ui=function(n){var e,t,r={},i=n.modules,a=n.nodeOps;for(e=0;e<rr.length;++e)for(r[rr[e]]=[],t=0;t<i.length;++t)s(i[t][rr[e]])&&r[rr[e]].push(i[t][rr[e]]);function d(n){var e=a.parentNode(n);s(e)&&a.removeChild(e,n)}function u(n,e,t,i,o,c,d){if(s(n.elm)&&s(c)&&(n=c[d]=kn(n)),n.isRootInsert=!o,!function(n,e,t,i){var a=n.data;if(s(a)){var o=s(n.componentInstance)&&a.keepAlive;if(s(a=a.hook)&&s(a=a.init)&&a(n,!1),s(n.componentInstance))return h(n,e),p(t,n.elm,i),l(o)&&function(n,e,t,i){var a,o=n;for(;o.componentInstance;)if(o=o.componentInstance._vnode,s(a=o.data)&&s(a=a.transition)){for(a=0;a<r.activate.length;++a)r.activate[a](tr,o);e.push(o);break}p(t,n.elm,i)}(n,e,t,i),!0}}(n,e,t,i)){var u=n.data,g=n.children,b=n.tag;s(b)?(n.elm=n.ns?a.createElementNS(n.ns,b):a.createElement(b,n),v(n),m(n,g,e),s(u)&&f(n,e),p(t,n.elm,i)):l(n.isComment)?(n.elm=a.createComment(n.text),p(t,n.elm,i)):(n.elm=a.createTextNode(n.text),p(t,n.elm,i))}}function h(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(f(n,e),v(n)):(er(n),e.push(n))}function p(n,e,t){s(n)&&(s(t)?a.parentNode(t)===n&&a.insertBefore(n,e,t):a.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)u(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&a.appendChild(n.elm,a.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function f(n,t){for(var i=0;i<r.create.length;++i)r.create[i](tr,n);s(e=n.data.hook)&&(s(e.create)&&e.create(tr,n),s(e.insert)&&t.push(n))}function v(n){var e;if(s(e=n.fnScopeId))a.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&a.setStyleScope(n.elm,e),t=t.parent;s(e=Ze)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&a.setStyleScope(n.elm,e)}function y(n,e,t,r,i,a){for(;r<=i;++r)u(t[r],a,n,e,!1,t,r)}function x(n){var e,t,i=n.data;if(s(i))for(s(e=i.hook)&&s(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];s(r)&&(s(r.tag)?(w(r),x(r)):d(r.elm))}}function w(n,e){if(s(e)||s(n.data)){var t,i=r.remove.length+1;for(s(e)?e.listeners+=i:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,i),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&w(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else d(n.elm)}function _(n,e,t,r){for(var i=t;i<r;i++){var a=e[i];if(s(a)&&ir(n,a))return i}}function E(n,e,t,i,c,d){if(n!==e){s(e.elm)&&s(i)&&(e=i[c]=kn(e));var h=e.elm=n.elm;if(l(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var p,m=e.data;s(m)&&s(p=m.hook)&&s(p=p.prepatch)&&p(n,e);var f=n.children,v=e.children;if(s(m)&&g(e)){for(p=0;p<r.update.length;++p)r.update[p](n,e);s(p=m.hook)&&s(p=p.update)&&p(n,e)}o(e.text)?s(f)&&s(v)?f!==v&&function(n,e,t,r,i){var l,c,d,h=0,p=0,m=e.length-1,g=e[0],f=e[m],v=t.length-1,b=t[0],x=t[v],w=!i;for(0;h<=m&&p<=v;)o(g)?g=e[++h]:o(f)?f=e[--m]:ir(g,b)?(E(g,b,r,t,p),g=e[++h],b=t[++p]):ir(f,x)?(E(f,x,r,t,v),f=e[--m],x=t[--v]):ir(g,x)?(E(g,x,r,t,v),w&&a.insertBefore(n,g.elm,a.nextSibling(f.elm)),g=e[++h],x=t[--v]):ir(f,b)?(E(f,b,r,t,p),w&&a.insertBefore(n,f.elm,g.elm),f=e[--m],b=t[++p]):(o(l)&&(l=ar(e,h,m)),o(c=s(b.key)?l[b.key]:_(b,e,h,m))?u(b,r,n,g.elm,!1,t,p):ir(d=e[c],b)?(E(d,b,r,t,p),e[c]=void 0,w&&a.insertBefore(n,d.elm,g.elm)):u(b,r,n,g.elm,!1,t,p),b=t[++p]);h>m?y(n,o(t[v+1])?null:t[v+1].elm,t,p,v,r):p>v&&k(e,h,m)}(h,f,v,t,d):s(v)?(s(n.text)&&a.setTextContent(h,""),y(h,null,v,0,v.length-1,t)):s(f)?k(f,0,f.length-1):s(n.text)&&a.setTextContent(h,""):n.text!==e.text&&a.setTextContent(h,e.text),s(m)&&s(p=m.hook)&&s(p=p.postpatch)&&p(n,e)}}}function T(n,e,t){if(l(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var A=b("attrs,class,staticClass,staticStyle,key");function I(n,e,t,r){var i,a=e.tag,o=e.data,c=e.children;if(r=r||o&&o.pre,e.elm=n,l(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(o)&&(s(i=o.hook)&&s(i=i.init)&&i(e,!0),s(i=e.componentInstance)))return h(e,t),!0;if(s(a)){if(s(c))if(n.hasChildNodes())if(s(i=o)&&s(i=i.domProps)&&s(i=i.innerHTML)){if(i!==n.innerHTML)return!1}else{for(var d=!0,u=n.firstChild,p=0;p<c.length;p++){if(!u||!I(u,c[p],t,r)){d=!1;break}u=u.nextSibling}if(!d||u)return!1}else m(e,c,t);if(s(o)){var g=!1;for(var v in o)if(!A(v)){g=!0,f(e,t);break}!g&&o.class&&se(o.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!o(e)){var c,d=!1,h=[];if(o(n))d=!0,u(e,h);else{var p=s(n.nodeType);if(!p&&ir(n,e))E(n,e,h,null,null,i);else{if(p){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&I(n,e,h))return T(e,h,!0),n;c=n,n=new vn(a.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,f=a.parentNode(m);if(u(e,h,m._leaveCb?null:f,a.nextSibling(m)),s(e.parent))for(var v=e.parent,b=g(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var w=0;w<r.create.length;++w)r.create[w](tr,v);var _=v.data.hook.insert;if(_.merged)for(var A=1;A<_.fns.length;A++)_.fns[A]()}else er(v);v=v.parent}s(f)?k([n],0,0):s(n.tag)&&x(n)}}return T(e,h,d),e.elm}s(n)&&x(n)}}({nodeOps:Zt,modules:[fr,yr,Ar,Sr,Lr,J?{create:di,activate:di,remove:function(n,e){!0!==n.data.show?si(n,e):e()}}:{}].concat(hr)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&yi(n,"input")}));var hi={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ue(t,"postpatch",(function(){hi.componentUpdated(n,e,t)})):pi(n,e,t.context),n._vOptions=[].map.call(n.options,fi)):("textarea"===t.tag||Xt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",vi),n.addEventListener("compositionend",bi),n.addEventListener("change",bi),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){pi(n,e,t.context);var r=n._vOptions,i=n._vOptions=[].map.call(n.options,fi);if(i.some((function(n,e){return!M(n,r[e])})))(n.multiple?e.value.some((function(n){return gi(n,i)})):e.value!==e.oldValue&&gi(e.value,i))&&yi(n,"change")}}};function pi(n,e,t){mi(n,e,t),(Y||Z)&&setTimeout((function(){mi(n,e,t)}),0)}function mi(n,e,t){var r=e.value,i=n.multiple;if(!i||Array.isArray(r)){for(var a,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],i)a=R(r,fi(o))>-1,o.selected!==a&&(o.selected=a);else if(M(fi(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));i||(n.selectedIndex=-1)}}function gi(n,e){return e.every((function(e){return!M(e,n)}))}function fi(n){return"_value"in n?n._value:n.value}function vi(n){n.target.composing=!0}function bi(n){n.target.composing&&(n.target.composing=!1,yi(n.target,"input"))}function yi(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function xi(n){return!n.componentInstance||n.data&&n.data.transition?n:xi(n.componentInstance._vnode)}var ki={model:hi,show:{bind:function(n,e,t){var r=e.value,i=(t=xi(t)).data&&t.data.transition,a=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&i?(t.data.show=!0,oi(t,(function(){n.style.display=a}))):n.style.display=r?a:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=xi(t)).data&&t.data.transition?(t.data.show=!0,r?oi(t,(function(){n.style.display=n.__vOriginalDisplay})):si(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,i){i||(n.style.display=n.__vOriginalDisplay)}}},wi={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function _i(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?_i(We(e.children)):n}function Ei(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var i=t._parentListeners;for(var a in i)e[T(a)]=i[a];return e}function Ti(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ai=function(n){return n.tag||be(n)},Ii=function(n){return"show"===n.name},ji={name:"transition",props:wi,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ai)).length){0;var r=this.mode;0;var i=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return i;var a=_i(i);if(!a)return i;if(this._leaving)return Ti(n,i);var o="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?o+"comment":o+a.tag:c(a.key)?0===String(a.key).indexOf(o)?a.key:o+a.key:a.key;var s=(a.data||(a.data={})).transition=Ei(this),l=this._vnode,d=_i(l);if(a.data.directives&&a.data.directives.some(Ii)&&(a.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(a,d)&&!be(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var u=d.data.transition=C({},s);if("out-in"===r)return this._leaving=!0,ue(u,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ti(n,i);if("in-out"===r){if(be(a))return l;var h,p=function(){h()};ue(s,"afterEnter",p),ue(s,"enterCancelled",p),ue(u,"delayLeave",(function(n){h=n}))}}return i}}},Si=C({tag:String,moveClass:String},wi);function zi(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ci(n){n.data.newPos=n.elm.getBoundingClientRect()}function $i(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,i=e.top-t.top;if(r||i){n.data.moved=!0;var a=n.elm.style;a.transform=a.WebkitTransform="translate("+r+"px,"+i+"px)",a.transitionDuration="0s"}}delete Si.mode;var Oi={Transition:ji,TransitionGroup:{props:Si,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var i=nt(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,i(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],a=this.children=[],o=Ei(this),s=0;s<i.length;s++){var l=i[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))a.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(r){for(var c=[],d=[],u=0;u<r.length;u++){var h=r[u];h.data.transition=o,h.data.pos=h.elm.getBoundingClientRect(),t[h.key]?c.push(h):d.push(h)}this.kept=n(e,null,c),this.removed=d}return n(e,null,a)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(zi),n.forEach(Ci),n.forEach($i),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Zr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Wr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Wr,n),t._moveCb=null,ni(t,e))})}})))},methods:{hasMove:function(n,e){if(!Vr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Nr(t,n)})),Hr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ri(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};At.config.mustUseProp=function(n,e,t){return"value"===t&&Dt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},At.config.isReservedTag=Kt,At.config.isReservedAttr=Pt,At.config.getTagNamespace=function(n){return Qt(n)?"svg":"math"===n?"math":void 0},At.config.isUnknownElement=function(n){if(!J)return!0;if(Kt(n))return!1;if(n=n.toLowerCase(),null!=Yt[n])return Yt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Yt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yt[n]=/HTMLUnknownElement/.test(e.toString())},C(At.options.directives,ki),C(At.options.components,Oi),At.prototype.__patch__=J?ui:O,At.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=yn),rt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new gt(n,r,O,{before:function(){n._isMounted&&!n._isDestroyed&&rt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,rt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){q.devtools&&sn&&sn.emit("init",At)}),0);var Pi=At;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Di(n,e){for(var t in e)n[t]=e[t];return n}var Mi=/[!'()*]/g,Ri=function(n){return"%"+n.charCodeAt(0).toString(16)},Gi=/%2C/g,Bi=function(n){return encodeURIComponent(n).replace(Mi,Ri).replace(Gi,",")};function Li(n){try{return decodeURIComponent(n)}catch(n){0}return n}var qi=function(n){return null==n||"object"==typeof n?n:String(n)};function Hi(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Li(t.shift()),i=t.length>0?Li(t.join("=")):null;void 0===e[r]?e[r]=i:Array.isArray(e[r])?e[r].push(i):e[r]=[e[r],i]})),e):e}function Ni(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Bi(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(Bi(e)):r.push(Bi(e)+"="+Bi(n)))})),r.join("&")}return Bi(e)+"="+Bi(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Fi=/\/?$/;function Ui(n,e,t,r){var i=r&&r.options.stringifyQuery,a=e.query||{};try{a=Vi(a)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:a,params:e.params||{},fullPath:Qi(e,i),matched:n?Wi(n):[]};return t&&(o.redirectedFrom=Qi(t,i)),Object.freeze(o)}function Vi(n){if(Array.isArray(n))return n.map(Vi);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Vi(n[t]);return e}return n}var Ji=Ui(null,{path:"/"});function Wi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Qi(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var i=n.hash;return void 0===i&&(i=""),(t||"/")+(e||Ni)(r)+i}function Ki(n,e,t){return e===Ji?n===e:!!e&&(n.path&&e.path?n.path.replace(Fi,"")===e.path.replace(Fi,"")&&(t||n.hash===e.hash&&Yi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Yi(n.query,e.query)&&Yi(n.params,e.params))))}function Yi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,i){var a=n[t];if(r[i]!==t)return!1;var o=e[t];return null==a||null==o?a===o:"object"==typeof a&&"object"==typeof o?Yi(a,o):String(a)===String(o)}))}function Xi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var i=t.instances[r],a=t.enteredCbs[r];if(i&&a){delete t.enteredCbs[r];for(var o=0;o<a.length;o++)i._isBeingDestroyed||a[o](i)}}}}var Zi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,i=e.parent,a=e.data;a.routerView=!0;for(var o=i.$createElement,s=t.name,l=i.$route,c=i._routerViewCache||(i._routerViewCache={}),d=0,u=!1;i&&i._routerRoot!==i;){var h=i.$vnode?i.$vnode.data:{};h.routerView&&d++,h.keepAlive&&i._directInactive&&i._inactive&&(u=!0),i=i.$parent}if(a.routerViewDepth=d,u){var p=c[s],m=p&&p.component;return m?(p.configProps&&na(m,a,p.route,p.configProps),o(m,a,r)):o()}var g=l.matched[d],f=g&&g.components[s];if(!g||!f)return c[s]=null,o();c[s]={component:f},a.registerRouteInstance=function(n,e){var t=g.instances[s];(e&&t!==n||!e&&t===n)&&(g.instances[s]=e)},(a.hook||(a.hook={})).prepatch=function(n,e){g.instances[s]=e.componentInstance},a.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[s]&&(g.instances[s]=n.componentInstance),Xi(l)};var v=g.props&&g.props[s];return v&&(Di(c[s],{route:l,configProps:v}),na(f,a,l,v)),o(f,a,r)}};function na(n,e,t,r){var i=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(i){i=e.props=Di({},i);var a=e.attrs=e.attrs||{};for(var o in i)n.props&&o in n.props||(a[o]=i[o],delete i[o])}}function ea(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var i=e.split("/");t&&i[i.length-1]||i.pop();for(var a=n.replace(/^\//,"").split("/"),o=0;o<a.length;o++){var s=a[o];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function ta(n){return n.replace(/\/+/g,"/")}var ra=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ia=ba,aa=da,oa=function(n,e){return ha(da(n,e),e)},sa=ha,la=va,ca=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function da(n,e){for(var t,r=[],i=0,a=0,o="",s=e&&e.delimiter||"/";null!=(t=ca.exec(n));){var l=t[0],c=t[1],d=t.index;if(o+=n.slice(a,d),a=d+l.length,c)o+=c[1];else{var u=n[a],h=t[2],p=t[3],m=t[4],g=t[5],f=t[6],v=t[7];o&&(r.push(o),o="");var b=null!=h&&null!=u&&u!==h,y="+"===f||"*"===f,x="?"===f||"*"===f,k=t[2]||s,w=m||g;r.push({name:p||i++,prefix:h||"",delimiter:k,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:w?ma(w):v?".*":"[^"+pa(k)+"]+?"})}}return a<n.length&&(o+=n.substr(a)),o&&r.push(o),r}function ua(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ha(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",fa(e)));return function(e,r){for(var i="",a=e||{},o=(r||{}).pretty?ua:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=a[l.name];if(null==d){if(l.optional){l.partial&&(i+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ra(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var u=0;u<d.length;u++){if(c=o(d[u]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");i+=(0===u?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');i+=l.prefix+c}}else i+=l}return i}}function pa(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function ma(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function ga(n,e){return n.keys=e,n}function fa(n){return n&&n.sensitive?"":"i"}function va(n,e,t){ra(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,a="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)a+=pa(s);else{var l=pa(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),a+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=pa(t.delimiter||"/"),u=a.slice(-d.length)===d;return r||(a=(u?a.slice(0,-d.length):a)+"(?:"+d+"(?=$))?"),a+=i?"$":r&&u?"":"(?="+d+"|$)",ga(new RegExp("^"+a,fa(t)),e)}function ba(n,e,t){return ra(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return ga(n,e)}(n,e):ra(n)?function(n,e,t){for(var r=[],i=0;i<n.length;i++)r.push(ba(n[i],e,t).source);return ga(new RegExp("(?:"+r.join("|")+")",fa(t)),e)}(n,e,t):function(n,e,t){return va(da(n,t),e,t)}(n,e,t)}ia.parse=aa,ia.compile=oa,ia.tokensToFunction=sa,ia.tokensToRegExp=la;var ya=Object.create(null);function xa(n,e,t){e=e||{};try{var r=ya[n]||(ya[n]=ia.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function ka(n,e,t,r){var i="string"==typeof n?{path:n}:n;if(i._normalized)return i;if(i.name){var a=(i=Di({},n)).params;return a&&"object"==typeof a&&(i.params=Di({},a)),i}if(!i.path&&i.params&&e){(i=Di({},i))._normalized=!0;var o=Di(Di({},e.params),i.params);if(e.name)i.name=e.name,i.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;i.path=xa(s,o,e.path)}else 0;return i}var l=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var i=n.indexOf("?");return i>=0&&(t=n.slice(i+1),n=n.slice(0,i)),{path:n,query:t,hash:e}}(i.path||""),c=e&&e.path||"/",d=l.path?ea(l.path,c,t||i.append):c,u=function(n,e,t){void 0===e&&(e={});var r,i=t||Hi;try{r=i(n||"")}catch(n){r={}}for(var a in e){var o=e[a];r[a]=Array.isArray(o)?o.map(qi):qi(o)}return r}(l.query,i.query,r&&r.options.parseQuery),h=i.hash||l.hash;return h&&"#"!==h.charAt(0)&&(h="#"+h),{_normalized:!0,path:d,query:u,hash:h}}var wa,_a=function(){},Ea={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),a=i.location,o=i.route,s=i.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,u=null==c?"router-link-active":c,h=null==d?"router-link-exact-active":d,p=null==this.activeClass?u:this.activeClass,m=null==this.exactActiveClass?h:this.exactActiveClass,g=o.redirectedFrom?Ui(null,ka(o.redirectedFrom),null,t):o;l[m]=Ki(r,g,this.exactPath),l[p]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(Fi,"/").indexOf(e.path.replace(Fi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,g);var f=l[m]?this.ariaCurrentValue:null,v=function(n){Ta(n)&&(e.replace?t.replace(a,_a):t.push(a,_a))},b={click:Ta};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[p],isExactActive:l[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":f};else{var k=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(k){k.isStatic=!1;var w=k.data=Di({},k.data);for(var _ in w.on=w.on||{},w.on){var E=w.on[_];_ in b&&(w.on[_]=Array.isArray(E)?E:[E])}for(var T in b)T in w.on?w.on[T].push(b[T]):w.on[T]=v;var A=k.data.attrs=Di({},k.data.attrs);A.href=s,A["aria-current"]=f}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Ta(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Aa="undefined"!=typeof window;function Ia(n,e,t,r,i){var a=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,i,a,o){var s=i.path,l=i.name;0;var c=i.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ta(e.path+"/"+n)}(s,a,c.strict);"boolean"==typeof i.caseSensitive&&(c.sensitive=i.caseSensitive);var u={path:d,regex:ja(d,c),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:l,parent:a,matchAs:o,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var a=o?ta(o+"/"+i.path):void 0;n(e,t,r,i,u,a)}));t[u.path]||(e.push(u.path),t[u.path]=u);if(void 0!==i.alias)for(var h=Array.isArray(i.alias)?i.alias:[i.alias],p=0;p<h.length;++p){0;var m={path:h[p],children:i.children};n(e,t,r,m,a,u.path||"/")}l&&(r[l]||(r[l]=u))}(a,o,s,n,i)}));for(var l=0,c=a.length;l<c;l++)"*"===a[l]&&(a.push(a.splice(l,1)[0]),c--,l--);return{pathList:a,pathMap:o,nameMap:s}}function ja(n,e){return ia(n,[],e)}function Sa(n,e){var t=Ia(n),r=t.pathList,i=t.pathMap,a=t.nameMap;function o(n,t,o){var s=ka(n,t,!1,e),c=s.name;if(c){var d=a[c];if(!d)return l(null,s);var u=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var h in t.params)!(h in s.params)&&u.indexOf(h)>-1&&(s.params[h]=t.params[h]);return s.path=xa(d.path,s.params),l(d,s,o)}if(s.path){s.params={};for(var p=0;p<r.length;p++){var m=r[p],g=i[m];if(za(g.regex,s.path,s.params))return l(g,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,i="function"==typeof r?r(Ui(n,t,null,e)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return l(null,t);var s=i,c=s.name,d=s.path,u=t.query,h=t.hash,p=t.params;if(u=s.hasOwnProperty("query")?s.query:u,h=s.hasOwnProperty("hash")?s.hash:h,p=s.hasOwnProperty("params")?s.params:p,c){a[c];return o({_normalized:!0,name:c,query:u,hash:h,params:p},void 0,t)}if(d){var m=function(n,e){return ea(n,e.parent?e.parent.path:"/",!0)}(d,n);return o({_normalized:!0,path:xa(m,p),query:u,hash:h},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:xa(t,e.params)});if(r){var i=r.matched,a=i[i.length-1];return e.params=r.params,l(a,e)}return l(null,e)}(0,t,n.matchAs):Ui(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?a[n]:void 0;Ia([e||n],r,i,a,t),t&&t.alias.length&&Ia(t.alias.map((function(n){return{path:n,children:[e]}})),r,i,a,t)},getRoutes:function(){return r.map((function(n){return i[n]}))},addRoutes:function(n){Ia(n,r,i,a)}}}function za(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var i=1,a=r.length;i<a;++i){var o=n.keys[i-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[i]?Li(r[i]):r[i])}return!0}var Ca=Aa&&window.performance&&window.performance.now?window.performance:Date;function $a(){return Ca.now().toFixed(3)}var Oa=$a();function Pa(){return Oa}function Da(n){return Oa=n}var Ma=Object.create(null);function Ra(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Di({},window.history.state);return t.key=Pa(),window.history.replaceState(t,"",e),window.addEventListener("popstate",La),function(){window.removeEventListener("popstate",La)}}function Ga(n,e,t,r){if(n.app){var i=n.options.scrollBehavior;i&&n.app.$nextTick((function(){var a=function(){var n=Pa();if(n)return Ma[n]}(),o=i.call(n,e,t,r?a:null);o&&("function"==typeof o.then?o.then((function(n){Ua(n,a)})).catch((function(n){0})):Ua(o,a))}))}}function Ba(){var n=Pa();n&&(Ma[n]={x:window.pageXOffset,y:window.pageYOffset})}function La(n){Ba(),n.state&&n.state.key&&Da(n.state.key)}function qa(n){return Na(n.x)||Na(n.y)}function Ha(n){return{x:Na(n.x)?n.x:window.pageXOffset,y:Na(n.y)?n.y:window.pageYOffset}}function Na(n){return"number"==typeof n}var Fa=/^#\d/;function Ua(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var i=Fa.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(i){var a=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(i,a={x:Na((t=a).x)?t.x:0,y:Na(t.y)?t.y:0})}else qa(n)&&(e=Ha(n))}else r&&qa(n)&&(e=Ha(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Va,Ja=Aa&&((-1===(Va=window.navigator.userAgent).indexOf("Android 2.")&&-1===Va.indexOf("Android 4.0")||-1===Va.indexOf("Mobile Safari")||-1!==Va.indexOf("Chrome")||-1!==Va.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wa(n,e){Ba();var t=window.history;try{if(e){var r=Di({},t.state);r.key=Pa(),t.replaceState(r,"",n)}else t.pushState({key:Da($a())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Qa(n){Wa(n,!0)}function Ka(n,e,t){var r=function(i){i>=n.length?t():n[i]?e(n[i],(function(){r(i+1)})):r(i+1)};r(0)}var Ya={redirected:2,aborted:4,cancelled:8,duplicated:16};function Xa(n,e){return no(n,e,Ya.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return eo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Za(n,e){return no(n,e,Ya.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function no(n,e,t,r){var i=new Error(r);return i._isRouter=!0,i.from=n,i.to=e,i.type=t,i}var eo=["params","query","hash"];function to(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ro(n,e){return to(n)&&n._isRouter&&(null==e||n.type===e)}function io(n){return function(e,t,r){var i=!1,a=0,o=null;ao(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){i=!0,a++;var l,c=lo((function(e){var i;((i=e).__esModule||so&&"Module"===i[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:wa.extend(e),t.components[s]=e,--a<=0&&r()})),d=lo((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=to(n)?n:new Error(e),r(o))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var u=l.component;u&&"function"==typeof u.then&&u.then(c,d)}}})),i||r()}}function ao(n,e){return oo(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function oo(n){return Array.prototype.concat.apply([],n)}var so="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function lo(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var co=function(n,e){this.router=n,this.base=function(n){if(!n)if(Aa){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ji,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function uo(n,e,t,r){var i=ao(n,(function(n,r,i,a){var o=function(n,e){"function"!=typeof n&&(n=wa.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,i,a)})):t(o,r,i,a)}));return oo(r?i.reverse():i)}function ho(n,e){if(e)return function(){return n.apply(e,arguments)}}co.prototype.listen=function(n){this.cb=n},co.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},co.prototype.onError=function(n){this.errorCbs.push(n)},co.prototype.transitionTo=function(n,e,t){var r,i=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var a=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),e&&e(r),i.ensureURL(),i.router.afterHooks.forEach((function(n){n&&n(r,a)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!i.ready&&(ro(n,Ya.redirected)&&a===Ji||(i.ready=!0,i.readyErrorCbs.forEach((function(e){e(n)}))))}))},co.prototype.confirmTransition=function(n,e,t){var r=this,i=this.current;this.pending=n;var a,o,s=function(n){!ro(n)&&to(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=i.matched.length-1;if(Ki(n,i)&&l===c&&n.matched[l]===i.matched[c])return this.ensureURL(),n.hash&&Ga(this.router,i,n,!1),s(((o=no(a=i,n,Ya.duplicated,'Avoided redundant navigation to current location: "'+a.fullPath+'".')).name="NavigationDuplicated",o));var d=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=d.updated,h=d.deactivated,p=d.activated,m=[].concat(function(n){return uo(n,"beforeRouteLeave",ho,!0)}(h),this.router.beforeHooks,function(n){return uo(n,"beforeRouteUpdate",ho)}(u),p.map((function(n){return n.beforeEnter})),io(p)),g=function(e,t){if(r.pending!==n)return s(Za(i,n));try{e(n,i,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return no(n,e,Ya.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(i,n))):to(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(Xa(i,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};Ka(m,g,(function(){Ka(function(n){return uo(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,i,a){return n(r,i,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),a(n)}))}}(n,t,r)}))}(p).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return s(Za(i,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Xi(n)}))}))}))},co.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},co.prototype.setupListeners=function(){},co.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ji,this.pending=null};var po=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mo(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Ja&&t;r&&this.listeners.push(Ra());var i=function(){var t=n.current,i=mo(n.base);n.current===Ji&&i===n._startLocation||n.transitionTo(i,(function(n){r&&Ga(e,n,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Wa(ta(r.base+n.fullPath)),Ga(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){Qa(ta(r.base+n.fullPath)),Ga(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mo(this.base)!==this.current.fullPath){var e=ta(this.base+this.current.fullPath);n?Wa(e):Qa(e)}},e.prototype.getCurrentLocation=function(){return mo(this.base)},e}(co);function mo(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(ta(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var go=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mo(n);if(!/^\/#/.test(e))return window.location.replace(ta(n+"/#"+e)),!0}(this.base)||fo()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Ja&&e;t&&this.listeners.push(Ra());var r=function(){var e=n.current;fo()&&n.transitionTo(vo(),(function(r){t&&Ga(n.router,r,e,!0),Ja||xo(r.fullPath)}))},i=Ja?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},e.prototype.push=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){yo(n.fullPath),Ga(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,i=this.current;this.transitionTo(n,(function(n){xo(n.fullPath),Ga(r.router,n,i,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vo()!==e&&(n?yo(e):xo(e))},e.prototype.getCurrentLocation=function(){return vo()},e}(co);function fo(){var n=vo();return"/"===n.charAt(0)||(xo("/"+n),!1)}function vo(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function bo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function yo(n){Ja?Wa(bo(n)):window.location.hash=n}function xo(n){Ja?Qa(bo(n)):window.location.replace(bo(n))}var ko=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ro(n,Ya.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(co),wo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Sa(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Ja&&!1!==n.fallback,this.fallback&&(e="hash"),Aa||(e="abstract"),this.mode=e,e){case"history":this.history=new po(this,n.base);break;case"hash":this.history=new go(this,n.base,this.fallback);break;case"abstract":this.history=new ko(this,n.base);break;default:0}},_o={currentRoute:{configurable:!0}};function Eo(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},_o.currentRoute.get=function(){return this.history&&this.history.current},wo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof po||t instanceof go){var r=function(n){t.setupListeners(),function(n){var r=t.current,i=e.options.scrollBehavior;Ja&&i&&"fullPath"in n&&Ga(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wo.prototype.beforeEach=function(n){return Eo(this.beforeHooks,n)},wo.prototype.beforeResolve=function(n){return Eo(this.resolveHooks,n)},wo.prototype.afterEach=function(n){return Eo(this.afterHooks,n)},wo.prototype.onReady=function(n,e){this.history.onReady(n,e)},wo.prototype.onError=function(n){this.history.onError(n)},wo.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},wo.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},wo.prototype.go=function(n){this.history.go(n)},wo.prototype.back=function(){this.go(-1)},wo.prototype.forward=function(){this.go(1)},wo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wo.prototype.resolve=function(n,e,t){var r=ka(n,e=e||this.history.current,t,this),i=this.match(r,e),a=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?ta(n+"/"+r):r}(this.history.base,a,this.mode),normalizedTo:r,resolved:i}},wo.prototype.getRoutes=function(){return this.matcher.getRoutes()},wo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Ji&&this.history.transitionTo(this.history.getCurrentLocation())},wo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ji&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wo.prototype,_o),wo.install=function n(e){if(!n.installed||wa!==e){n.installed=!0,wa=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Zi),e.component("RouterLink",Ea);var i=e.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},wo.version="3.5.3",wo.isNavigationFailure=ro,wo.NavigationFailureType=Ya,wo.START_LOCATION=Ji,Aa&&window.Vue&&window.Vue.use(wo);var To=wo;t(227),t(176),t(261),t(103),t(263),t(35),t(36),t(264);function Ao(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(80),t(93),t(122);function Io(n){return(Io="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var jo=t(75),So=(t(188),t(18),t(44),t(230),t(231),t(40),t(29),{NotFound:function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,478))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,477))}}),zo={"v-6768a9e7":function(){return t.e(5).then(t.bind(null,480))},"v-3a59c096":function(){return t.e(6).then(t.bind(null,481))},"v-635bdaa6":function(){return t.e(7).then(t.bind(null,482))},"v-a74a57ce":function(){return t.e(8).then(t.bind(null,483))},"v-d52fa6b8":function(){return t.e(9).then(t.bind(null,484))},"v-0096a856":function(){return t.e(10).then(t.bind(null,485))},"v-01ba14e3":function(){return t.e(11).then(t.bind(null,486))},"v-784ff23a":function(){return t.e(12).then(t.bind(null,487))},"v-2deaaf56":function(){return t.e(13).then(t.bind(null,488))},"v-2d73f679":function(){return t.e(14).then(t.bind(null,489))},"v-d9a518f6":function(){return t.e(15).then(t.bind(null,490))},"v-5736fc35":function(){return t.e(16).then(t.bind(null,491))},"v-fa1b9a8a":function(){return t.e(17).then(t.bind(null,492))},"v-62d2e41f":function(){return t.e(18).then(t.bind(null,493))},"v-346aebdf":function(){return t.e(19).then(t.bind(null,494))},"v-7d6f7b6e":function(){return t.e(20).then(t.bind(null,479))},"v-00d5e539":function(){return t.e(21).then(t.bind(null,495))},"v-53104ef6":function(){return t.e(22).then(t.bind(null,496))},"v-1a9d53e5":function(){return t.e(23).then(t.bind(null,497))},"v-150b83f6":function(){return t.e(24).then(t.bind(null,498))},"v-a113e2c4":function(){return t.e(25).then(t.bind(null,499))},"v-d2440a98":function(){return t.e(26).then(t.bind(null,500))},"v-680748c4":function(){return t.e(27).then(t.bind(null,501))},"v-416d1532":function(){return t.e(28).then(t.bind(null,502))},"v-ca22736a":function(){return t.e(29).then(t.bind(null,503))},"v-7d1c2eeb":function(){return t.e(30).then(t.bind(null,504))},"v-60e51ea4":function(){return t.e(31).then(t.bind(null,505))},"v-9cbdbc54":function(){return t.e(32).then(t.bind(null,506))},"v-c24e73d6":function(){return t.e(33).then(t.bind(null,507))},"v-6d2e70eb":function(){return t.e(34).then(t.bind(null,508))},"v-2fe3fa79":function(){return t.e(35).then(t.bind(null,509))},"v-0b8036da":function(){return t.e(36).then(t.bind(null,510))},"v-5f03001a":function(){return t.e(37).then(t.bind(null,511))},"v-064a931c":function(){return t.e(38).then(t.bind(null,512))},"v-0436f619":function(){return t.e(39).then(t.bind(null,513))},"v-2b3c7b2a":function(){return t.e(40).then(t.bind(null,514))},"v-48ab307b":function(){return t.e(41).then(t.bind(null,515))},"v-a63cde52":function(){return t.e(42).then(t.bind(null,516))},"v-49b9f1b0":function(){return t.e(43).then(t.bind(null,517))},"v-0a21df14":function(){return t.e(44).then(t.bind(null,518))},"v-5fea683d":function(){return t.e(45).then(t.bind(null,519))},"v-512420e6":function(){return t.e(46).then(t.bind(null,520))},"v-4c85098c":function(){return t.e(47).then(t.bind(null,521))},"v-385c1de4":function(){return t.e(48).then(t.bind(null,522))},"v-00de7c67":function(){return t.e(49).then(t.bind(null,523))},"v-32b6909a":function(){return t.e(50).then(t.bind(null,524))},"v-e097ec3a":function(){return t.e(51).then(t.bind(null,525))},"v-dcf1b992":function(){return t.e(52).then(t.bind(null,526))},"v-64a87d57":function(){return t.e(53).then(t.bind(null,527))},"v-33098487":function(){return t.e(54).then(t.bind(null,528))}};function Co(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var $o=/-(\w)/g,Oo=Co((function(n){return n.replace($o,(function(n,e){return e?e.toUpperCase():""}))})),Po=/\B([A-Z])/g,Do=Co((function(n){return n.replace(Po,"-$1").toLowerCase()})),Mo=Co((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Ro(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Mo(Oo(e))):n(Mo(e))||n(Do(e))}var Go=Object.assign({},So,zo),Bo=function(n){return Go[n]},Lo=function(n){return zo[n]},qo=function(n){return So[n]},Ho=function(n){return Pi.component(n)};function No(n){return Ro(Lo,n)}function Fo(n){return Ro(qo,n)}function Uo(n){return Ro(Bo,n)}function Vo(n){return Ro(Ho,n)}function Jo(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=i(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Vo(e)||!Uo(e)){n.next=5;break}return n.next=3,Uo(e)();case 3:t=n.sent,Pi.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Wo(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}t(81);var Qo=t(100);function Ko(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,i,a=[],o=!0,s=!1;try{for(t=t.call(n);!(o=(r=t.next()).done)&&(a.push(r.value),!e||a.length!==e);o=!0);}catch(n){s=!0,i=n}finally{try{o||null==t.return||t.return()}finally{if(s)throw i}}return a}}(n,e)||Object(Qo.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}t(121),t(126),t(77);var Yo=t(220),Xo=t.n(Yo),Zo=t(221),ns=t.n(Zo),es={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Ko(n,1)[0]})).map((function(n){var e=Ko(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(ns()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=rs(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(jo.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=is(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Xo()([{name:"description",content:this.$description}],n,this.siteMeta,as)},updateCanonicalLink:function(){ts(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",rs(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){is(null,this.currentMetaTags),ts()}};function ts(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function rs(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function is(n,e){if(e&&Object(jo.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function as(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(136);var os=t(144),ss={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(os)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),i=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),a=window.innerHeight+r,o=0;o<t.length;o++){var s=t[o],l=t[o+1],c=0===o&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(s.hash)){var u=s;if(a===i)for(var h=o+1;h<t.length;h++)if(d===decodeURIComponent(t[h].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(u.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ls=(t(106),t(101)),cs=t.n(ls),ds={mounted:function(){var n=this;cs.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Pi.component(n.name)||cs.a.start(),t()})),this.$router.afterEach((function(){cs.a.done(),n.isSidebarOpen=!1}))}};t(79),t(78),t(378);function us(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(138);function hs(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ps(n,e,t){return e&&hs(n.prototype,e),t&&hs(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(379);var ms=function(){function n(){us(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ps(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,i=n.duration,a=void 0===i?3e3:i,o=document.createElement("div");o.className="message move-in",o.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(o),a>0&&setTimeout((function(){e.close(o)}),a)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),gs={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ms).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(233),t(102),t(104),t(137),t(381);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=n:i.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var fs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},vs={},bs=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},ys=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:fs[n]},xs=function n(e,t,r){var i=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))i[n]=t[n];else{var e=n.replace("data","");i.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,a=e.children;i.appendChild(n(t,r,a))})),i},ks=function(n,e,t){var r,i=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},ws=function(n,e){var t,r,i=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=bs(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,a=[eval][0](i);return a.template=e,a}(s.js,s.html);var l=ys("vue");return s.jsLib.unshift(l),s},_s=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<html>([\s\S]+)<\/html>/),a=n.match(/<script>([\s\S]+)<\/script>/),o={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Es=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ts(){var n=ks(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=ks(n,"vuepress-plugin-demo-block__code"),t=ks(n,"vuepress-plugin-demo-block__display"),r=ks(n,"vuepress-plugin-demo-block__footer"),i=ks(t,"vuepress-plugin-demo-block__app"),a=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),a={js:i,css:i.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Es(n),htmlTpl:bs("")},o=ys("react"),s=ys("reactDOM");return a.jsLib.unshift(o,s),a}(a,o):"vanilla"===s?_s(a,o):ws(a,o),d=xs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",As.bind(null,d,l,e,r)),ys("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=i.concat(a).concat(ys("cssLib")).concat(ys("jsLib")).join(",");return xs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),ys("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,i=n.jsLib,a=n.cssLib,o=JSON.stringify({css:e,html:t,js:r,js_external:i.concat(ys("jsLib")).join(";"),css_external:a.concat(ys("cssLib")).join(";"),layout:ys("codepenLayout"),js_pre_processor:ys("codepenJsProcessor"),editors:ys("codepenEditors")});return xs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:ys("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var u=e.firstChild.cloneNode(!0);u.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(u)}if(c.css&&function(n){if(!vs[n]){var e=xs("style",{innerHTML:n});document.body.appendChild(e),vs[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),i);else if("vue"===s){var h=(new(Vue.extend(c.script))).$mount();i.appendChild(h.$el)}else"vanilla"===s&&(i.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ts()}),300)}function As(n,e,t,r){var i="1"!==n.dataset.isExpand;t.style.height=i?"".concat(e,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=i?"1":"0"}var Is={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ts()},updated:function(){Ts()}},js=(t(224),"auto"),Ss="zoom-in",zs="zoom-out",Cs="grab",$s="move";function Os(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?n.addEventListener(e,t,i):n.removeEventListener(e,t,i)}function Ps(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Ds(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ms(n,e,t){!function(n){var e=Rs,t=Gs;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var i=n.transform;delete n.transform,n[t]=i}}(e);var r=n.style,i={};for(var a in e)t&&(i[a]=r[a]||""),r[a]=e[a];return i}var Rs="transition",Gs="transform",Bs="transform",Ls="transitionend";var qs=function(){},Hs={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:qs,onClose:qs,onGrab:qs,onMove:qs,onRelease:qs,onBeforeOpen:qs,onBeforeClose:qs,onBeforeGrab:qs,onBeforeRelease:qs,onImageLoading:qs,onImageLoaded:qs},Ns={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Us(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,i=this.lastScrollPosition.y-t,a=this.options.scrollThreshold;(Math.abs(i)>=a||Math.abs(r)>=a)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Fs(n)&&!Us(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Fs(n)&&!Us(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Fs(n){return 0===n.button}function Us(n){return n.metaKey||n.ctrlKey}var Vs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ms(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Os(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ms(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Js="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Ws=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Qs=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Ks={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Ds(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,i=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Cs:zs,transition:Bs+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ms(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ms(this.el,{transform:"none"})},grab:function(n,e,t){var r=Ys(),i=r.x-n,a=r.y-e;Ms(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=Ys(),i=r.x-n,a=r.y-e;Ms(this.el,{transition:Bs,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+a)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ms(this.el,this.styleClose)},restoreOpenStyle:function(){Ms(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Ys(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,i=r.customSize,a=r.scaleBase;if(!i&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(i&&"object"===(void 0===i?"undefined":Js(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=Ys(),c={x:l.x-o,y:l.y-s},d=c.x/o,u=c.y/s,h=a+Math.min(d,u);if(i&&"string"==typeof i){var p=t||this.el.naturalWidth,m=e||this.el.naturalHeight,g=parseFloat(i)*p/(100*this.rect.width),f=parseFloat(i)*m/(100*this.rect.height);if(h>g||h>f)return{x:g,y:f}}return{x:h,y:h}}};function Ys(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Xs(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Os(n,r,e[r],t)}))}var Zs=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Ks),this.overlay=Object.create(Vs),this.handler=Object.create(Ns),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Qs({},Hs,e),this.overlay.init(this),this.handler.init(this)}return Ws(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Ss,Os(n,"click",this.handler.click),this.options.preloadImage&&Ps(Ds(n)));return this}},{key:"config",value:function(n){return n?(Qs(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),Ps(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Os(document,"scroll",this.handler.scroll),Os(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Os(window,"resize",this.handler.resizeWindow);var a=function n(){Os(r,Ls,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Xs(document,e.handler,!0),t(r)};return Os(r,Ls,a),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=js,this.overlay.fadeOut(),this.target.zoomOut(),Os(document,"scroll",this.handler.scroll,!1),Os(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Os(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Os(t,Ls,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Xs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Os(t,Ls,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(n,e,t);var a=function n(){Os(i,Ls,n,!1),r(i)};return Os(i,Ls,a),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var i=this.target.el,a=function n(){Os(i,Ls,n,!1),r(i)};return Os(i,Ls,a),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=js,this.target.restoreOpenStyle();var r=function r(){Os(t,Ls,r,!1),n.lock=!1,n.released=!0,e(t)};return Os(t,Ls,r),this}}}]),n}(),nl=".theme-vdoing-content img:not(.no-zoom)",el=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),tl=Number("500"),rl=function(){function n(){us(this,n),this.instance=new Zs(el)}return ps(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:nl;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:nl,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:tl;setTimeout((function(){return n.update(e)}),t)}}]),n}(),il=[es,ss,ds,gs,Is,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new rl,this.$vuepress.zooming.updateDelay()}}],al={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Wo("layout",n),Pi.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},ol=t(20),sl=Object(ol.a)(al,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(jo.a)(t));break;default:throw new Error("Unknown option name.")}}(sl,"mixins",il);var ll=[{name:"v-6768a9e7",path:"/web/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-6768a9e7").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/01.前端.html",redirect:"/web/"},{name:"v-3a59c096",path:"/ui/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-3a59c096").then(t)}},{path:"/ui/index.html",redirect:"/ui/"},{path:"/00.目录页/02.页面.html",redirect:"/ui/"},{name:"v-635bdaa6",path:"/technology/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-635bdaa6").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-a74a57ce",path:"/more/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-a74a57ce").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/04.更多.html",redirect:"/more/"},{name:"v-d52fa6b8",path:"/index/知识整理/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-d52fa6b8").then(t)}},{path:"/index/知识整理/index.html",redirect:"/index/知识整理/"},{path:"/01.后端/00.知识整理.html",redirect:"/index/知识整理/"},{name:"v-0096a856",path:"/note/学习笔记/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-0096a856").then(t)}},{path:"/note/学习笔记/index.html",redirect:"/note/学习笔记/"},{path:"/01.后端/01.学习笔记.html",redirect:"/note/学习笔记/"},{name:"v-01ba14e3",path:"/pages/035670/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-01ba14e3").then(t)}},{path:"/pages/035670/index.html",redirect:"/pages/035670/"},{path:"/02.运维/01.容器技术/01.Jenkins教程.html",redirect:"/pages/035670/"},{name:"v-784ff23a",path:"/pages/9a7ee40fc232253e/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-784ff23a").then(t)}},{path:"/pages/9a7ee40fc232253e/index.html",redirect:"/pages/9a7ee40fc232253e/"},{path:"/03.技术/01.技术文档/01.Git使用手册.html",redirect:"/pages/9a7ee40fc232253e/"},{name:"v-2deaaf56",path:"/pages/ad247c4332211551/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-2deaaf56").then(t)}},{path:"/pages/ad247c4332211551/index.html",redirect:"/pages/ad247c4332211551/"},{path:"/03.技术/01.技术文档/02.Markdown使用教程.html",redirect:"/pages/ad247c4332211551/"},{name:"v-2d73f679",path:"/pages/4e8444e2d534d14f/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-2d73f679").then(t)}},{path:"/pages/4e8444e2d534d14f/index.html",redirect:"/pages/4e8444e2d534d14f/"},{path:"/03.技术/01.技术文档/15.yaml语言教程.html",redirect:"/pages/4e8444e2d534d14f/"},{name:"v-d9a518f6",path:"/pages/4c778760be26d8b3/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-d9a518f6").then(t)}},{path:"/pages/4c778760be26d8b3/index.html",redirect:"/pages/4c778760be26d8b3/"},{path:"/03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.html",redirect:"/pages/4c778760be26d8b3/"},{name:"v-5736fc35",path:"/pages/6b9d359ec5aa5019/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-5736fc35").then(t)}},{path:"/pages/6b9d359ec5aa5019/index.html",redirect:"/pages/6b9d359ec5aa5019/"},{path:"/03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.html",redirect:"/pages/6b9d359ec5aa5019/"},{name:"v-fa1b9a8a",path:"/pages/f44d2f9ad04ab8d3/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-fa1b9a8a").then(t)}},{path:"/pages/f44d2f9ad04ab8d3/index.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{path:"/03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{name:"v-62d2e41f",path:"/pages/95331c6a9613faf8/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-62d2e41f").then(t)}},{path:"/pages/95331c6a9613faf8/index.html",redirect:"/pages/95331c6a9613faf8/"},{path:"/03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.html",redirect:"/pages/95331c6a9613faf8/"},{name:"v-346aebdf",path:"/friends/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-346aebdf").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/04.更多/99.友情链接.html",redirect:"/friends/"},{name:"v-7d6f7b6e",path:"/about/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-7d6f7b6e").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-00d5e539",path:"/pages/beb6c0bd8a66cea6/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-00d5e539").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/06.收藏夹/01.技术网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-53104ef6",path:"/archives/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-53104ef6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-1a9d53e5",path:"/categories/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-1a9d53e5").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-150b83f6",path:"/tags/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-150b83f6").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-a113e2c4",path:"/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-a113e2c4").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-d2440a98",path:"/pages/90c423/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-d2440a98").then(t)}},{path:"/pages/90c423/index.html",redirect:"/pages/90c423/"},{path:"/学习笔记/00.类加载器&JVM/00.JVM知识图谱.html",redirect:"/pages/90c423/"},{name:"v-680748c4",path:"/pages/8292d8/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-680748c4").then(t)}},{path:"/pages/8292d8/index.html",redirect:"/pages/8292d8/"},{path:"/学习笔记/70.《Git》学习笔记/10.手册/00.常用Git命令清单.html",redirect:"/pages/8292d8/"},{name:"v-416d1532",path:"/pages/c10281/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-416d1532").then(t)}},{path:"/pages/c10281/index.html",redirect:"/pages/c10281/"},{path:"/学习笔记/70.《Git》学习笔记/10.手册/03.Git变基合并.html",redirect:"/pages/c10281/"},{name:"v-ca22736a",path:"/pages/4cbc21/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-ca22736a").then(t)}},{path:"/pages/4cbc21/index.html",redirect:"/pages/4cbc21/"},{path:"/学习笔记/70.《Git》学习笔记/10.手册/06.Git命令思维导图.html",redirect:"/pages/4cbc21/"},{name:"v-7d1c2eeb",path:"/pages/635088/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-7d1c2eeb").then(t)}},{path:"/pages/635088/index.html",redirect:"/pages/635088/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/10.Git基础与命令.html",redirect:"/pages/635088/"},{name:"v-60e51ea4",path:"/pages/1832fe/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-60e51ea4").then(t)}},{path:"/pages/1832fe/index.html",redirect:"/pages/1832fe/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.html",redirect:"/pages/1832fe/"},{name:"v-9cbdbc54",path:"/pages/d9e9c6/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-9cbdbc54").then(t)}},{path:"/pages/d9e9c6/index.html",redirect:"/pages/d9e9c6/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.html",redirect:"/pages/d9e9c6/"},{name:"v-c24e73d6",path:"/pages/4bef1a/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-c24e73d6").then(t)}},{path:"/pages/4bef1a/index.html",redirect:"/pages/4bef1a/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.html",redirect:"/pages/4bef1a/"},{name:"v-6d2e70eb",path:"/pages/ea5a8c/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-6d2e70eb").then(t)}},{path:"/pages/ea5a8c/index.html",redirect:"/pages/ea5a8c/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.html",redirect:"/pages/ea5a8c/"},{name:"v-2fe3fa79",path:"/pages/a399b3/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-2fe3fa79").then(t)}},{path:"/pages/a399b3/index.html",redirect:"/pages/a399b3/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.html",redirect:"/pages/a399b3/"},{name:"v-0b8036da",path:"/pages/49ee30/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-0b8036da").then(t)}},{path:"/pages/49ee30/index.html",redirect:"/pages/49ee30/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.html",redirect:"/pages/49ee30/"},{name:"v-5f03001a",path:"/pages/574d62/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-5f03001a").then(t)}},{path:"/pages/574d62/index.html",redirect:"/pages/574d62/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.html",redirect:"/pages/574d62/"},{name:"v-064a931c",path:"/pages/3a3247/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-064a931c").then(t)}},{path:"/pages/3a3247/index.html",redirect:"/pages/3a3247/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/70.Git分支-变基.html",redirect:"/pages/3a3247/"},{name:"v-0436f619",path:"/pages/c984d1/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-0436f619").then(t)}},{path:"/pages/c984d1/index.html",redirect:"/pages/c984d1/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.html",redirect:"/pages/c984d1/"},{name:"v-2b3c7b2a",path:"/pages/76d859/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-2b3c7b2a").then(t)}},{path:"/pages/76d859/index.html",redirect:"/pages/76d859/"},{path:"/学习笔记/70.《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.html",redirect:"/pages/76d859/"},{name:"v-48ab307b",path:"/pages/5aa878/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-48ab307b").then(t)}},{path:"/pages/5aa878/index.html",redirect:"/pages/5aa878/"},{path:"/知识整理/01.java基础.html",redirect:"/pages/5aa878/"},{name:"v-a63cde52",path:"/pages/98788c/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-a63cde52").then(t)}},{path:"/pages/98788c/index.html",redirect:"/pages/98788c/"},{path:"/知识整理/02.jvm.html",redirect:"/pages/98788c/"},{name:"v-49b9f1b0",path:"/pages/f8ee2e/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-49b9f1b0").then(t)}},{path:"/pages/f8ee2e/index.html",redirect:"/pages/f8ee2e/"},{path:"/知识整理/03.设计模式.html",redirect:"/pages/f8ee2e/"},{name:"v-0a21df14",path:"/pages/86f5d7/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-0a21df14").then(t)}},{path:"/pages/86f5d7/index.html",redirect:"/pages/86f5d7/"},{path:"/知识整理/04.排序算法.html",redirect:"/pages/86f5d7/"},{name:"v-5fea683d",path:"/pages/427643/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-5fea683d").then(t)}},{path:"/pages/427643/index.html",redirect:"/pages/427643/"},{path:"/知识整理/05.系统架构设计.html",redirect:"/pages/427643/"},{name:"v-512420e6",path:"/pages/4a8a37/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-512420e6").then(t)}},{path:"/pages/4a8a37/index.html",redirect:"/pages/4a8a37/"},{path:"/知识整理/06.机器配置.html",redirect:"/pages/4a8a37/"},{name:"v-4c85098c",path:"/pages/67b177/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-4c85098c").then(t)}},{path:"/pages/67b177/index.html",redirect:"/pages/67b177/"},{path:"/知识整理/07.定时任务.html",redirect:"/pages/67b177/"},{name:"v-385c1de4",path:"/pages/c0fe60/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-385c1de4").then(t)}},{path:"/pages/c0fe60/index.html",redirect:"/pages/c0fe60/"},{path:"/知识整理/08.分布式.html",redirect:"/pages/c0fe60/"},{name:"v-00de7c67",path:"/pages/d130fe/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-00de7c67").then(t)}},{path:"/pages/d130fe/index.html",redirect:"/pages/d130fe/"},{path:"/知识整理/09.关系型数据库.html",redirect:"/pages/d130fe/"},{name:"v-32b6909a",path:"/pages/451590/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-32b6909a").then(t)}},{path:"/pages/451590/index.html",redirect:"/pages/451590/"},{path:"/知识整理/10.网络.html",redirect:"/pages/451590/"},{name:"v-e097ec3a",path:"/pages/e1ba65/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-e097ec3a").then(t)}},{path:"/pages/e1ba65/index.html",redirect:"/pages/e1ba65/"},{path:"/知识整理/11.消息中间件.html",redirect:"/pages/e1ba65/"},{name:"v-dcf1b992",path:"/pages/649d86/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-dcf1b992").then(t)}},{path:"/pages/649d86/index.html",redirect:"/pages/649d86/"},{path:"/知识整理/12.Elasticsearch.html",redirect:"/pages/649d86/"},{name:"v-64a87d57",path:"/pages/26e33d/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-64a87d57").then(t)}},{path:"/pages/26e33d/index.html",redirect:"/pages/26e33d/"},{path:"/知识整理/13.redis.html",redirect:"/pages/26e33d/"},{name:"v-33098487",path:"/pages/172a2f/",component:sl,beforeEnter:function(n,e,t){Jo("Layout","v-33098487").then(t)}},{path:"/pages/172a2f/index.html",redirect:"/pages/172a2f/"},{path:"/知识整理/14.spring.html",redirect:"/pages/172a2f/"},{path:"*",component:sl}],cl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/tx.png"}],["meta",{name:"keywords",content:"后端博客,个人技术博客,后端面试题,技术文档,学习,面试,Java,mysql,ES,Oracle,K8S,jenkins,docker,jvm,spring cloud,git,github,markdown"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"后端",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.后端",description:"后端技术"}},title:"后端",date:"2020-03-11T21:50:53.000Z",permalink:"/web/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-6768a9e7",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"运维",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.运维",imgUrl:"/img/ui.png",description:"运维相关技术"}},title:"运维",date:"2020-03-11T21:50:54.000Z",permalink:"/ui/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html",relativePath:"00.目录页/02.页面.md",key:"v-3a59c096",path:"/ui/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术",imgUrl:"/img/other.png",description:"技术文档、教程、技巧、总结等文章"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-635bdaa6",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/04.更多.md",key:"v-a74a57ce",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"知识整理",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"知识整理",imgUrl:"https://avatars3.githubusercontent.com/u/18133?s=200&v=4",description:"面试知识要点整理"}},title:"知识整理",date:"2020-11-18T17:40:48.000Z",permalink:"/index/知识整理/",article:!1,comment:!1,editLink:!1,author:{name:"kevin"}},regularPath:"/01.%E5%90%8E%E7%AB%AF/00.%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html",relativePath:"01.后端/00.知识整理.md",key:"v-d52fa6b8",path:"/index/知识整理/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"学习笔记",imgUrl:"https://avatars3.githubusercontent.com/u/18133?s=200&v=4",description:"<a href='https://git-scm.com/book/zh/v2' target='_blank'>Git官网文档</a>的学习笔记，以官方文档为准。"}},title:"学习笔记",date:"2020-11-18T17:40:48.000Z",permalink:"/note/学习笔记/",article:!1,comment:!1,editLink:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"01.后端/01.学习笔记.md",key:"v-0096a856",path:"/note/学习笔记/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Jenkins教程",frontmatter:{title:"Jenkins教程",date:"2022-04-26T17:07:36.000Z",permalink:"/pages/035670/",categories:["jenkins教程"],tags:[null],author:{name:"kevin"},sticky:1},regularPath:"/02.%E8%BF%90%E7%BB%B4/01.%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF/01.Jenkins%E6%95%99%E7%A8%8B.html",relativePath:"02.运维/01.容器技术/01.Jenkins教程.md",key:"v-01ba14e3",path:"/pages/035670/",headers:[{level:2,title:"jenkins搭建",slug:"jenkins搭建",normalizedTitle:"jenkins搭建",charIndex:2},{level:4,title:"1.环境信息",slug:"_1-环境信息",normalizedTitle:"1.环境信息",charIndex:15},{level:4,title:"2.maven配置仓库",slug:"_2-maven配置仓库",normalizedTitle:"2.maven配置仓库",charIndex:70},{level:4,title:"3.docker方式安装jekins",slug:"_3-docker方式安装jekins",normalizedTitle:"3.docker方式安装jekins",charIndex:326},{level:4,title:"4.安装插件",slug:"_4-安装插件",normalizedTitle:"4.安装插件",charIndex:967},{level:4,title:"5.配置jenkins",slug:"_5-配置jenkins",normalizedTitle:"5.配置jenkins",charIndex:1227},{level:4,title:"6.系统配置",slug:"_6-系统配置",normalizedTitle:"6.系统配置",charIndex:1591},{level:4,title:"7.构建java项目",slug:"_7-构建java项目",normalizedTitle:"7.构建java项目",charIndex:1742},{level:4,title:"8.构建VUE项目",slug:"_8-构建vue项目",normalizedTitle:"8.构建vue项目",charIndex:3822},{level:4,title:"9.问题",slug:"_9-问题",normalizedTitle:"9.问题",charIndex:5369}],headersStr:"jenkins搭建 1.环境信息 2.maven配置仓库 3.docker方式安装jekins 4.安装插件 5.配置jenkins 6.系统配置 7.构建java项目 8.构建VUE项目 9.问题",content:'# jenkins搭建\n\n# 1.环境信息\n\nJDK1.8\nmaven 3.5.4\njenkins laster \n\n\n1\n2\n3\n\n\n# 2.maven配置仓库\n\n<mirrors>\n    <mirror>\n        <id>nexus-aliyun</id>\n        <mirrorOf>central</mirrorOf>\n        <name>Nexus aliyun</name>\n        <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n    </mirror>\t\n</mirrors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.docker方式安装jekins\n\n3.1 docker拉取jekins\n\ndocker pull jenkins/jenkins:lts\n\n\n1\n\n\n3.2 创建挂载目录 并开放读写权限\n\nmkdir -p /opt/work/jenkins\nchmod 777 /opt/work/jenkins\nchown -R 1000 /opt/work/jenkins\n\n\n1\n2\n3\n\n\n3.3 启动\n\ndocker run -d --name jenkins -p 9000:8080 -p 50000:50000  --restart=always -v /opt/work/jenkins:/var/jenkins_home -v /etc/localtime:/etc/localtime -v /opt/work/apache-maven-3.5.4:/usr/local/maven jenkins/jenkins:lts\n\n\n1\n\n\n3.4进入控制台\n\nhttp://ip:9000\n等待界面初始化进入解锁界面\n\n\n1\n2\n\n\n\n\n3.5查看初始化密码\n\ndocker exec -it jenkins bash\ncat /var/jenkins_home/secrets/initialAdminPassword\n\n\n1\n2\n\n\n3.6选择安装插件的方式\n\n如果知道要安装哪些插件，就选择安装推荐的插件。\n\n\n\n3.7等待安装完成，后续步骤按照界面提示即可\n\n# 4.安装插件\n\n\n\n主要安装以下几个插件，在右上角进行搜索\nPublish Over SSH -- 服务器操作插件 配置服务器信息 -- 暂未用到该方式\nSSH2 Easy     -----  服务器操作插件 配置服务器信息\nMaven Integration ----- maven插件 发布JAR包用\nGit Parameter ----- git插件\t拉取代码用\nNodeJS Plugin ----- nodejs插件 发布VUE用\n安装完后重启勾选右下角重启服务\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 5.配置jenkins\n\n进入配置界面\n\n\n\n5.1全局环境配置\n\n进入容器\ndocker exec -it jenkins bash\n查看java home\necho $JAVA_HOME 获取java路径\n界面点击新增jdk 取消自动安装\n/opt/java/openjdk\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n5.2配置maven\n\n取消自动安装\n在第3.3步骤中启动时配置了maven路径usr/local/maven 复制路径填入下面框格\n\n\n1\n2\n\n\n\n\n5.3配置nodejs\n\n这个需要特别注意，需要根据目前开发的VUE版本安装对应的支持版本，否则可能导致构建失败。我第一次安装了nodejs14的版本就由于版本过高导致构建失败，后来重新安装了nodejs 12.16.2才正常构建成功。\n\n\n1\n\n\n\n\n# 6.系统配置\n\n点击系统设置-系统设置\n\n6.1 Server Groups Center 配置服务器信息\n\n\n\n配置完成之后,需要先保存退出配置界面，再进入才可以配置Server List，否则可能找不到Server Group\n\n\n1\n\n\n6.2 配置Server Group List\n\n\n\n# 7.构建java项目\n\n点击左侧菜单新建任务，然后选择构建一个MAVEN项目\n\n\n1\n\n\n\n\n7.1构建策略\n\n构建的版本保留几个作为回滚就够了，不需要一直保留着，以免占用服务器硬盘资源。\n点击General勾选丢弃旧的构建，根据实际使用情况备份以下2个信息\n\t保持构建的天数\n\t保持构建的最大个数\n还可以勾选参数化构建过程，对一些信息参数化。（这一步我暂时未做）\n\n\n1\n2\n3\n4\n5\n\n\n\n\n7.2 git配置\n\n点击源码管理配置git信息，输入URL 添加认证 选择要构建的分支\n如果做了参数化构建，这里就可以配置参数。\n\n\n1\n2\n\n\n\n\n7.3 取消构建触发器\n\n在构建触发器 取消勾选 “Build whenever a SNAPSHOT dependency is built”\n\n\n1\n\n\n7.4 配置maven构建命令\n\n如果是单模块项目，则使用以下命令即可\nclean install xxx -Dmaven.test.skip=true\n如果是多模块项目，则需要确认构建的执行项目\nclean install -pl xxx -am -amd -Dmaven.test.skip=true\n-pl 标识指定构建某个模块\n-am 是向下的。表示同时处理选定模块所依赖的模块。\n-amd 是向上的。表示同时处理依赖选定模块的模块。\n使用-am、-amd等时候，必须配合-pl指定模块使用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n7.5 配置FTP上传\n\n我没有使用SSH上传方式（懒的弄证书😂）\n配置FTP方式上传包\nRun only if build succeed 标识构建成功后才执行\ntarget server对应的是jenkins容器里面的绝对路径\n/var/jenkins_home/workspace/项目路径/target/jar包名.jar\nremoteLocation  表示要上传到远程服务器的哪个位置\nfileName 表示上传之后文件的名称\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n7.6 执行远程脚本或者命令发起部署\n\n\n\n# docker构建部署命令例子\nexport BUILD_ID=dontKillMe \ninnerport=8086 #docker容器内部端口\noutport=8081 #docker容器外部端口\ndockername=api #容器名称\nweb=api-0.0.1-SNAPSHOT #jar包名\nwebdir=/opt/work/api #docker构建路径\nbackup=/opt/work/backup #备份路径\nbulid=/opt/work/bulid #jenkins 上传的路径\ndate=$(date +%Y%m%d%H%M) #备份的文件后缀\necho "####### 备份jar包 ##########"\ncp $webdir/$web.jar $backup/$web-$date.jar #备份历史版本\nrm -rf $webdir/$web.jar #删除历史版本\nmv $bulid/$web.jar $webdir/$web.jar #拷贝最新版本到 构建路径\necho "####### 删除当前容器 ##########"\ndocker stop $dockername\nsleep 10\ndocker rm $dockername\nsleep 3\ndocker rmi $dockername\nsleep 3\necho "####### 制作最新的当前镜像 ##########"\ncd $webdir #进入构建路径\ndocker build -t $dockername .\necho "####### 启动当前最新的容器 ##########"\ndocker run -d --name $dockername -p $outport:$innerport $dockername\nsleep 5\npid=`ps aux|grep $dockername|grep -v grep |grep -v "/bin/sh"| awk \'{print $2}\'`\nif [ -z "${pid}" ]; then\necho "################################项目启动失败################################"\ncat dsadsadas #使jenkins发布失败，导致构建项目不稳定\nelse\necho "################################项目启动成功#########################################"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 8.构建VUE项目\n\n大部分的操作和构建Java项目一致，略微有点小区别。\n第一步选择构建一个自由风格的软件项目\n第一次构建要安装nodejs，时间会久点\n\n\n1\n2\n3\n\n\n\n\n1-3步与第7点一致\n\n\n1\n\n\n8.1 构建环境选择nodejs\n\n1.要选择安装nodejs插件，在第4点已安装\n2.点击构建环境，勾选Provide Node & npm bin/ folder to PATH\n\n\n1\n2\n\n\n\n\n8.2新增执行shell命令\n\ncnpm install\ncnpm run build\ncd /var/jenkins_home/workspace/xxx\ntar -cvf dist.tar dist/\n\n\n1\n2\n3\n4\n\n\n\n\n8.3 FTP上传\n\n\n\n 8. 4 执行远程shell命令\n    \n    \n\nexport BUILD_ID=dontKillMe\ninnerport=8080\noutport=8080\ndockername=vue\nweb=dist\nwebdir=/opt/work/vue\nbackup=/opt/work/backup\nbulid=/opt/work/bulid\ndate=$(date +%Y%m%d%H%M)\necho "####### 备份jar包 ##########"\ncd $webdir\ntar -cvf $web.tar  $web\ncp $webdir/$web.tar $backup/$web-$date.tar\nrm -rf $webdir/$web.tar\nmv $bulid/$web.tar $webdir/$web.tar\ntar -xvf $web.tar\nrm -rf $web.tar\necho "####### 删除当前容器 ##########"\ndocker stop $dockername\nsleep 10\ndocker rm $dockername\nsleep 3\ndocker rmi $dockername\nsleep 3\necho "####### 制作最新的当前镜像 ##########"\ndocker build -t $dockername .\necho "####### 启动当前最新的容器 ##########"\ndocker run -d --name $dockername -p $outport:$innerport $dockername\nsleep 5\npid=`ps aux|grep $dockername|grep -v grep |grep -v "/bin/sh"| awk \'{print $2}\'`\nif [ -z "${pid}" ]; then\necho "################################项目启动失败################################"\ncat dsadsadas #使jenkins发布失败，导致构建项目不稳定\nelse\necho "################################项目启动成功#########################################"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n8.5 上传成功之后，删除包\n\ncd /var/jenkins_home/workspace/xxx\nrm -rf dist.tar\n\n\n1\n2\n\n\n\n\n# 9.问题\n\n目前碰到的大部分问题都是权限不足的问题\n\n仓库的权限不足\n\nchmod 777 -R /jenkins主目录/.m2/repository\n\n\n1\n\n\nbulid 目录权限不足\n\nchmod 777 -R xxx\n\n\n1\n\n\n脚本执行异常 sh脚本要通过touch创建，如果从window放上去有字符的问题',normalizedContent:'# jenkins搭建\n\n# 1.环境信息\n\njdk1.8\nmaven 3.5.4\njenkins laster \n\n\n1\n2\n3\n\n\n# 2.maven配置仓库\n\n<mirrors>\n    <mirror>\n        <id>nexus-aliyun</id>\n        <mirrorof>central</mirrorof>\n        <name>nexus aliyun</name>\n        <url>http://maven.aliyun.com/nexus/content/groups/public</url>\n    </mirror>\t\n</mirrors>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 3.docker方式安装jekins\n\n3.1 docker拉取jekins\n\ndocker pull jenkins/jenkins:lts\n\n\n1\n\n\n3.2 创建挂载目录 并开放读写权限\n\nmkdir -p /opt/work/jenkins\nchmod 777 /opt/work/jenkins\nchown -r 1000 /opt/work/jenkins\n\n\n1\n2\n3\n\n\n3.3 启动\n\ndocker run -d --name jenkins -p 9000:8080 -p 50000:50000  --restart=always -v /opt/work/jenkins:/var/jenkins_home -v /etc/localtime:/etc/localtime -v /opt/work/apache-maven-3.5.4:/usr/local/maven jenkins/jenkins:lts\n\n\n1\n\n\n3.4进入控制台\n\nhttp://ip:9000\n等待界面初始化进入解锁界面\n\n\n1\n2\n\n\n\n\n3.5查看初始化密码\n\ndocker exec -it jenkins bash\ncat /var/jenkins_home/secrets/initialadminpassword\n\n\n1\n2\n\n\n3.6选择安装插件的方式\n\n如果知道要安装哪些插件，就选择安装推荐的插件。\n\n\n\n3.7等待安装完成，后续步骤按照界面提示即可\n\n# 4.安装插件\n\n\n\n主要安装以下几个插件，在右上角进行搜索\npublish over ssh -- 服务器操作插件 配置服务器信息 -- 暂未用到该方式\nssh2 easy     -----  服务器操作插件 配置服务器信息\nmaven integration ----- maven插件 发布jar包用\ngit parameter ----- git插件\t拉取代码用\nnodejs plugin ----- nodejs插件 发布vue用\n安装完后重启勾选右下角重启服务\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n# 5.配置jenkins\n\n进入配置界面\n\n\n\n5.1全局环境配置\n\n进入容器\ndocker exec -it jenkins bash\n查看java home\necho $java_home 获取java路径\n界面点击新增jdk 取消自动安装\n/opt/java/openjdk\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n\n5.2配置maven\n\n取消自动安装\n在第3.3步骤中启动时配置了maven路径usr/local/maven 复制路径填入下面框格\n\n\n1\n2\n\n\n\n\n5.3配置nodejs\n\n这个需要特别注意，需要根据目前开发的vue版本安装对应的支持版本，否则可能导致构建失败。我第一次安装了nodejs14的版本就由于版本过高导致构建失败，后来重新安装了nodejs 12.16.2才正常构建成功。\n\n\n1\n\n\n\n\n# 6.系统配置\n\n点击系统设置-系统设置\n\n6.1 server groups center 配置服务器信息\n\n\n\n配置完成之后,需要先保存退出配置界面，再进入才可以配置server list，否则可能找不到server group\n\n\n1\n\n\n6.2 配置server group list\n\n\n\n# 7.构建java项目\n\n点击左侧菜单新建任务，然后选择构建一个maven项目\n\n\n1\n\n\n\n\n7.1构建策略\n\n构建的版本保留几个作为回滚就够了，不需要一直保留着，以免占用服务器硬盘资源。\n点击general勾选丢弃旧的构建，根据实际使用情况备份以下2个信息\n\t保持构建的天数\n\t保持构建的最大个数\n还可以勾选参数化构建过程，对一些信息参数化。（这一步我暂时未做）\n\n\n1\n2\n3\n4\n5\n\n\n\n\n7.2 git配置\n\n点击源码管理配置git信息，输入url 添加认证 选择要构建的分支\n如果做了参数化构建，这里就可以配置参数。\n\n\n1\n2\n\n\n\n\n7.3 取消构建触发器\n\n在构建触发器 取消勾选 “build whenever a snapshot dependency is built”\n\n\n1\n\n\n7.4 配置maven构建命令\n\n如果是单模块项目，则使用以下命令即可\nclean install xxx -dmaven.test.skip=true\n如果是多模块项目，则需要确认构建的执行项目\nclean install -pl xxx -am -amd -dmaven.test.skip=true\n-pl 标识指定构建某个模块\n-am 是向下的。表示同时处理选定模块所依赖的模块。\n-amd 是向上的。表示同时处理依赖选定模块的模块。\n使用-am、-amd等时候，必须配合-pl指定模块使用\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n7.5 配置ftp上传\n\n我没有使用ssh上传方式（懒的弄证书😂）\n配置ftp方式上传包\nrun only if build succeed 标识构建成功后才执行\ntarget server对应的是jenkins容器里面的绝对路径\n/var/jenkins_home/workspace/项目路径/target/jar包名.jar\nremotelocation  表示要上传到远程服务器的哪个位置\nfilename 表示上传之后文件的名称\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n\n7.6 执行远程脚本或者命令发起部署\n\n\n\n# docker构建部署命令例子\nexport build_id=dontkillme \ninnerport=8086 #docker容器内部端口\noutport=8081 #docker容器外部端口\ndockername=api #容器名称\nweb=api-0.0.1-snapshot #jar包名\nwebdir=/opt/work/api #docker构建路径\nbackup=/opt/work/backup #备份路径\nbulid=/opt/work/bulid #jenkins 上传的路径\ndate=$(date +%y%m%d%h%m) #备份的文件后缀\necho "####### 备份jar包 ##########"\ncp $webdir/$web.jar $backup/$web-$date.jar #备份历史版本\nrm -rf $webdir/$web.jar #删除历史版本\nmv $bulid/$web.jar $webdir/$web.jar #拷贝最新版本到 构建路径\necho "####### 删除当前容器 ##########"\ndocker stop $dockername\nsleep 10\ndocker rm $dockername\nsleep 3\ndocker rmi $dockername\nsleep 3\necho "####### 制作最新的当前镜像 ##########"\ncd $webdir #进入构建路径\ndocker build -t $dockername .\necho "####### 启动当前最新的容器 ##########"\ndocker run -d --name $dockername -p $outport:$innerport $dockername\nsleep 5\npid=`ps aux|grep $dockername|grep -v grep |grep -v "/bin/sh"| awk \'{print $2}\'`\nif [ -z "${pid}" ]; then\necho "################################项目启动失败################################"\ncat dsadsadas #使jenkins发布失败，导致构建项目不稳定\nelse\necho "################################项目启动成功#########################################"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 8.构建vue项目\n\n大部分的操作和构建java项目一致，略微有点小区别。\n第一步选择构建一个自由风格的软件项目\n第一次构建要安装nodejs，时间会久点\n\n\n1\n2\n3\n\n\n\n\n1-3步与第7点一致\n\n\n1\n\n\n8.1 构建环境选择nodejs\n\n1.要选择安装nodejs插件，在第4点已安装\n2.点击构建环境，勾选provide node & npm bin/ folder to path\n\n\n1\n2\n\n\n\n\n8.2新增执行shell命令\n\ncnpm install\ncnpm run build\ncd /var/jenkins_home/workspace/xxx\ntar -cvf dist.tar dist/\n\n\n1\n2\n3\n4\n\n\n\n\n8.3 ftp上传\n\n\n\n 8. 4 执行远程shell命令\n    \n    \n\nexport build_id=dontkillme\ninnerport=8080\noutport=8080\ndockername=vue\nweb=dist\nwebdir=/opt/work/vue\nbackup=/opt/work/backup\nbulid=/opt/work/bulid\ndate=$(date +%y%m%d%h%m)\necho "####### 备份jar包 ##########"\ncd $webdir\ntar -cvf $web.tar  $web\ncp $webdir/$web.tar $backup/$web-$date.tar\nrm -rf $webdir/$web.tar\nmv $bulid/$web.tar $webdir/$web.tar\ntar -xvf $web.tar\nrm -rf $web.tar\necho "####### 删除当前容器 ##########"\ndocker stop $dockername\nsleep 10\ndocker rm $dockername\nsleep 3\ndocker rmi $dockername\nsleep 3\necho "####### 制作最新的当前镜像 ##########"\ndocker build -t $dockername .\necho "####### 启动当前最新的容器 ##########"\ndocker run -d --name $dockername -p $outport:$innerport $dockername\nsleep 5\npid=`ps aux|grep $dockername|grep -v grep |grep -v "/bin/sh"| awk \'{print $2}\'`\nif [ -z "${pid}" ]; then\necho "################################项目启动失败################################"\ncat dsadsadas #使jenkins发布失败，导致构建项目不稳定\nelse\necho "################################项目启动成功#########################################"\nfi\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n8.5 上传成功之后，删除包\n\ncd /var/jenkins_home/workspace/xxx\nrm -rf dist.tar\n\n\n1\n2\n\n\n\n\n# 9.问题\n\n目前碰到的大部分问题都是权限不足的问题\n\n仓库的权限不足\n\nchmod 777 -r /jenkins主目录/.m2/repository\n\n\n1\n\n\nbulid 目录权限不足\n\nchmod 777 -r xxx\n\n\n1\n\n\n脚本执行异常 sh脚本要通过touch创建，如果从window放上去有字符的问题',charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git使用手册",frontmatter:{title:"Git使用手册",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/9a7ee40fc232253e",categories:["技术","技术文档"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/01.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"03.技术/01.技术文档/01.Git使用手册.md",key:"v-784ff23a",path:"/pages/9a7ee40fc232253e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:296},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:478},{level:4,title:"提交描述规范",slug:"提交描述规范",normalizedTitle:"提交描述规范",charIndex:795},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:819},{level:4,title:"提交修改",slug:"提交修改",normalizedTitle:"提交修改",charIndex:936},{level:4,title:"查看版本记录",slug:"查看版本记录",normalizedTitle:"查看版本记录",charIndex:1105},{level:4,title:"回退版本",slug:"回退版本",normalizedTitle:"回退版本",charIndex:1204},{level:4,title:"撤销修改",slug:"撤销修改",normalizedTitle:"撤销修改",charIndex:1565},{level:4,title:"删除文件",slug:"删除文件",normalizedTitle:"删除文件",charIndex:1639},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1714},{level:4,title:"SSH验证",slug:"ssh验证",normalizedTitle:"ssh验证",charIndex:1722},{level:4,title:"关联远程仓库",slug:"关联远程仓库",normalizedTitle:"关联远程仓库",charIndex:1733},{level:4,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:2772},{level:4,title:"删除远程仓库",slug:"删除远程仓库",normalizedTitle:"删除远程仓库",charIndex:2813},{level:4,title:"从远程库克隆项目",slug:"从远程库克隆项目",normalizedTitle:"从远程库克隆项目",charIndex:2860},{level:5,title:"克隆指定分支",slug:"克隆指定分支",normalizedTitle:"克隆指定分支",charIndex:2908},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2962},{level:4,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:2970},{level:4,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:3015},{level:4,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:3074},{level:4,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:3116},{level:4,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:3265},{level:4,title:"修改分支名",slug:"修改分支名",normalizedTitle:"修改分支名",charIndex:3308},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3362},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:7033}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 提交描述规范 版本管理 提交修改 查看版本记录 回退版本 撤销修改 删除文件 远程仓库 SSH验证 关联远程仓库 查看远程仓库 删除远程仓库 从远程库克隆项目 克隆指定分支 分支管理 创建分支 查看分支 切换分支 合并分支 删除分支 修改分支名 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:liuwenkai/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:liuwenkai/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Markdown使用教程",frontmatter:{title:"Markdown使用教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ad247c4332211551",categories:["技术","技术文档"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/02.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/02.Markdown使用教程.md",key:"v-2deaaf56",path:"/pages/ad247c4332211551/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:4,title:"什么是徽章",slug:"什么是徽章",normalizedTitle:"什么是徽章",charIndex:202},{level:4,title:"徽章的使用",slug:"徽章的使用",normalizedTitle:"徽章的使用",charIndex:318},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:585},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1203},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1221},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1233},{level:4,title:"四级标题",slug:"四级标题",normalizedTitle:"四级标题",charIndex:1247},{level:5,title:"五级标题",slug:"五级标题",normalizedTitle:"五级标题",charIndex:1263},{level:6,title:"六级标题",slug:"六级标题",normalizedTitle:"六级标题",charIndex:1281},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1291},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1303},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1313},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1323},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1334},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1345},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1357},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1368},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1376},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1388},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1400},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1412},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1424},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1438},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1448},{level:4,title:"区块嵌套",slug:"区块嵌套",normalizedTitle:"区块嵌套",charIndex:1462},{level:4,title:"区块中使用列表",slug:"区块中使用列表",normalizedTitle:"区块中使用列表",charIndex:1474},{level:4,title:"列表中使用区块",slug:"列表中使用区块",normalizedTitle:"列表中使用区块",charIndex:1489},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1502},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1514},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1524},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1536},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4929},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1569},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1579},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1591},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1603},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1626},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1637},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1654},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1669},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1688},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1698},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1710},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1720},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1731},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1742}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 什么是徽章 徽章的使用 三、设置目录 四、标题 二级标题 三级标题 四级标题 五级标题 六级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 区块嵌套 区块中使用列表 列表中使用区块 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-liuwenkai-brightgreen.svg)](https://github.com/liuwenkai01)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n\n\n1\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/liuwenkai01/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n1\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-liuwenkai-brightgreen.svg)](https://github.com/liuwenkai01)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n\n\n1\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/liuwenkai01/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/liuwenkai/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n1\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"yaml语言教程",frontmatter:{title:"yaml语言教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4e8444e2d534d14f",categories:["技术","技术文档"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/15.yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/15.yaml语言教程.md",key:"v-2d73f679",path:"/pages/4e8444e2d534d14f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:326},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:422},{level:2,title:"YAML 对象",slug:"yaml-对象",normalizedTitle:"yaml 对象",charIndex:576},{level:2,title:"YAML 数组",slug:"yaml-数组",normalizedTitle:"yaml 数组",charIndex:1086},{level:2,title:"复合结构（对象和数组组合）",slug:"复合结构-对象和数组组合",normalizedTitle:"复合结构（对象和数组组合）",charIndex:1594},{level:2,title:"纯量",slug:"纯量",normalizedTitle:"纯量",charIndex:549},{level:2,title:"转换数据格式",slug:"转换数据格式",normalizedTitle:"转换数据格式",charIndex:3050},{level:2,title:"锚点引用",slug:"锚点引用",normalizedTitle:"锚点引用",charIndex:3157}],excerpt:'<h1 id="yaml语言教程"><a class="header-anchor" href="#yaml语言教程">#</a> yaml语言教程</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>YAML 是 &quot;YAML Ain\'t a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\n',headersStr:"简介 基本语法 数据类型 YAML 对象 YAML 数组 复合结构（对象和数组组合） 纯量 转换数据格式 锚点引用",content:"# yaml语言教程\n\n\n# 简介\n\nYAML 是 \"YAML Ain't a Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\n\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nYAML 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# YAML 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# YAML 数组\n\n以 - 开头的行表示构成一个数组：\n\n- A\n- B\n- C\n\n\n1\n2\n3\n\n\nYAML 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - A\n - B\n - C\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - Ruby\n  - Perl\n  - Python \nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'Ruby', 'Perl', 'Python'],\n  websites: {\n    YAML: 'yaml.org',\n    Ruby: 'ruby-lang.org',\n    Python: 'python.org',\n    Perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * Null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - TRUE  #true,True都可以\n    - FALSE  #false，False都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # Null\n    nodeName: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd\ndatetime: \n    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  Foo\n  Bar\nthat: >\n  Foo\n  Bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  Foo\n \ns2: |+\n  Foo\n \n \ns3: |-\n  Foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' }\n\n\n1\n\n\n字符串之中可以插入 HTML 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell Steve \n- Clark \n- Brian \n- Oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",normalizedContent:"# yaml语言教程\n\n\n# 简介\n\nyaml 是 \"yaml ain't a markup language\"（yaml 不是一种标记语言）的递归缩写。在开发的这种语言时，yaml 的意思其实是：\"yet another markup language\"（仍是一种标记语言）。\n\nyaml 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和yaml非常接近）。\n\nyaml 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nyaml 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# yaml 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# yaml 数组\n\n以 - 开头的行表示构成一个数组：\n\n- a\n- b\n- c\n\n\n1\n2\n3\n\n\nyaml 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - a\n - b\n - c\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200w\n    -\n        id: 2\n        name: company2\n        price: 500w\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200w},{id: 2,name: company2,price: 500w}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - ruby\n  - perl\n  - python \nwebsites:\n  yaml: yaml.org \n  ruby: ruby-lang.org \n  python: python.org \n  perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'ruby', 'perl', 'python'],\n  websites: {\n    yaml: 'yaml.org',\n    ruby: 'ruby-lang.org',\n    python: 'python.org',\n    perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - true  #true,true都可以\n    - false  #false，false都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # null\n    nodename: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用iso 8601格式，即yyyy-mm-dd\ndatetime: \n    -  2018-02-17t15:02:31+08:00    #时间使用iso 8601格式，时间和日期之间使用t连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  foo\n  bar\nthat: >\n  foo\n  bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'foo\\nbar\\n', that: 'foo bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  foo\n \ns2: |+\n  foo\n \n \ns3: |-\n  foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'foo\\n', s2: 'foo\\n\\n\\n', s3: 'foo' }\n\n\n1\n\n\n字符串之中可以插入 html 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell steve \n- clark \n- brian \n- oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'steve', 'clark', 'brian', 'oren', 'steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"GitHub高级搜索技巧",frontmatter:{title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4c778760be26d8b3",categories:["技术","GitHub技巧"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.md",key:"v-d9a518f6",path:"/pages/4c778760be26d8b3/",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"GitHub Actions 实现自动部署静态博客",frontmatter:{title:"GitHub Actions 实现自动部署静态博客",date:"2019-12-27T11:44:41.000Z",permalink:"/pages/6b9d359ec5aa5019",categories:["技术","GitHub技巧"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/02.GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html",relativePath:"03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md",key:"v-5736fc35",path:"/pages/6b9d359ec5aa5019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:32},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:17},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3473}],excerpt:'<h1 id="github-actions-实现自动部署静态博客"><a class="header-anchor" href="#github-actions-实现自动部署静态博客">#</a> GitHub Actions 实现自动部署静态博客</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>我使用vuepress搭建了一个静态博客，挂在了Github pages和<a href="https://dev.tencent.com/" target="_blank" rel="noopener noreferrer">Coding pages<OutboundLink/></a>上面。</p>\n<p>coding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。</p>\n',headersStr:"前言 实现 相关文章",content:'# GitHub Actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到Github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解GitHub Actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。GitHub Actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的Settings/Secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是ACCESS_TOKEN和CODING_TOKEN。\n\n\n\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: CI\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: Checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # toKen私密变量\n          CODING_TOKEN: ${{ secrets.CODING_TOKEN }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> ACCESS_TOKE 和 CODING_TOKEN 都是保存在github仓库的Settings/Secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.liuwenkai.com\' > CNAME\nif [ -z "$GITHUB_TOKEN" ]; then\n  msg=\'deploy\'\n  githubUrl=git@github.com:liuwenkai/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githubUrl=https://liuwenkai:${GITHUB_TOKEN}@github.com/liuwenkai/blog.git\n  git config --global user.name "liuwenkai"\n  git config --global user.email "610725422@qq.com"\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.liuwenkai.com\\nliuwenkai.com\' > CNAME  # 自定义域名\nif [ -z "$CODING_TOKEN" ]; then  # -z 字符串 长度为0则为true；$CODING_TOKEN来自于github仓库`Settings/Secrets`设置的私密环境变量\n  codingUrl=git@git.dev.tencent.com:liuwenkai/liuwenkai.git\nelse\n  codingUrl=https://liuwenkai:${CODING_TOKEN}@git.dev.tencent.com/liuwenkai/liuwenkai.git\nfi\ngit add -A\ngit commit -m "${msg}"\ngit push -f $codingUrl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用Shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的CNAME文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是GitHub Actions自动触发的部署，此时使用的是可以通过toKen来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * Shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建CNAME文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由GitHub Actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的Actions这一项查看。\n\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》',normalizedContent:'# github actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了github pages和coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解github actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。github actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的settings/secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是access_token和coding_token。\n\n\n\ngithub actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 yaml 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。github 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: ci\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          github_token: ${{ secrets.access_token }} # token私密变量\n          coding_token: ${{ secrets.coding_token }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> access_toke 和 coding_token 都是保存在github仓库的settings/secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.liuwenkai.com\' > cname\nif [ -z "$github_token" ]; then\n  msg=\'deploy\'\n  githuburl=git@github.com:liuwenkai/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githuburl=https://liuwenkai:${github_token}@github.com/liuwenkai/blog.git\n  git config --global user.name "liuwenkai"\n  git config --global user.email "610725422@qq.com"\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.liuwenkai.com\\nliuwenkai.com\' > cname  # 自定义域名\nif [ -z "$coding_token" ]; then  # -z 字符串 长度为0则为true；$coding_token来自于github仓库`settings/secrets`设置的私密环境变量\n  codingurl=git@git.dev.tencent.com:liuwenkai/liuwenkai.git\nelse\n  codingurl=https://liuwenkai:${coding_token}@git.dev.tencent.com/liuwenkai/liuwenkai.git\nfi\ngit add -a\ngit commit -m "${msg}"\ngit push -f $codingurl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的cname文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是github actions自动触发的部署，此时使用的是可以通过token来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建cname文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由github actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的actions这一项查看。\n\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》',charsets:{cjk:!0},lastUpdated:"2022/04/29, 13:56:58",lastUpdatedTimestamp:1651211818e3},{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",frontmatter:{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",date:"2019-12-30T21:23:00.000Z",permalink:"/pages/f44d2f9ad04ab8d3",categories:["技术","GitHub技巧"],tags:["github","博客"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/03.GitHub%20Actions%20%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81.html",relativePath:"03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md",key:"v-fa1b9a8a",path:"/pages/f44d2f9ad04ab8d3/",headers:[{level:2,title:"百度主动链接推送",slug:"百度主动链接推送",normalizedTitle:"百度主动链接推送",charIndex:246},{level:2,title:"自动生成urls.txt",slug:"自动生成urls-txt",normalizedTitle:"自动生成urls.txt",charIndex:605},{level:2,title:"GitHub Actions 定时运行代码",slug:"github-actions-定时运行代码",normalizedTitle:"github actions 定时运行代码",charIndex:2},{level:3,title:"配置 GitHub Actions",slug:"配置-github-actions",normalizedTitle:"配置 github actions",charIndex:2077},{level:3,title:"baiduPush命令在package.json配置",slug:"baidupush命令在package-json配置",normalizedTitle:"baidupush命令在package.json配置",charIndex:2830},{level:3,title:"baiduPush.sh执行百度推送命令",slug:"baidupush-sh执行百度推送命令",normalizedTitle:"baidupush.sh执行百度推送命令",charIndex:3183},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3669}],excerpt:'<h1 id="github-actions-定时运行代码-每天定时百度链接推送"><a class="header-anchor" href="#github-actions-定时运行代码-每天定时百度链接推送">#</a> GitHub Actions 定时运行代码：每天定时百度链接推送</h1>\n<p>博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。</p>\n<p>最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。</p>\n<p>GitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>\n',headersStr:"百度主动链接推送 自动生成urls.txt GitHub Actions 定时运行代码 配置 GitHub Actions baiduPush命令在package.json配置 baiduPush.sh执行百度推送命令 相关文章",content:"# GitHub Actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=liuwenkai.com&token=T5PEAzhG*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baiduPush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorConsole();\nconst matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readFileList = require('./modules/readFileList');\nconst urlsRoot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst DOMAIN = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!DOMAIN) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://liuwenkai.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writeFileSync(urlsRoot, DOMAIN)\n  const files = readFileList(); // 读取所有md文件数据\n\n  files.forEach( file => {\n    const { data } = matter(fs.readFileSync(file.filePath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${DOMAIN}${data.permalink}/`;\n      console.log(link)\n      fs.appendFileSync(urlsRoot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baiduPush.js https://liuwenkai.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# GitHub Actions 定时运行代码\n\n今天的主角GitHub Actions 要登场了。（相关：GitHub Actions 入门教程、GitHub Actions 实现自动部署静态博客）\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 GitHub Actions\n\n触发 GitHub Actions 需要在项目仓库新建一个.github/workflows子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。\n\n配置文件的第一部分是触发条件。\n\n## baiduPush.yml\nname: 'baiduPush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的Ubuntu\n    steps:\n      - name: 'Checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'Run baiduPush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baiduPush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baiduPush命令。完整代码看 这里\n\n\n# baiduPush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baiduPush\": \"node utils/baiduPush.js https://liuwenkai.com && bash baiduPush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baiduPush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baiduPush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baiduPush命令之所以没有放在baiduPush.yml的 run 里面是因为我想在本地也可以执行npm run baiduPush命令。\n\n\n# baiduPush.sh执行百度推送命令\n\nbaiduPush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://liuwenkai.com&token=T5PEAzhGa*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baiduPush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 GitHub Actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在GitHub上的静态博客的问题》",normalizedContent:"# github actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到github actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=liuwenkai.com&token=t5peazhg*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baidupush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorconsole();\nconst matter = require('gray-matter'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readfilelist = require('./modules/readfilelist');\nconst urlsroot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst domain = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!domain) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baidupush.js https://liuwenkai.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writefilesync(urlsroot, domain)\n  const files = readfilelist(); // 读取所有md文件数据\n\n  files.foreach( file => {\n    const { data } = matter(fs.readfilesync(file.filepath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${domain}${data.permalink}/`;\n      console.log(link)\n      fs.appendfilesync(urlsroot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baidupush.js https://liuwenkai.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# github actions 定时运行代码\n\n今天的主角github actions 要登场了。（相关：github actions 入门教程、github actions 实现自动部署静态博客）\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 github actions\n\n触发 github actions 需要在项目仓库新建一个.github/workflows子目录，里面是 yaml 格式配置文件，文件名可以随便取。github 只要发现配置文件，就会运行 actions。\n\n配置文件的第一部分是触发条件。\n\n## baidupush.yml\nname: 'baidupush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的ubuntu\n    steps:\n      - name: 'checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'run baidupush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baidupush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baidupush命令。完整代码看 这里\n\n\n# baidupush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baidupush\": \"node utils/baidupush.js https://liuwenkai.com && bash baidupush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baidupush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baidupush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baidupush命令之所以没有放在baidupush.yml的 run 里面是因为我想在本地也可以执行npm run baidupush命令。\n\n\n# baidupush.sh执行百度推送命令\n\nbaidupush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://liuwenkai.com&token=t5peazhga*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baidupush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用github actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 github actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在github上的静态博客的问题》",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"GitHub加速下载项目的方法",frontmatter:{title:"GitHub加速下载项目的方法",date:"2020-03-09T10:28:09.000Z",permalink:"/pages/95331c6a9613faf8",categories:["技术","GitHub技巧"],tags:[null],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/10.GitHub%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.md",key:"v-62d2e41f",path:"/pages/95331c6a9613faf8/",headers:[{level:2,title:"利用码云来转接做下载加速",slug:"利用码云来转接做下载加速",normalizedTitle:"利用码云来转接做下载加速",charIndex:109}],excerpt:'<h1 id="github加速下载项目的方法"><a class="header-anchor" href="#github加速下载项目的方法">#</a> GitHub加速下载项目的方法</h1>\n<p>国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。</p>\n',headersStr:"利用码云来转接做下载加速",content:'# GitHub加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从GitHub/GitLab导入项目\n    \n    \n\n 3. 选择从URL导入，粘贴从GitHub复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',normalizedContent:'# github加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从github/gitlab导入项目\n    \n    \n\n 3. 选择从url导入，粘贴从github复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"友情链接",frontmatter:{title:"友情链接",date:"2019-12-25T14:27:01.000Z",permalink:"/friends",article:!1,sidebar:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/99.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"04.更多/99.友情链接.md",key:"v-346aebdf",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:241}],headersStr:"友链申请",content:"大飞哥\n\n大道至简，知易行难\n\n- name: 大飞哥\n  desc: 大道至简，知易行难\n  avatar: /img/df.png\n  #link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: Evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/liuwenkai/image_store/blog/20200103123203.jpg # 头像\n  link: https://liuwenkai.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",normalizedContent:"大飞哥\n\n大道至简，知易行难\n\n- name: 大飞哥\n  desc: 大道至简，知易行难\n  avatar: /img/df.png\n  #link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/liuwenkai/image_store/blog/20200103123203.jpg # 头像\n  link: https://liuwenkai.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2022/05/05, 11:07:05",lastUpdatedTimestamp:1651720025e3},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about/",sidebar:!1,article:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-7d6f7b6e",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:134}],headersStr:"📚Blog ✉️ 联系",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 610725422@qq.com\n * GitHub: https://github.com/liuwenkai01\n * Vdoing主题文档：https://doc.xugaoyi.com/\n * Vdoing交流QQ群：694387113",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术。如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 610725422@qq.com\n * github: https://github.com/liuwenkai01\n * vdoing主题文档：https://doc.xugaoyi.com/\n * vdoing交流qq群：694387113",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6/",date:"2020-04-19T11:33:04.000Z",article:!1,author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E6%8A%80%E6%9C%AF%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.技术网站.md",key:"v-00d5e539",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:134},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:342},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:563},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:590},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:678},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:742},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:800},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:864},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:349},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1115},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1164},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1236},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1297},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1460},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1720},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:842},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2057},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2117},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2147},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2208},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:541},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3309},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1934},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2387},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:3730},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1806},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4411},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:218},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3296},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4655},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5028},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2297},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5108},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5136}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n\x3c!--\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/liuwenkai/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n\n ::: center\n 关注公众号[有趣研究社]，回复`前端资源`，获取 [前端学习资料](https://github.com/liuwenkai01/blog-gitalk-comment/wiki/Front-end-Study)\n::: --\x3e\n',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-53104ef6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/27, 18:05:32",lastUpdatedTimestamp:1651053932e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-1a9d53e5",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/27, 18:05:32",lastUpdatedTimestamp:1651053932e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-150b83f6",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/27, 18:05:32",lastUpdatedTimestamp:1651053932e3},{title:"Home",frontmatter:{home:!0,heroText:"Kevin's blog",tagline:"java后端技术博客，积跬步以至千里，致敬每个爱学习的你。",bannerBg:"/img/bg.jpg"},regularPath:"/",relativePath:"index.md",key:"v-a113e2c4",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/30, 17:04:08",lastUpdatedTimestamp:1651309448e3},{title:"jvm",frontmatter:{title:"jvm",date:"2022-04-30T17:26:43.000Z",permalink:"/pages/90c423/",categories:["学习笔记","类加载器&JVM"],tags:[null],author:{name:"liuwenkai01",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/00.%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8&JVM/00.JVM%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1.html",relativePath:"学习笔记/00.类加载器&JVM/00.JVM知识图谱.md",key:"v-d2440a98",path:"/pages/90c423/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/05/05, 09:31:04",lastUpdatedTimestamp:1651714264e3},{title:"常用Git命令清单",frontmatter:{title:"常用Git命令清单",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/8292d8/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/00.%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95.html",relativePath:"学习笔记/70.《Git》学习笔记/10.手册/00.常用Git命令清单.md",key:"v-680748c4",path:"/pages/8292d8/",headers:[{level:2,title:"一、新建代码库",slug:"一、新建代码库",normalizedTitle:"一、新建代码库",charIndex:187},{level:2,title:"二、配置",slug:"二、配置",normalizedTitle:"二、配置",charIndex:334},{level:2,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:605},{level:2,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:1005},{level:2,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:1406},{level:2,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:2199},{level:2,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:2616},{level:2,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:3725},{level:2,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:4147},{level:2,title:"十、常用操作组合",slug:"十、常用操作组合",normalizedTitle:"十、常用操作组合",charIndex:4799},{level:3,title:"1. 修改本地分支名和远程分支名",slug:"_1-修改本地分支名和远程分支名",normalizedTitle:"1. 修改本地分支名和远程分支名",charIndex:4812}],headersStr:"一、新建代码库 二、配置 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、常用操作组合 1. 修改本地分支名和远程分支名",content:'# 常用Git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n>  * Workspace：工作区\n>  * Index / Stage：暂存区\n>  * Repository：仓库区（或本地仓库）\n>  * Remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\nGit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 Git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',normalizedContent:'# 常用git命令清单\n\n一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。\n\n\n\n下面是我整理的常用 git 命令清单。几个专用名词的译名如下。\n\n>  * workspace：工作区\n>  * index / stage：暂存区\n>  * repository：仓库区（或本地仓库）\n>  * remote：远程仓库\n\n\n# 一、新建代码库\n\n# 在当前目录新建一个git代码库\n$ git init\n\n# 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 二、配置\n\ngit的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n# 显示当前的git配置\n$ git config --list\n\n# 编辑git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 三、增加/删除文件\n\n# 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 四、代码提交\n\n# 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 五、分支\n\n# 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 六、标签\n\n# 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagname]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 七、查看信息\n\n# 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -s [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 八、远程同步\n\n# 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 九、撤销\n\n# 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 十、常用操作组合\n\n\n# 1. 修改本地分支名和远程分支名\n\ngit branch -m old_branch new_branch # 重命名本地分支\ngit push origin :old_branch # 删除远程旧分支（分支名前有冒号）\ngit push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支\n\n\n1\n2\n3\n\n\n相关文章：\n\n《如何撤销 git 操作？》\n\n《git cherry-pick 教程》 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。\n\n> 命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html',charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git变基合并",frontmatter:{title:"Git变基合并",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c10281/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/03.Git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6.html",relativePath:"学习笔记/70.《Git》学习笔记/10.手册/03.Git变基合并.md",key:"v-416d1532",path:"/pages/c10281/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:17},{level:3,title:"变基要遵守的准则",slug:"变基要遵守的准则",normalizedTitle:"变基要遵守的准则",charIndex:750},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:815},{level:2,title:"后悔药",slug:"后悔药",normalizedTitle:"后悔药",charIndex:531},{level:2,title:"开发期间的rebase操作",slug:"开发期间的rebase操作",normalizedTitle:"开发期间的rebase操作",charIndex:1887},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:1905},{level:3,title:"操作步骤",slug:"操作步骤",normalizedTitle:"操作步骤",charIndex:2159},{level:3,title:"git cherry-pick",slug:"git-cherry-pick",normalizedTitle:"git cherry-pick",charIndex:2524},{level:4,title:"基本应用",slug:"基本应用",normalizedTitle:"基本应用",charIndex:2595},{level:4,title:"转移多个提交",slug:"转移多个提交",normalizedTitle:"转移多个提交",charIndex:2777}],headersStr:"说明 变基要遵守的准则 变基的实质 后悔药 开发期间的rebase操作 背景 操作步骤 git cherry-pick 基本应用 转移多个提交",content:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (HEAD -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看HEAD指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (HEAD -> v2, master) HEAD@{0}: checkout: moving from master to v2\n07c398f (HEAD -> v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master\n07c398f (HEAD -> v2, master) HEAD@{2}: rebase (start): checkout v2\n15a97d8 HEAD@{3}: reset: moving to 15a97d8\n07c398f (HEAD -> v2, master) HEAD@{4}: merge v2: Fast-forward\n15a97d8 HEAD@{5}: checkout: moving from v2 to master\n07c398f (HEAD -> v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (HEAD -> v2, master) HEAD@{7}: rebase (pick): C\n15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase\nd278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 HEAD@{10}: commit: D\n\n# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}\ngit reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit ID 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commitHash> # 将commitHash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\nCherry pick 支持一次转移多个提交。\n\ngit cherry-pick <HashA> <HashB> # A和B提交\n\n\n1\n\n\n上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick A..B # A到B提交，不包含A\n\n\n1\n\n\n上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。\n\ngit cherry-pick A^..B # A到B提交，包含A\n\n\n1\n",normalizedContent:"# rebase分支合并\n\n\n# 说明\n\n以下 v2 是某个需求的开发分支， dev是总的开发分支，v2 是基于dev分支签出的。\n\n当完成v2的开发后，需要把代码合并到dev，我们可以使用rebase进行合并：\n\n# 首先将 v2 push到远程仓库\ngit add .\ngit commit -m 'xxx'\ngit push origin v2\n\n# 切换到 dev 拉取最新代码\ngit checkout dev\ngit pull origin dev\n\n# 切换到 v2\ngit checkout v2\ngit rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev\n\n# 切换到 dev\ngit checkout dev\ngit merge v2  # 将 dev分支 快进合并 （此时 (head -> dev, v2) [commit] 两个分支指向同一个提交）\n\n# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）\ngit log\n\n\t# 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态\n\n# 试运行项目是否有问题\nyarn start\n\ngit status # 查看状态是否有问题\ngit push origin dev # 推送到远程仓库的 dev\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 变基要遵守的准则\n\n几个人同时在一个分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 因此，变基操作过后的分支将不要再使用。\n\n\n# 后悔药\n\n# 查看head指针变动记录\ngit reflog\n# 记录示例(当前分支是v2):\n07c398f (head -> v2, master) head@{0}: checkout: moving from master to v2\n07c398f (head -> v2, master) head@{1}: rebase (finish): returning to refs/heads/master\n07c398f (head -> v2, master) head@{2}: rebase (start): checkout v2\n15a97d8 head@{3}: reset: moving to 15a97d8\n07c398f (head -> v2, master) head@{4}: merge v2: fast-forward\n15a97d8 head@{5}: checkout: moving from v2 to master\n07c398f (head -> v2, master) head@{6}: rebase (finish): returning to refs/heads/v2\n07c398f (head -> v2, master) head@{7}: rebase (pick): c\n15a97d8 head@{8}: rebase (start): checkout master # 首次rebase\nd278ecd head@{9}: checkout: moving from master to v2 # rebase前的状态\n15a97d8 head@{10}: commit: d\n\n# 可见，示例中最初的 rebase 操作是 head@{8}，想回退到变基前的状态需让指针指向 head@{9}\ngit reset --hard d278ecd  # 重置当前分支的head为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致\n\n# 此时打印 log 查看是否回到之前的状态\ngit log\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。\n\n\n# 开发期间的rebase操作\n\n\n# 背景\n\n有两个分支：\n\ndev\n*v2\n\n\n1\n2\n\n\n2.4-dev 是基于dev切出来的。\n\n提交记录如下：\n\n\t\tdev\na - b - c\n\t\tv2\n\n\n1\n2\n3\n\n\n开发期间，两个分支同时有新的commit ：\n\n\t\t\t\tdev\na - b - c - d - e\n\t\t\\ - f - g\n\t\t\t\tv2\n\n\n1\n2\n3\n4\n\n\n当前你正在v2进行开发，dev也同时进行开发，并有重大的改变，你需要把dev的提交同步到v2。\n\n需求： 把dev中新的提交同步到v2，且不能影响dev分支。\n\n\n# 操作步骤\n\n 1. 基于最新的 dev 切一个新的分支 dev-copy\n    \n    > dev-copy 和 dev 两者的 commit id 一致。\n\n 2. 在dev-copy中执行rebase，将 dev-copy 的提交变基到 v2\n    \n    git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2\n    \n    \n    1\n    \n\n 3. 删除原v2分支，将dev-copy分支名改为v2\n    \n    # 当前在 dev-copy 分支\n    git branch -d v2 # 删除分支\n    git branch -m dev-copy v2 # 重命名\n    \n    \n    1\n    2\n    3\n    \n\n\n# git cherry-pick\n\n来源：《git cherry-pick 教程》\n\n用于将单个或几个[commit]复制到另一个分支。\n\n# 基本应用\n\ngit cherry-pick <commithash> # 将commithash应用于当前分支\n\n\n1\n\n\n上面命令就会将指定的提交commithash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。\n\ngit cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。\n\n# 转移多个提交\n\ncherry pick 支持一次转移多个提交。\n\ngit cherry-pick <hasha> <hashb> # a和b提交\n\n\n1\n\n\n上面的命令将 a 和 b 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。\n\n如果想要转移一系列的连续提交，可以使用下面的简便语法。\n\ngit cherry-pick a..b # a到b提交，不包含a\n\n\n1\n\n\n上面的命令可以转移从 a 到 b 的所有提交。它们必须按照正确的顺序放置：提交 a 必须早于提交 b，否则命令将失败，但不会报错。\n\n注意，使用上面的命令，提交 a 将不会包含在 cherry pick 中。如果要包含提交 a，可以使用下面的语法。\n\ngit cherry-pick a^..b # a到b提交，包含a\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git命令思维导图",frontmatter:{title:"Git命令思维导图",date:"2020-11-18T17:46:22.000Z",permalink:"/pages/4cbc21/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E6%89%8B%E5%86%8C/06.Git%E5%91%BD%E4%BB%A4%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE.html",relativePath:"学习笔记/70.《Git》学习笔记/10.手册/06.Git命令思维导图.md",key:"v-ca22736a",path:"/pages/4cbc21/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git基础与命令",frontmatter:{title:"Git基础与命令",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/635088/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10.Git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/10.Git基础与命令.md",key:"v-7d1c2eeb",path:"/pages/635088/",headers:[{level:2,title:"Git基础",slug:"git基础",normalizedTitle:"git基础",charIndex:2},{level:3,title:"全局配置",slug:"全局配置",normalizedTitle:"全局配置",charIndex:93},{level:3,title:"检查配置信息",slug:"检查配置信息",normalizedTitle:"检查配置信息",charIndex:202},{level:3,title:"获取帮助",slug:"获取帮助",normalizedTitle:"获取帮助",charIndex:237},{level:3,title:"初始化仓库",slug:"初始化仓库",normalizedTitle:"初始化仓库",charIndex:398},{level:3,title:"克隆远程仓库",slug:"克隆远程仓库",normalizedTitle:"克隆远程仓库",charIndex:474},{level:3,title:"检查文件状态",slug:"检查文件状态",normalizedTitle:"检查文件状态",charIndex:623},{level:3,title:"加入暂存区 (跟踪文件)",slug:"加入暂存区-跟踪文件",normalizedTitle:"加入暂存区 (跟踪文件)",charIndex:950},{level:3,title:"忽略文件",slug:"忽略文件",normalizedTitle:"忽略文件",charIndex:1119},{level:3,title:"查看修改的具体内容",slug:"查看修改的具体内容",normalizedTitle:"查看修改的具体内容",charIndex:2105},{level:3,title:"提交更新",slug:"提交更新",normalizedTitle:"提交更新",charIndex:2263},{level:3,title:"跳过使用暂存区域",slug:"跳过使用暂存区域",normalizedTitle:"跳过使用暂存区域",charIndex:2406},{level:2,title:"Git 基础 - 查看提交历史",slug:"git-基础-查看提交历史",normalizedTitle:"git 基础 - 查看提交历史",charIndex:2506},{level:2,title:"Git 基础 - 撤消操作",slug:"git-基础-撤消操作",normalizedTitle:"git 基础 - 撤消操作",charIndex:4022},{level:2,title:"Git 基础 - 远程仓库的使用",slug:"git-基础-远程仓库的使用",normalizedTitle:"git 基础 - 远程仓库的使用",charIndex:4228},{level:3,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:4249},{level:3,title:"添加远程仓库",slug:"添加远程仓库",normalizedTitle:"添加远程仓库",charIndex:4323},{level:3,title:"从远程仓库中抓取与拉取",slug:"从远程仓库中抓取与拉取",normalizedTitle:"从远程仓库中抓取与拉取",charIndex:4370},{level:3,title:"推送到远程仓库",slug:"推送到远程仓库",normalizedTitle:"推送到远程仓库",charIndex:1106},{level:3,title:"查看某个远程仓库",slug:"查看某个远程仓库",normalizedTitle:"查看某个远程仓库",charIndex:4825},{level:3,title:"远程仓库的重命名与移除",slug:"远程仓库的重命名与移除",normalizedTitle:"远程仓库的重命名与移除",charIndex:4951},{level:2,title:"Git 基础 - 打标签",slug:"git-基础-打标签",normalizedTitle:"git 基础 - 打标签",charIndex:5049},{level:3,title:"列出标签",slug:"列出标签",normalizedTitle:"列出标签",charIndex:5066},{level:3,title:"创建标签",slug:"创建标签",normalizedTitle:"创建标签",charIndex:5164},{level:3,title:"附注标签",slug:"附注标签",normalizedTitle:"附注标签",charIndex:5199},{level:3,title:"轻量标签",slug:"轻量标签",normalizedTitle:"轻量标签",charIndex:5181},{level:3,title:"后期打标签",slug:"后期打标签",normalizedTitle:"后期打标签",charIndex:5893},{level:3,title:"共享标签",slug:"共享标签",normalizedTitle:"共享标签",charIndex:6294},{level:3,title:"删除标签",slug:"删除标签",normalizedTitle:"删除标签",charIndex:6527},{level:3,title:"检出标签",slug:"检出标签",normalizedTitle:"检出标签",charIndex:7014},{level:2,title:"Git 命令别名",slug:"git-命令别名",normalizedTitle:"git 命令别名",charIndex:8135}],headersStr:"Git基础 全局配置 检查配置信息 获取帮助 初始化仓库 克隆远程仓库 检查文件状态 加入暂存区 (跟踪文件) 忽略文件 查看修改的具体内容 提交更新 跳过使用暂存区域 Git 基础 - 查看提交历史 Git 基础 - 撤消操作 Git 基础 - 远程仓库的使用 查看远程仓库 添加远程仓库 从远程仓库中抓取与拉取 推送到远程仓库 查看某个远程仓库 远程仓库的重命名与移除 Git 基础 - 打标签 列出标签 创建标签 附注标签 轻量标签 后期打标签 共享标签 删除标签 检出标签 Git 命令别名",content:"# Git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# Git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n M README # 已修改，但未暂存 （M的位置靠右，红色）\nMM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\nA  lib/git.rb # 新添加到暂存区，未提交\nM  lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色）\n?? LICENSE.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 Git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO\n/TODO\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nGitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# Git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 SHA-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - Scott Chacon, 6 years ago : changed the version number\n085bb3b - Scott Chacon, 6 years ago : removed unnecessary test\na11bef0 - Scott Chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from SIGCHLD on trap\n*  5e3ee11 Merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 Added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e Merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# Git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# Git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# Git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\nGit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nAuthor: Scott Chacon <schacon@gee-mail.com>\nDate:   Mon Mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\nDeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nTo /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nNote: checking out '2.0.0'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\n  git checkout -b <new-branch>\n\nHEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nPrevious HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final\nHEAD is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nSwitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# Git 命令别名\n\nGit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset HEAD --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage fileA\n$ git reset HEAD -- fileA\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 HEAD'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nAuthor: Josh Goebel <dreamer3@example.com>\nDate:   Tue Aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    Signed-off-by: Scott Chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",normalizedContent:"# git基础与命令\n\n官方文档（中文）：https://git-scm.com/book/zh/v2\n\n> 本文档是根据官方文档来编写的，以官方文档为准。\n\n\n# git基础\n\n\n# 全局配置\n\ngit config --global user.name 'your name'\ngit config --global user.email 'xxx@xx.com'\n\n\n1\n2\n\n\n自报家门\n\n\n# 检查配置信息\n\ngit config --list\n\n\n1\n\n\n\n# 获取帮助\n\n# 获取全局帮助手册\ngit help\n\n# 获取特定命令的详细版帮助手册 (两个命令是等价的)\ngit help <某个命令>\ngit <某个命令> --help # 两个横杠\n\n# 获取特定命令的简明版帮助手册\ngit <某个命令> -h  # 一个横杠\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 初始化仓库\n\n# 本地目录初始化仓库\ngit init\n\n\n1\n2\n\n\n如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库\n\n\n# 克隆远程仓库\n\n# 克隆\ngit clone <url>\n\n# 克隆同时修改目录名\ngit clone <url> <name>\n\n\n1\n2\n3\n4\n5\n\n\n初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 git 刚刚检出了它们， 而你尚未编辑过它们\n\n\n# 检查文件状态\n\n# 查看详细状态说明\ngit status\n\n# 查看简明状态说明\ngit status -s  # -s 或 --short\n m readme # 已修改，但未暂存 （m的位置靠右，红色）\nmm rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）\na  lib/git.rb # 新添加到暂存区，未提交\nm  lib/simplegit.rb # 已修改，已暂存 （m的位置靠左，绿色）\n?? license.txt # 新添加，未跟踪\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n * git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区\n\n * 参数的一个横杠表示缩写，两个横杠表示全称。\n\n\n# 加入暂存区 (跟踪文件)\n\n# 文件加入暂存区（跟踪指定文件)\ngit add <files>\n\n\n1\n2\n\n\ngit add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。\n\nadd 命令是将文件加入到暂存区，commit 命令的提交到本地仓库，push 命令是推送到远程仓库。\n\n\n# 忽略文件\n\n添加一个名为 .gitignore 的文件，列出要忽略的文件的模式\n\n*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）\n*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）\n\n\n1\n2\n\n\n文件 .gitignore 的格式规范如下：\n\n * 所有空行或者以 # 开头的行都会被 git 忽略（注释符号）。\n\n * 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。\n   \n   > glob 模式是指 shell 所使用的简化了的正则表达式\n\n * 匹配模式可以以（/）开头防止递归。\n\n * 匹配模式可以以（/）结尾指定目录。\n\n * 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。\n\n----------------------------------------\n\n * 星号（*）匹配零个或多个任意字符\n * [abc] 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）\n * 问号（?）只匹配一个任意字符\n * [0-9] 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配\n * 使用两个星号（**）表示匹配任意中间目录，比如 a/**/z 可以匹配 a/z 、 a/b/z 或 a/b/c/z 等。\n\n# 忽略所有的 .a 文件\n*.a\n\n# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件\n!lib.a\n\n# 只忽略当前目录下的 todo 文件，而不忽略 subdir/todo\n/todo\n\n# 忽略任何目录下名为 build 的文件夹\nbuild/\n\n# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt\ndoc/*.txt\n\n# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件\ndoc/**/*.pdf\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ngithub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表， 你可以在 https://github.com/github/gitignore 找到它。\n\n\n# 查看修改的具体内容\n\ngit diff # 比较修改之后还没有暂存起来的变化内容。\n\ngit diff --staged # 查看已暂存的将要添加到下次提交里的内容\n\n\n1\n2\n3\n\n\ngit status 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用git diff可以看到具体变动的内容。\n\n\n# 提交更新\n\ngit commit # 未带参数的会打开默认文本编辑器让你输入提交说明\n\ngit commit -m '提交说明' # 带-m参数直接输入提交说明\n\n\n1\n2\n3\n\n\n使用git commit提交更新，在此之前，务必确认所有变动已经被git add添加到暂存区。\n\n\n# 跳过使用暂存区域\n\ngit commit -a -m '提交说明'\n\n\n1\n\n\n添加-a选项可以跳过git add 步骤，把已经跟踪过的文件一并提交。\n\n注意：这个操作无法提交未跟踪的文件。\n\n\n# git 基础 - 查看提交历史\n\ngit log\n\n\n1\n\n\n不传入任何参数的默认情况下，git log 会按时间先后顺序列出所有的提交，最近的更新排在最上面。\n\n此命令打印的数据中有一项是一长串的 sha-1 校验码。\n\n带入-p或--patch查看提交的具体差异：\n\ngit log -p -2 # -p显示差异  -2显示最近的提交次数\n\n\n1\n\n\n--stat 显示每次提交的差异统计\n\ngit log --stat\n\n\n1\n\n\n--pretty 这个选项可以使用不同于默认格式的方式展示提交历史\n\n这个选项有一些内建的子选项供你使用。 比如 oneline 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 short，full 和 fuller 选项，它们展示信息的格式基本一致，但是详尽程度不一：\n\n$ git log --pretty=oneline\nca82a6dff817ec66f44342007202690a93763949 changed the version number\n085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test\na11bef06a3f659402fe7563abf99ad00de2209e6 first commit\n\n\n1\n2\n3\n4\n\n\n最有意思的是 format ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 git 的更新而发生改变：\n\n$ git log --pretty=format:\"%h - %an, %ar : %s\"\nca82a6d - scott chacon, 6 years ago : changed the version number\n085bb3b - scott chacon, 6 years ago : removed unnecessary test\na11bef0 - scott chacon, 6 years ago : first commit\n\n\n1\n2\n3\n4\n\n\ngit log --pretty=format 常用的选项 列出了 format 接受的常用格式占位符的写法及其代表的意义。\n\n当 oneline 或 format 与另一个 log 选项 --graph 结合使用时尤其有用。 这个选项添加了一些 ascii 字符串来形象地展示你的分支、合并历史：\n\n$ git log --pretty=format:\"%h %s\" --graph\n* 2d3acf9 ignore errors from sigchld on trap\n*  5e3ee11 merge branch 'master' of git://github.com/dustin/grit\n|\\\n| * 420eac9 added a method for getting the current branch.\n* | 30e367c timeout code and tests\n* | 5a09431 add timeout protection to grit\n* | e1193f8 support for heads with slashes in them\n|/\n* d6016bc require time for xmlschema\n*  11d191e merge branch 'defunkt' into local\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# git 基础 - 撤消操作\n\n你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：\n\n$ git commit -m 'initial commit'\n$ git add forgotten_file\n$ git commit --amend # 重新提交，且只有一次提交记录\n\n\n1\n2\n3\n\n\n最终你只会有一个提交——第二次提交将代替第一次提交的结果。\n\n更多撤销操作请了解 reset命令。\n\n\n# git 基础 - 远程仓库的使用\n\n\n# 查看远程仓库\n\ngit remote # 仅显示远程仓库的名称\ngit remote -v # 显示远程仓库的名称 + 地址\n\n\n1\n2\n\n\n\n# 添加远程仓库\n\n git remote add <远程仓库名> <url>\n\n\n1\n\n\n\n# 从远程仓库中抓取与拉取\n\n就如刚才所见，从远程仓库中获得数据，可以执行：\n\ngit fetch <remote>\n\n\n1\n\n\n这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。\n\n注意： git fetch 命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。\n\ngit pull\n\n\n1\n\n\n用 git pull 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或其它名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。\n\n\n# 推送到远程仓库\n\ngit push <remote> <branch> # git push origin master\n\n\n1\n\n\n\n# 查看某个远程仓库\n\n git remote show <remote> # git remote show origin\n\n\n1\n\n\n查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支\n\n\n# 远程仓库的重命名与移除\n\ngit remote rename <原名> <新名> # 重命名\ngit remote remove paul <remote># 移除远程仓库\n\n\n1\n2\n\n\n\n# git 基础 - 打标签\n\n\n# 列出标签\n\ngit tag # 完整标签列表\ngit tag -l \"v2.0*\" # 只显示包含 v2.0 的标签。 注意加星号(*)\n\n\n1\n2\n\n\n-l 或 --list 都可以。\n\n\n# 创建标签\n\ngit 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。\n\n轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。\n\n而附注标签是存储在 git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 gnu privacy guard （gpg）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。\n\n\n# 附注标签\n\ngit tag -a v1.4 -m \"my version 1.4\" # -a表示add， -m 表示附件信息\n\n\n1\n\n\n通过使用 git show 命令可以看到标签信息和与之对应的提交信息：\n\ngit show v1.4\n\n\n1\n\n\n\n# 轻量标签\n\n轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 -a、-s 或 -m 选项，只需要提供标签名字：\n\ngit tag v1.4-lw # 不需要添加选项\n\n\n1\n\n\n这时，如果在标签上运行 git show，你不会看到额外的标签信息。 命令只会显示出提交信息：\n\n$ git show v1.4-lw\ncommit ca82a6dff817ec66f44342007202690a93763949\nauthor: scott chacon <schacon@gee-mail.com>\ndate:   mon mar 17 21:52:11 2008 -0700\n\n\n1\n2\n3\n4\n\n\n\n# 后期打标签\n\n你也可以对过去的提交打标签。 假设提交历史是这样的：\n\n$ git log --pretty=oneline\n166ae0c4d3f420721acbb115cc33848dfcc2121a started write support\n9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile\n8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme\n\n\n1\n2\n3\n4\n\n\n现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：\n\n$ git tag -a v1.2 9fceb02 # 打的标签属于附注标签\n\n\n1\n\n\n\n# 共享标签\n\ngit push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin <tagname>。\n\ngit push origin v1.5 # 显式地推送标签到远程仓库\ngit push origin --tags # 一次性推送所有不在远程仓库上的标签\n\n\n1\n2\n\n\n现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。\n\n\n# 删除标签\n\n要删除掉你本地仓库上的标签，可以使用命令 git tag -d <tagname>。 例如，可以使用以下命令删除一个轻量标签：\n\n$ git tag -d v1.4-lw\ndeleted tag 'v1.4-lw' (was e7d5add)\n\n\n1\n2\n\n\n注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 git push <remote> :refs/tags/<tagname> 来更新你的远程仓库：\n\n第一种变体是 git push <remote> :refs/tags/<tagname> ：\n\n$ git push origin :refs/tags/v1.4-lw\nto /git@github.com:schacon/simplegit.git\n - [deleted]         v1.4-lw\n\n\n1\n2\n3\n\n\n上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。\n\n第二种更直观的删除远程标签的方式是：\n\n$ git push origin --delete <tagname>\n\n\n1\n\n\n\n# 检出标签\n\n如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于“分离头指针（detached head）”的状态——这个状态有些不好的副作用：\n\n$ git checkout 2.0.0\nnote: checking out '2.0.0'.\n\nyou are in 'detached head' state. you can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nif you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. example:\n\n  git checkout -b <new-branch>\n\nhead is now at 99ada87... merge pull request #89 from schacon/appendix-final\n\n$ git checkout 2.0-beta-0.1\nprevious head position was 99ada87... merge pull request #89 from schacon/appendix-final\nhead is now at df3f601... add atlas.json and cover image\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：\n\n$ git checkout -b version2 v2.0.0\nswitched to a new branch 'version2'\n\n\n1\n2\n\n\n如果在这之后又进行了一次提交，version2 分支就会因为这个改动向前移动， 此时它就会和 v2.0.0 标签稍微有些不同，这时就要当心了。\n\n\n# git 命令别名\n\ngit 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 git 命令，可以通过 git config 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：\n\n$ git config --global alias.co checkout\n$ git config --global alias.br branch\n$ git config --global alias.ci commit\n$ git config --global alias.st status\n\n\n1\n2\n3\n4\n\n\n这意味着，当要输入 git commit 时，只需要输入 git ci。\n\n在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 git 中添加你自己的取消暂存别名：\n\n$ git config --global alias.unstage 'reset head --'\n\n\n1\n\n\n这会使下面的两个命令等价：\n\n$ git unstage filea\n$ git reset head -- filea\n\n\n1\n2\n\n\n这样看起来更清楚一些。 通常也会添加一个 last 命令，像这样：\n\n$ git config --global alias.last 'log -1 head'\n\n\n1\n\n\n这样，可以轻松地看到最后一次提交：\n\n$ git last\ncommit 66938dae3329c7aebe598c2246a8e6af90d04646\nauthor: josh goebel <dreamer3@example.com>\ndate:   tue aug 26 19:48:51 2008 +0800\n\n    test for current head\n\n    signed-off-by: scott chacon <schacon@example.com>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出，git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 git 子命令。 如果是那样的话，可以在命令前面加入 ! 符号。 如果你自己要写一些与 git 仓库协作的工具的话，那会很有用。 我们现在演示将 git visual 定义为 gitk 的别名：\n\n$ git config --global alias.visual '!gitk'\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git工具-重写历史",frontmatter:{title:"Git工具-重写历史",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/1832fe/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.md",key:"v-60e51ea4",path:"/pages/1832fe/",headers:[{level:2,title:"修改最后一次提交",slug:"修改最后一次提交",normalizedTitle:"修改最后一次提交",charIndex:453},{level:3,title:"修改提交信息",slug:"修改提交信息",normalizedTitle:"修改提交信息",charIndex:519},{level:3,title:"修改实际内容",slug:"修改实际内容",normalizedTitle:"修改实际内容",charIndex:700},{level:2,title:"修改多个提交信息",slug:"修改多个提交信息",normalizedTitle:"修改多个提交信息",charIndex:1113},{level:2,title:"重新排序提交",slug:"重新排序提交",normalizedTitle:"重新排序提交",charIndex:4034},{level:2,title:"压缩提交",slug:"压缩提交",normalizedTitle:"压缩提交",charIndex:4460},{level:2,title:"拆分提交",slug:"拆分提交",normalizedTitle:"拆分提交",charIndex:6218},{level:2,title:"核武器级选项：filter-branch",slug:"核武器级选项-filter-branch",normalizedTitle:"核武器级选项：filter-branch",charIndex:7244},{level:3,title:"从每一个提交中移除一个文件",slug:"从每一个提交中移除一个文件",normalizedTitle:"从每一个提交中移除一个文件",charIndex:7318},{level:3,title:"使一个子目录做为新的根目录",slug:"使一个子目录做为新的根目录",normalizedTitle:"使一个子目录做为新的根目录",charIndex:8358},{level:3,title:"全局修改邮箱地址",slug:"全局修改邮箱地址",normalizedTitle:"全局修改邮箱地址",charIndex:8684}],headersStr:"修改最后一次提交 修改提交信息 修改实际内容 修改多个提交信息 重新排序提交 压缩提交 拆分提交 核武器级选项：filter-branch 从每一个提交中移除一个文件 使一个子目录做为新的根目录 全局修改邮箱地址",content:"# Git 工具 - 重写历史\n\n许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nNOTE   在满意之前不要推送你的工作GIT 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\nTIP   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ GIT\n      COMMIT --AMEND --NO-EDIT\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 HEAD~2^ 或 HEAD~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i HEAD~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 HEAD~3..HEAD 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n# Rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" HEAD~3..HEAD\na5f4a0d added cat-file\n310154e updated README formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（HEAD~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i HEAD~3\nStopped at f7f3f6d... changed my name a bit\nYou can amend the commit now, with\n\n       git commit --amend\n\nOnce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated README formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# Commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current HEAD with a name\n# t, reset <label> = reset HEAD to a label\n# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). Use -c <commit> to reword the commit message.\n#\n# These lines can be re-ordered; they are executed from top to bottom.\n#\n# If you remove a line here THAT COMMIT WILL BE LOST.\n#\n# However, if you remove everything, the rebase will be aborted.\n#\n# Note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated README formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# This is a combination of 3 commits.\n# The first commit's message is:\nchanged my name a bit\n\n# This is the 2nd commit message:\n\nupdated README formatting and added blame\n\n# This is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated README formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset HEAD^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset HEAD^\n$ git add README\n$ git commit -m 'updated README formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\nGit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated README formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\nCAUTION   GIT FILTER-BRANCH 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          GIT-FILTER-REPO，它是一个 PYTHON 脚本，相比大多数使用 FILTER-BRANCH\n          的应用来说，它做得要更好。它的文档和源码可访问\n          HTTPS://GITHUB.COM/NEWREN/GIT-FILTER-REPO 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD\nRewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' HEAD 的命令。\n\n最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk HEAD\nRewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nRef 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 Git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ];\n        then\n                GIT_AUTHOR_NAME=\"Scott Chacon\";\n                GIT_AUTHOR_EMAIL=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",normalizedContent:"# git 工具 - 重写历史\n\n许多时候，在使用 git 时，你可能想要修订提交历史。 git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 git stash 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。\n\n在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。\n\nnote   在满意之前不要推送你的工作git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 在本地 随便重写历史记录。\n       然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。\n       简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。\n       \n\n\n# 修改最后一次提交\n\n修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。\n\n\n# 修改提交信息\n\n如果，你只是想修改最近一次提交的提交信息，那么很简单：\n\n$ git commit --amend\n\n\n1\n\n\n上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。\n\n\n# 修改实际内容\n\n另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 git commit --amend 以新的改进后的提交来 替换 掉旧有的最后一次提交，\n\n使用这个技巧的时候需要小心，因为修正会改变提交的 sha-1 校验和。 它类似于一个小的变基——如果已经推送了最后一次提交就不要修正它。\n\ntip   修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。\n      如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件），\n      那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：$ git\n      commit --amend --no-edit\n      \n\n\n# 修改多个提交信息\n\n为了修改在提交历史中较远的提交，必须使用更复杂的工具。 git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 head 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 git rebase 增加 -i 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。\n\n例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 git rebase -i 命令，即 head~2^ 或 head~3。 记住 ~3 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：\n\n$ git rebase -i head~3\n\n\n1\n\n\n再次记住这是一个变基命令——在 head~3..head 范围内的每一个修改了提交信息的提交及其 所有后裔 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。\n\n运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n# rebase 710f0f8..a5f4a0d onto 710f0f8\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n需要重点注意的是相对于正常使用的 log 命令，这些提交显示的顺序是相反的。 运行一次 log 命令，会看到类似这样的东西：\n\n$ git log --pretty=format:\"%h %s\" head~3..head\na5f4a0d added cat-file\n310154e updated readme formatting and added blame\nf7f3f6d changed my name a bit\n\n\n1\n2\n3\n4\n\n\n注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（head~3）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。\n\n你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：\n\nedit f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：\n\n$ git rebase -i head~3\nstopped at f7f3f6d... changed my name a bit\nyou can amend the commit now, with\n\n       git commit --amend\n\nonce you're satisfied with your changes, run\n\n       git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这些指令准确地告诉你该做什么。 输入\n\n$ git commit --amend\n\n\n1\n\n\n修改提交信息，然后退出编辑器。 然后，运行\n\n$ git rebase --continue\n\n\n1\n\n\n这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，git 将会停止，让你修正提交，然后继续直到完成。\n\n\n# 重新排序提交\n\n也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：\n\npick f7f3f6d changed my name a bit\npick 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n改为这样：\n\npick 310154e updated readme formatting and added blame\npick f7f3f6d changed my name a bit\n\n\n1\n2\n\n\n当保存并退出编辑器时，git 将你的分支带回这些提交的父提交，应用 310154e 然后应用 f7f3f6d，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。\n\n\n# 压缩提交\n\n通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：\n\n#\n# commands:\n# p, pick <commit> = use commit\n# r, reword <commit> = use commit, but edit the commit message\n# e, edit <commit> = use commit, but stop for amending\n# s, squash <commit> = use commit, but meld into previous commit\n# f, fixup <commit> = like \"squash\", but discard this commit's log message\n# x, exec <command> = run command (the rest of the line) using shell\n# b, break = stop here (continue rebase later with 'git rebase --continue')\n# d, drop <commit> = remove commit\n# l, label <label> = label current head with a name\n# t, reset <label> = reset head to a label\n# m, merge [-c <commit> | -c <commit>] <label> [# <oneline>]\n# .       create a merge commit using the original merge commit's\n# .       message (or the oneline, if no original merge commit was\n# .       specified). use -c <commit> to reword the commit message.\n#\n# these lines can be re-ordered; they are executed from top to bottom.\n#\n# if you remove a line here that commit will be lost.\n#\n# however, if you remove everything, the rebase will be aborted.\n#\n# note that empty commits are commented out\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n如果，指定 “squash” 而不是 “pick” 或 “edit”，git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：\n\npick f7f3f6d changed my name a bit\nsquash 310154e updated readme formatting and added blame\nsquash a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n当保存并退出编辑器时，git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：\n\n# this is a combination of 3 commits.\n# the first commit's message is:\nchanged my name a bit\n\n# this is the 2nd commit message:\n\nupdated readme formatting and added blame\n\n# this is the 3rd commit message:\n\nadded cat-file\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。\n\n\n# 拆分提交\n\n拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated readme formatting”，第二个 “added blame” 来代替原来的 “updated readme formatting and added blame”。 可以通过修改 rebase -i 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：\n\npick f7f3f6d changed my name a bit\nedit 310154e updated readme formatting and added blame\npick a5f4a0d added cat-file\n\n\n1\n2\n3\n\n\n然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，git 带你到列表中第一个提交的父提交，应用第一个提交（f7f3f6d）， 应用第二个提交（310154e），然后让你进入命令行。 那里，可以通过 git reset head^ 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 git rebase --continue：\n\n$ git reset head^\n$ git add readme\n$ git commit -m 'updated readme formatting'\n$ git add lib/simplegit.rb\n$ git commit -m 'added blame'\n$ git rebase --continue\n\n\n1\n2\n3\n4\n5\n6\n\n\ngit 在脚本中应用最后一次提交（a5f4a0d），历史记录看起来像这样：\n\n$ git log -4 --pretty=format:\"%h %s\"\n1c002dd added cat-file\n9b29157 added blame\n35cfb2b updated readme formatting\nf3cc40e changed my name a bit\n\n\n1\n2\n3\n4\n5\n\n\n再次强调，这些改动了所有在列表中的提交的 sha-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。\n\n\n# 核武器级选项：filter-branch\n\n有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 filter-branch，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。\n\ncaution   git filter-branch 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用\n          git-filter-repo，它是一个 python 脚本，相比大多数使用 filter-branch\n          的应用来说，它做得要更好。它的文档和源码可访问\n          https://github.com/newren/git-filter-repo 获取。\n          \n\n\n# 从每一个提交中移除一个文件\n\n这经常发生。 有人粗心地通过 git add . 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 filter-branch 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 passwords.txt 的文件，可以使用 --tree-filter 选项给 filter-branch：\n\n$ git filter-branch --tree-filter 'rm -f passwords.txt' head\nrewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n--tree-filter 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 passwords.txt 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 git filter-branch --tree-filter 'rm -f *~' head 的命令。\n\n最后将可以看到 git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 master 分支。 为了让 filter-branch 在所有分支上运行，可以给命令传递 --all 选项。\n\n\n# 使一个子目录做为新的根目录\n\n假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（trunk、tags 等等）。 如果想要让 trunk 子目录作为每一个提交的新的项目根目录，filter-branch 也可以帮助你那么做：\n\n$ git filter-branch --subdirectory-filter trunk head\nrewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)\nref 'refs/heads/master' was rewritten\n\n\n1\n2\n3\n\n\n现在新项目根目录是 trunk 子目录了。 git 会自动移除所有不影响子目录的提交。\n\n\n# 全局修改邮箱地址\n\n另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 --commit-filter：\n\n$ git filter-branch --commit-filter '\n        if [ \"$git_author_email\" = \"schacon@localhost\" ];\n        then\n                git_author_name=\"scott chacon\";\n                git_author_email=\"schacon@example.com\";\n                git commit-tree \"$@\";\n        else\n                git commit-tree \"$@\";\n        fi' head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 sha-1 校验和，这个命令会修改你的历史中的每一个提交的 sha-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git工具-重置揭密",frontmatter:{title:"Git工具-重置揭密",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/d9e9c6/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110.Git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.md",key:"v-9cbdbc54",path:"/pages/d9e9c6/",headers:[{level:2,title:"三棵树",slug:"三棵树",normalizedTitle:"三棵树",charIndex:147},{level:3,title:"HEAD",slug:"head",normalizedTitle:"head",charIndex:348},{level:3,title:"索引",slug:"索引",normalizedTitle:"索引",charIndex:257},{level:3,title:"工作目录",slug:"工作目录",normalizedTitle:"工作目录",charIndex:1116},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:1764},{level:2,title:"重置的作用",slug:"重置的作用",normalizedTitle:"重置的作用",charIndex:2573},{level:3,title:"第 1 步：移动 HEAD",slug:"第-1-步-移动-head",normalizedTitle:"第 1 步：移动 head",charIndex:2720},{level:3,title:"第 2 步：更新索引（--mixed）",slug:"第-2-步-更新索引-mixed",normalizedTitle:"第 2 步：更新索引（--mixed）",charIndex:3207},{level:3,title:"第 3 步：更新工作目录（--hard）",slug:"第-3-步-更新工作目录-hard",normalizedTitle:"第 3 步：更新工作目录（--hard）",charIndex:3507},{level:3,title:"回顾",slug:"回顾",normalizedTitle:"回顾",charIndex:3867},{level:2,title:"通过路径来重置",slug:"通过路径来重置",normalizedTitle:"通过路径来重置",charIndex:4002},{level:2,title:"压缩",slug:"压缩",normalizedTitle:"压缩",charIndex:4855},{level:2,title:"检出",slug:"检出",normalizedTitle:"检出",charIndex:1113},{level:3,title:"不带路径",slug:"不带路径",normalizedTitle:"不带路径",charIndex:5428},{level:3,title:"带路径",slug:"带路径",normalizedTitle:"带路径",charIndex:5429},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6348}],headersStr:"三棵树 HEAD 索引 工作目录 工作流程 重置的作用 第 1 步：移动 HEAD 第 2 步：更新索引（--mixed） 第 3 步：更新工作目录（--hard） 回顾 通过路径来重置 压缩 检出 不带路径 带路径 总结",content:"# Git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 Git 的 reset 和 checkout 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\nGit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nHEAD                上一次提交的快照，下一次提交的父结点\nIndex               预期的下一次提交的快照\nWorking Directory   沙盒\n\n\n# HEAD\n\nHEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：\n\n$ git cat-file -p HEAD\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor Scott Chacon  1301511835 -0700\ncommitter Scott Chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r HEAD\n100644 blob a906cb2a4a904a152...   README\n100644 blob 8f94139338f9404f2...   Rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nGit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 git commit 时 Git 看起来的样子。\n\nGit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\tREADME\n100644 8f94139338f9404f26296befa88755fc2598c289 0\tRakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── README\n├── Rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 HEAD 不同，若运行 git status 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 HEAD 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 HEAD\n\nreset 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（checkout 所做的）；reset 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 reset 回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 HEAD 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset HEAD~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 HEAD 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 HEAD （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed HEAD file.txt 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 HEAD 分支的指向 （已跳过）\n 2. 让索引看起来像 HEAD （到此处停止）\n\n所以它本质上只是将 file.txt 从 HEAD 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft HEAD~2 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 HEAD。 reset 会移动 HEAD 分支的指向，而 checkout 只会移动 HEAD 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 HEAD 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 reset 会移动 HEAD 分支的指向，而 checkout 则移动 HEAD 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 HEAD。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 WD Safe? 一列——如果它标记为 NO，那么运行该命令之前请考虑一下。\n\n                            HEAD   INDEX   WORKDIR   WD SAFE?\nCommit Level                                         \nreset --soft [commit]       REF    NO      NO        YES\nreset [commit]              REF    YES     NO        YES\nreset --hard [commit]       REF    YES     YES       NO\ncheckout <commit>           HEAD   YES     YES       YES\nFile Level                                           \nreset [commit] <paths>      NO     YES     NO        YES\ncheckout [commit] <paths>   NO     YES     YES       NO",normalizedContent:"# git 工具 - 重置揭密\n\n在继续了解更专业的工具前，我们先探讨一下 git 的 reset 和 checkout 命令。 在初遇的 git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。\n\n\n# 三棵树\n\n理解 reset 和 checkout 的最简方法，就是以 git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）\n\ngit 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：\n\n树                   用途\nhead                上一次提交的快照，下一次提交的父结点\nindex               预期的下一次提交的快照\nworking directory   沙盒\n\n\n# head\n\nhead 是当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 head 将是下一次提交的父结点。 通常，理解 head 的最简方式，就是将它看做 该分支上的最后一次提交 的快照。\n\n其实，查看快照的样子很容易。 下例就显示了 head 快照实际的目录列表，以及其中每个文件的 sha-1 校验和：\n\n$ git cat-file -p head\ntree cfda3bf379e4f8dba8717dee55aab78aef7f4daf\nauthor scott chacon  1301511835 -0700\ncommitter scott chacon  1301511835 -0700\n\ninitial commit\n\n$ git ls-tree -r head\n100644 blob a906cb2a4a904a152...   readme\n100644 blob 8f94139338f9404f2...   rakefile\n040000 tree 99f1a6d12cb4b6f19...   lib\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\ngit 的 cat-file 和 ls-tree 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。\n\n\n# 索引\n\n索引是你的 预期的下一次提交。 我们也会将这个概念引用为 git 的“暂存区”，这就是当你运行 git commit 时 git 看起来的样子。\n\ngit 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 git commit 将它们转换为树来用作新的提交。\n\n$ git ls-files -s\n100644 a906cb2a4a904a152e80877d4088654daad0c859 0\treadme\n100644 8f94139338f9404f26296befa88755fc2598c289 0\trakefile\n100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0\tlib/simplegit.rb\n\n\n1\n2\n3\n4\n\n\n再说一次，我们在这里又用到了 git ls-files 这个幕后的命令，它会显示出索引当前的样子。\n\n确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。\n\n\n# 工作目录\n\n最后，你就有了自己的 工作目录（通常也叫 工作区）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 .git 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 沙盒。在你将修改提交到暂存区并记录到历史之前，可以随意更改。\n\n$ tree\n.\n├── readme\n├── rakefile\n└── lib\n    └── simplegit.rb\n\n1 directory, 3 files\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 工作流程\n\n经典的 git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。\n\n\n\n让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 v1 版本，将它标记为蓝色。 现在运行 git init，这会创建一个 git 仓库，其中的 head 引用指向未创建的 master 分支。\n\n\n\n此时，只有工作目录有内容。\n\n现在我们想要提交这个文件，所以用 git add 来获取工作目录中的内容，并将其复制到索引中。\n\n\n\n接着运行 git commit，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 master 来指向本次提交。\n\n\n\n此时如果我们运行 git status，会发现没有任何改动，因为现在三棵树完全相同。\n\n现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 v2 版本，并将它标记为红色。\n\n\n\n如果现在运行 git status，我们会看到文件显示在 “changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 git add 来将它暂存到索引中。\n\n\n\n此时，由于索引和 head 不同，若运行 git status 的话就会看到 “changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 git commit 来完成提交。\n\n\n\n现在运行 git status 会没有输出，因为三棵树又变得相同了。\n\n切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 head 指向新的分支引用，将 索引 填充为该次提交的快照， 然后将 索引 的内容复制到 工作目录 中。\n\n\n# 重置的作用\n\n在以下情景中观察 reset 命令会更有意义。\n\n为了演示这些例子，假设我们再次修改了 file.txt 文件并第三次提交它。 现在的历史看起来是这样的：\n\n\n\n让我们跟着 reset 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。\n\n\n# 第 1 步：移动 head\n\nreset 做的第一件事是移动 head 的指向。 这与改变 head 自身不同（checkout 所做的）；reset 移动 head 指向的分支。 这意味着如果 head 设置为 master 分支（例如，你正在 master 分支上）， 运行 git reset 9e5e6a4 将会使 master 指向 9e5e6a4。\n\n\n\n无论你调用了何种形式的带有一个提交的 reset，它首先都会尝试这样做。 使用 reset --soft，它将仅仅停在那儿。\n\n现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 git commit 命令。 当你在运行 git commit 时，git 会创建一个新的提交，并移动 head 所指向的分支来使其指向该提交。 当你将它 reset 回 head~（head 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 git commit 来完成 git commit --amend 所要做的事情了（见 修改最后一次提交）。\n\n\n# 第 2 步：更新索引（--mixed）\n\n注意，如果你现在运行 git status 的话，就会看到新的 head 和以绿色标出的它和索引之间的区别。\n\n接下来，reset 会用 head 指向的当前快照的内容来更新索引。\n\n\n\n如果指定 --mixed 选项，reset 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 git reset head~），这就是命令将会停止的地方。\n\n现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 提交，但还会 取消暂存 所有的东西。 于是，我们回滚到了所有 git add 和 git commit 的命令执行之前。\n\n\n# 第 3 步：更新工作目录（--hard）\n\nreset 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 --hard 选项，它将会继续这一步。\n\n\n\n现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、git add 和 git commit 命令 以及 工作目录中的所有工作。\n\n必须注意，--hard 标记是 reset 命令唯一的危险用法，它也是 git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 reset 调用都可以轻松撤消，但是 --hard 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 git 数据库中的一个提交内还留有该文件的 v3 版本， 我们可以通过 reflog 来找回它。但是若该文件还未提交，git 仍会覆盖它从而导致无法恢复。\n\n\n# 回顾\n\nreset 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：\n\n 1. 移动 head 分支的指向 （若指定了 --soft，则到此停止）\n 2. 使索引看起来像 head （若未指定 --hard，则到此停止）\n 3. 使工作目录看起来像索引\n\n\n# 通过路径来重置\n\n前面讲述了 reset 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，reset 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 head 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 可以部分更新，所以重置会继续进行第 2、3 步。\n\n现在，假如我们运行 git reset file.txt （这其实是 git reset --mixed head file.txt 的简写形式，因为你既没有指定一个提交的 sha-1 或分支，也没有指定 --soft 或 --hard），它会：\n\n 1. 移动 head 分支的指向 （已跳过）\n 2. 让索引看起来像 head （到此处停止）\n\n所以它本质上只是将 file.txt 从 head 复制到索引中。\n\n\n\n它还有 取消暂存文件 的实际效果。 如果我们查看该命令的示意图，然后再想想 git add 所做的事，就会发现它们正好相反。\n\n\n\n这就是为什么 git status 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 取消暂存的文件 来了解更多。）\n\n我们可以不让 git 从 head 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 git reset eb43bf file.txt 的命令即可。\n\n\n\n它其实做了同样的事情，也就是把工作目录中的文件恢复到 v1 版本，运行 git add 添加它， 然后再将它恢复到 v3 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 git commit，它就会记录一条“将该文件恢复到 v1 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。\n\n还有一点同 git add 一样，就是 reset 命令也可以接受一个 --patch 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。\n\n\n# 压缩\n\n我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。\n\n假设你的一系列提交信息中有 “oops.”“wip” 和 “forgot this file”， 聪明的你就能使用 reset 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （压缩提交 展示了另一种方式，不过在本例中用 reset 更简单。）\n\n假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。\n\n\n\n那么可以运行 git reset --soft head~2 来将 head 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：\n\n\n\n然后只需再次运行 git commit：\n\n\n\n现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 file-a.txt 的提交， 接着第二个提交将 file-a.txt 修改成了 v3 版并增加了 file-b.txt。 包含 v2 版本的文件已经不在历史中了。\n\n\n# 检出\n\n最后，你大概还想知道 checkout 和 reset 之间的区别。 和 reset 一样，checkout 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。\n\n\n# 不带路径\n\n运行 git checkout [branch] 与运行 git reset --hard [branch] 非常相似，它会更新所有三棵树使其看起来像 [branch]，不过有两点重要的区别。\n\n首先不同于 reset --hard，checkout 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 reset --hard 则会不做检查就全面地替换所有东西。\n\n第二个重要的区别是 checkout 如何更新 head。 reset 会移动 head 分支的指向，而 checkout 只会移动 head 自身来指向另一个分支。\n\n例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上（所以 head 指向它）。 如果我们运行 git reset master，那么 develop 自身现在会和 master 指向同一个提交。 而如果我们运行 git checkout master 的话，develop 不会移动，head 自身会移动。 现在 head 将会指向 master。\n\n所以，虽然在这两种情况下我们都移动 head 使其指向了提交 a，但_做法_是非常不同的。 reset 会移动 head 分支的指向，而 checkout 则移动 head 自身。\n\n\n\n\n# 带路径\n\n运行 checkout 的另一种方式就是指定一个文件路径，这会像 reset 一样不会移动 head。 它就像 git reset [branch] file 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 git reset --hard [branch] file（如果 reset 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 head。\n\n此外，同 git reset 和 git add 一样，checkout 也接受一个 --patch 选项，允许你根据选择一块一块地恢复文件内容。\n\n\n# 总结\n\n希望你现在熟悉并理解了 reset 命令，不过关于它和 checkout 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。\n\n下面的速查表列出了命令对树的影响。 “head” 一列中的 “ref” 表示该命令移动了 head 指向的分支引用，而 “head” 则表示只移动了 head 自身。 特别注意 wd safe? 一列——如果它标记为 no，那么运行该命令之前请考虑一下。\n\n                            head   index   workdir   wd safe?\ncommit level                                         \nreset --soft [commit]       ref    no      no        yes\nreset [commit]              ref    yes     no        yes\nreset --hard [commit]       ref    yes     yes       no\ncheckout <commit>           head   yes     yes       yes\nfile level                                           \nreset [commit] <paths>      no     yes     no        yes\ncheckout [commit] <paths>   no     yes     yes       no",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支-分支原理",frontmatter:{title:"Git分支-分支原理",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/4bef1a/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20.Git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md",key:"v-c24e73d6",path:"/pages/4bef1a/",headers:[{level:3,title:"首次提交",slug:"首次提交",normalizedTitle:"首次提交",charIndex:130},{level:4,title:"小结：",slug:"小结",normalizedTitle:"小结：",charIndex:684},{level:3,title:"再次提交",slug:"再次提交",normalizedTitle:"再次提交",charIndex:823},{level:3,title:"Git 的分支",slug:"git-的分支",normalizedTitle:"git 的分支",charIndex:896},{level:3,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:1088},{level:3,title:"当前分支的指针",slug:"当前分支的指针",normalizedTitle:"当前分支的指针",charIndex:1252},{level:3,title:"查看当前所在分支",slug:"查看当前所在分支",normalizedTitle:"查看当前所在分支",charIndex:1432},{level:3,title:"分支切换",slug:"分支切换",normalizedTitle:"分支切换",charIndex:1771},{level:3,title:"创建分支同时切换",slug:"创建分支同时切换",normalizedTitle:"创建分支同时切换",charIndex:3223}],headersStr:"首次提交 小结： 再次提交 Git 的分支 创建分支 当前分支的指针 查看当前所在分支 分支切换 创建分支同时切换",content:"# Git分支-分支原理\n\nGit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，Git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add README test.rb LICENSE\n$ git commit -m 'The initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。\n\n现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# Git 的分支\n\nGit 的分支，其实本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> Git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\nGit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\nGit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 HEAD 的特殊指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. HEAD 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (HEAD -> master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -> master分支，testing 分支)\n34ac2 Fixed bug # 34ac2 提交对象\n98ca9 The initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 HEAD 就指向 testing 分支了。\n\n\n\n图6. HEAD 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. HEAD 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 HEAD 随之移动 ▲\n\n这条命令做了两件事。 一是使 HEAD 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (HEAD, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",normalizedContent:"# git分支-分支原理\n\ngit 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。\n\n\n# 首次提交\n\n在进行提交操作时，git 会保存一个提交对象（commit object）。\n\n假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 sha-1 哈希算法），然后会把当前版本的文件快照保存到 git 仓库中 （git 使用 blob 对象来保存它们），最终将校验和加入到暂存区域等待提交：\n\n$ git add readme test.rb license\n$ git commit -m 'the initial commit of my project'\n\n\n1\n2\n\n\n当使用 git commit 进行提交操作时，git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 git 仓库中这些校验和保存为树对象。随后，git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，git 就可以在需要的时候重现此次保存的快照。\n\n现在，git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个 树对象 （记录着目录结构和 blob 对象索引）以及一个 提交对象（包含着指向前述树对象的指针和所有提交信息）。\n\n\n\n图1. 首次提交对象及其树结构 ▲\n\n# 小结：\n\n 1. git add 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的文件快照（blob对象）。\n\n 2. git commit 提交操作，计算子目录或跟目录的校验和 保存为树对象。随后，创建一个提交对象，包含着指向树对象的指针和所有提交信息。\n\n\n# 再次提交\n\n做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。\n\n\n\n图2. 提交对象及其父对象 ▲\n\n\n# git 的分支\n\ngit 的分支，其实本质上仅仅是指向提交对象的可变指针。 git 的默认分支名字是 master。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。 master 分支指针会在每次提交时自动向前移动。\n\n> git 的 master 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。\n\n\n\n图3. 分支及其提交历史 ▲\n\n\n# 创建分支\n\ngit 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：\n\n$ git branch testing\n\n\n1\n\n\n这会在当前所在的提交对象上创建一个指针。\n\n\n\n图4. 两个指向相同提交历史的分支 ▲\n\n\n# 当前分支的指针\n\ngit 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个名为 head 的特殊指针，指向当前所在的本地分支（译注：将 head 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。\n\n\n\n图5. head 指向当前所在的分支 ▲\n\n\n# 查看当前所在分支\n\n你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。\n\n$ git log --oneline --decorate\nf30ab (head -> master, testing) add feature # f30ab提交对象 (head当前所在分支 -> master分支，testing 分支)\n34ac2 fixed bug # 34ac2 提交对象\n98ca9 the initial commit of my project # 98ca9 提交对象\n\n\n1\n2\n3\n4\n\n\n正如你所见，当前 master 和 testing 分支均指向校验和以 f30ab 开头的提交对象。\n\n\n# 分支切换\n\n$ git checkout testing  # git checkout <分支名>\n\n\n1\n\n\n这样 head 就指向 testing 分支了。\n\n\n\n图6. head 指向当前所在的分支 ▲\n\n那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：\n\n$ vim test.rb\n$ git commit -a -m 'made a change'\n\n\n1\n2\n\n\n\n\n图7. head 分支随着提交操作自动向前移动 ▲\n\n如图所示，你的 testing 分支向前移动了，但是 master 分支却没有，它仍然指向运行 git checkout 时所指的对象。 这就有意思了，现在我们切换回 master 分支看看：\n\n$ git checkout master\n\n\n1\n\n\n\n\n图8. 检出时 head 随之移动 ▲\n\n这条命令做了两件事。 一是使 head 指回 master 分支，二是将工作目录恢复成 master 分支所指向的快照内容。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 testing 分支所做的修改，以便于向另一个方向进行开发。\n\n我们不妨再稍微做些修改并提交：\n\n$ vim test.rb\n$ git commit -a -m 'made other changes'\n\n\n1\n2\n\n\n现在，这个项目的提交历史已经产生了分叉（参见 项目分叉历史）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。\n\n\n\n图9. 项目分叉历史 ▲\n\n你可以简单地使用 git log 命令查看分叉历史。 运行 git log --oneline --decorate --graph --all ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。\n\n$ git log --oneline --decorate --graph --all\n* c2b9e (head, master) made other changes\n| * 87ab2 (testing) made a change\n|/\n* f30ab add feature\n* 34ac2 fixed bug\n* 98ca9 initial commit of my project\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n由于 git 的分支实质上仅是包含所指对象校验和（长度为 40 的 sha-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？\n\n这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 git 鼓励开发人员频繁地创建和使用分支。\n\n\n# 创建分支同时切换\n\n通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：\n\ngit checkout -b <newbranchname>\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支的新建与合并-分支操作",frontmatter:{title:"Git分支的新建与合并-分支操作",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/ea5a8c/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30.Git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.md",key:"v-6d2e70eb",path:"/pages/ea5a8c/",headers:[{level:3,title:"创建分支并切换",slug:"创建分支并切换",normalizedTitle:"创建分支并切换",charIndex:45},{level:3,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:187},{level:3,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:575},{level:3,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:666},{level:3,title:"多次提交之后合并分支",slug:"多次提交之后合并分支",normalizedTitle:"多次提交之后合并分支",charIndex:781},{level:3,title:"遇到冲突时的分支合并",slug:"遇到冲突时的分支合并",normalizedTitle:"遇到冲突时的分支合并",charIndex:1123}],headersStr:"创建分支并切换 切换分支 合并分支 删除分支 多次提交之后合并分支 遇到冲突时的分支合并",content:"# Git分支的新建与合并-分支操作\n\n文档：Git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支Git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现CONFLICT提升，表示有冲突\n\n$ git merge iss53\nAuto-merging index.html\nCONFLICT (content): Merge conflict in index.html\nAutomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< HEAD:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",normalizedContent:"# git分支的新建与合并-分支操作\n\n文档：git 分支 - 分支的新建与合并\n\n\n# 创建分支并切换\n\n此时有一个需求需要在新的分支iss53上工作：\n\n$ git checkout -b iss53  # b表示branch\n\n\n1\n\n\n它是下面两条命令的简写：\n\n$ git branch iss53\n$ git checkout iss53\n\n\n1\n2\n\n\n\n# 切换分支\n\n突然有一个紧急问题要解决，需要在原来的master分支进行修复：\n\n$ git checkout master\n\n\n1\n\n\n在切换到master之前，需要iss53分支保持好一个干净的状态（修改都已提交）。\n\n注意：切换分支git 会重置你的工作目录。\n\n> checkout 中文含义 “检出”，checkout <branch> 检出分支 => 检出指定分支的代码 => 重置工作目录并切换分支。\n\n接下来，你要修复这个紧急问题。 建立一个 hotfix 分支，在该分支上工作直到问题解决：\n\n$ git checkout -b hotfix\n\n# 中间过程在hotfix上修改了代码并提交\n$ echo 'test' > ./hotfix.txt\n$ git add .\n$ git commit -m 'fixed'\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 合并分支\n\n$ git checkout master # 首先切回master分支\n$ git merge hotfix # 把 hotfix 分支合并过来\n\n\n1\n2\n\n\n\n# 删除分支\n\n$ git branch -d hotfix # d表示delete\n\n# 然后切回iss53继续工作\n$ git checkout iss53\n\n\n1\n2\n3\n4\n\n\n注意删除分支是在 branch 命令上\n\n\n# 多次提交之后合并分支\n\n假设你已经修正了 #53 问题，打算合并到master分支：\n\n$ git checkout master\n$ git merga iss53\n\n\n1\n2\n\n\n这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，git 不得不做一些额外的工作。 出现这种情况的时候，git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的三方合并。\n\n和之前将分支指针向前推进所不同的是，git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。\n\n\n# 遇到冲突时的分支合并\n\n如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，git 就没法干净的合并它们，就产生了冲突。\n\n合并过程中出现conflict提升，表示有冲突\n\n$ git merge iss53\nauto-merging index.html\nconflict (content): merge conflict in index.html\nautomatic merge failed; fix conflicts and then commit the result.\n\n\n1\n2\n3\n4\n\n\n使用git status查看未合并状态。\n\n任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：\n\n<<<<<<< head:index.html\n<div id=\"footer\">contact : email.support@github.com</div>\n=======\n<div id=\"footer\">\n please contact us at support@github.com\n</div>\n>>>>>>> iss53:index.html\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n你需要手动解决冲突，解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，git 就会将它们标记为冲突已解决。\n\n如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 git commit 来完成合并提交。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支管理-查看分支",frontmatter:{title:"Git分支管理-查看分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/a399b3/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40.Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.md",key:"v-2fe3fa79",path:"/pages/a399b3/",headers:[{level:3,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:10},{level:3,title:"查看每个分支的最后提交",slug:"查看每个分支的最后提交",normalizedTitle:"查看每个分支的最后提交",charIndex:152},{level:3,title:"查看已(未)合并的分支",slug:"查看已-未-合并的分支",normalizedTitle:"查看已(未)合并的分支",charIndex:297},{level:4,title:"查看指定分支的已(未)合并的分支",slug:"查看指定分支的已-未-合并的分支",normalizedTitle:"查看指定分支的已(未)合并的分支",charIndex:765}],headersStr:"查看分支 查看每个分支的最后提交 查看已(未)合并的分支 查看指定分支的已(未)合并的分支",content:"# Git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 Merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: The branch 'testing' is not fully merged.\nIf you are sure you want to delete it, run 'git branch -D testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -D testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topicA\n  featureB\n\n\n1\n2\n3\n",normalizedContent:"# git分支管理-查看分支\n\n\n# 查看分支\n\n$ git branch\n  iss53\n* master  # 带星号*表示当前所在分支\n  testing\n\n\n1\n2\n3\n4\n\n\ngit branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。\n\n\n# 查看每个分支的最后提交\n\n$ git branch -v\n  iss53   93b412c fix javascript issue\n* master  7a98805 merge branch 'iss53'\n  testing 782fd34 test\n\n\n1\n2\n3\n4\n\n\n\n# 查看已(未)合并的分支\n\n--merged 与 --no-merged 这两个选项可以查看哪些分支已经合并或未合并到 当前 分支。\n\n$ git branch --merged # 查看已合并分支列表\n  iss53\n* master\n\n\n1\n2\n3\n\n\n上面列表中分支名字前没有 * 号的分支通常可以使用 git branch -d 删除掉；\n\n$ git branch --no-merged # 查看未合并的分支列表\n  testing\n\n\n1\n2\n\n\n上面显示未合并的分支，尝试使用 git branch -d 命令删除它时会失败：\n\n$ git branch -d testing\nerror: the branch 'testing' is not fully merged.\nif you are sure you want to delete it, run 'git branch -d testing'.\n\n\n1\n2\n3\n\n\n强制删除未合并的分支:\n\n$ git branch -d testing\n\n\n1\n\n\n# 查看指定分支的已(未)合并的分支\n\n上面描述的选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 当前 分支的分支。\n\n你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 testing 分支的有哪些？\n\n$ git branch --no-merged testing\n  topica\n  featureb\n\n\n1\n2\n3\n",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支开发工作流",frontmatter:{title:"Git分支开发工作流",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/49ee30/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50.Git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.md",key:"v-0b8036da",path:"/pages/49ee30/",headers:[{level:3,title:"长期分支",slug:"长期分支",normalizedTitle:"长期分支",charIndex:32},{level:3,title:"主题分支 (短期分支)",slug:"主题分支-短期分支",normalizedTitle:"主题分支 (短期分支)",charIndex:625}],headersStr:"长期分支 主题分支 (短期分支)",content:"# Git分支开发工作流\n\n文档：Git分支开发工作流\n\n\n# 长期分支\n\n因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 C1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 C4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 C10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 C5 和 C6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 Git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。",normalizedContent:"# git分支开发工作流\n\n文档：git分支开发工作流\n\n\n# 长期分支\n\n因为 git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。\n\n许多使用 git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码，开发过程在dev分支，开发完成后并入test分支进行测试，通过测试的稳定代码才并入master分支中。\n\ndev和test分支不需要保持绝对稳定，但在test通过测试达到稳定状态，就可以被合并入master分支。\n\n事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(master)的指针总是在提交历史中落后一大截，而前沿分支(dev或test)的指针往往比较靠前。\n\n你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 proposed（建议） 或 pu: proposed updates（建议更新）分支，它可能因包含一些不成熟的内容而不能进入master 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。\n\n\n# 主题分支 (短期分支)\n\n主题分支对任何规模的项目都适用。 主题分支是一种短期分支，它被用来实现单一特性或其相关工作。\n\n你已经在上一节中你创建的 iss53 和 hotfix 主题分支中看到过这种用法。 你在上一节用到的主题分支（iss53 和 hotfix 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中每个分支都仅与其目标特性相关，因此，在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。\n\n考虑这样一个例子，你在 master 分支上工作到 c1，这时为了解决一个问题而新建 iss91 分支，在 iss91 分支上工作到 c4，然而对于那个问题你又有了新的想法，于是你再新建一个 iss91v2 分支试图用另一种方法解决那个问题，接着你回到 master 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 c10 的时候新建一个 dumbidea 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：\n\n\n\n图1. 拥有多个主题分支的提交历史 ▲\n\n现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 iss91v2 分支中方案。 另外，你将 dumbidea 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以抛弃 iss91 分支（即丢弃 c5 和 c6 提交），然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：\n\n\n\n图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲\n\n我们将会在 分布式 git 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。\n\n请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 git 版本库中 —— 没有与服务器发生交互。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支-远程分支",frontmatter:{title:"Git分支-远程分支",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/574d62/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60.Git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.md",key:"v-5f03001a",path:"/pages/574d62/",headers:[{level:3,title:"查看远程引用列表与信息",slug:"查看远程引用列表与信息",normalizedTitle:"查看远程引用列表与信息",charIndex:71},{level:3,title:"远程跟踪分支",slug:"远程跟踪分支",normalizedTitle:"远程跟踪分支",charIndex:184},{level:3,title:"推送",slug:"推送",normalizedTitle:"推送",charIndex:432},{level:4,title:"重命名远程仓库上的分支名",slug:"重命名远程仓库上的分支名",normalizedTitle:"重命名远程仓库上的分支名",charIndex:2723},{level:3,title:"跟踪分支",slug:"跟踪分支",normalizedTitle:"跟踪分支",charIndex:186},{level:3,title:"查看跟踪分支",slug:"查看跟踪分支",normalizedTitle:"查看跟踪分支",charIndex:5263},{level:3,title:"拉取",slug:"拉取",normalizedTitle:"拉取",charIndex:605},{level:3,title:"删除远程分支",slug:"删除远程分支",normalizedTitle:"删除远程分支",charIndex:6361}],headersStr:"查看远程引用列表与信息 远程跟踪分支 推送 重命名远程仓库上的分支名 跟踪分支 查看跟踪分支 拉取 删除远程分支",content:"# Git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 Git 服务器。 如果你从这里克隆，Git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 Git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 Git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 URL 的缩写。远程仓库名本质上是远程URL的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\nCounting objects: 24, done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (15/15), done.\nWriting objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.\nTotal 24 (delta 2), reused 0 (delta 0)\nTo https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 Git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nNOTE   如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，GIT 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “CREDENTIAL CACHE”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 GIT CONFIG\n       --GLOBAL CREDENTIAL.HELPER CACHE 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: Counting objects: 7, done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0)\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 Git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\nSwitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nBranch sf set up to track remote branch serverfix from origin.\nSwitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nBranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nNOTE   上游快捷方式当设置好跟踪分支后，可以通过简写 @{UPSTREAM} 或 @{U} 来引用它的上游分支。 所以在\n       MASTER 分支时并且它正在跟踪 ORIGIN/MASTER 时，如果愿意的话可以使用 GIT MERGE @{U}\n       来取代 GIT MERGE ORIGIN/MASTER。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nTo https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",normalizedContent:"# git分支-远程分支\n\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。\n\n> 远程分支本质上也是一个指针，指向远程地址\n\n\n# 查看远程引用列表与信息\n\ngit ls-remote <remote> # 远程引用的完整列表\ngit remote show <remote> # 远程分支的更多信息\n\n\n1\n2\n\n\n上面两行命令比较少用，更常见的做法是利用远程跟踪分支。\n\n\n# 远程跟踪分支\n\n远程跟踪分支是远程分支状态的引用。它们是你无法移动的本地引用。一旦你进行了网络通信， git 就会为你移动它们以精确反映远程仓库的状态。请将它们看做书签， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。\n\n它们以 <remote>/<branch> 的形式命名。 例如，如果你想要查看最后一次与远程仓库 origin 通信时 master 分支的状态，你可以查看 origin/master 分支。 你与同事合作解决一个问题并且他们推送了一个 iss53 分支，你可能有自己的本地 iss53 分支， 然而在服务器上的分支会以 origin/iss53 来表示。\n\n这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 git.ourcompany.com 的 git 服务器。 如果你从这里克隆，git 的 clone 命令会为你自动将其命名为 origin，拉取它的所有数据， 创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master。 git 也会给你一个与 origin 的 master 分支在指向同一个地方的本地 master 分支，这样你就有工作的基础。\n\n笔记：从远程克隆下来的仓库有一个叫origin/master的远程跟踪分支 和 一个本地的master分支\n\n> 笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 git init 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 git clone 时默认的远程仓库名字。 如果你运行 git clone -o booyah，那么你默认的远程分支名字将会是 booyah/master。\n\n\n\n图1. 克隆之后的服务器与本地仓库 ▲\n\n如果你在本地的 master 分支做了一些工作，在同一段时间内有其他人推送提交到 git.ourcompany.com 并且更新了它的 master 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 origin 服务器连接（并拉取数据），你的 origin/master 指针就不会移动。\n\n\n\n图2. 本地与远程的工作可以分叉 ▲\n\n如果要与给定的远程仓库同步数据，运行 git fetch <remote> 命令（在本例中为 git fetch origin）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 git.ourcompany.com）， 从中抓取本地没有的数据，并且更新本地数据库，移动 origin/master 指针到更新之后的位置。\n\n\n\n图3. git fetch 更新你的远程跟踪分支 ▲\n\n笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉\n\n为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 git.team1.ourcompany.com。 你可以运行 git remote add 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 git 基础 中详细说明。 将这个远程仓库命名为 teamone，将其作为完整 url 的缩写。远程仓库名本质上是远程url的缩写\n\n\n\n图4. 添加另一个远程仓库 ▲\n\n现在，可以运行 git fetch teamone 来抓取远程仓库 teamone 有而本地没有的数据。 因为那台服务器上现有的数据是 origin 服务器上的一个子集， 所以 git 并不会抓取数据而是会设置远程跟踪分支 teamone/master 指向 teamone 的 master 分支。\n\n\n\n图5. 远程跟踪分支 teamone/master ▲\n\n\n# 推送\n\n当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。\n\n如果希望和别人一起在名为 serverfix 的分支上工作，你可以像推送第一个分支那样推送它。 运行 git push <remote> <branch>:\n\n$ git push origin serverfix\ncounting objects: 24, done.\ndelta compression using up to 8 threads.\ncompressing objects: 100% (15/15), done.\nwriting objects: 100% (24/24), 1.91 kib | 0 bytes/s, done.\ntotal 24 (delta 2), reused 0 (delta 0)\nto https://github.com/schacon/simplegit\n * [new branch]      serverfix -> serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里有些工作被简化了。 git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix， 那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。” 我们将会详细学习 git 内部原理 的 refs/heads/ 部分， 但是现在可以先把它放在儿。你也可以运行 git push origin serverfix:serverfix， 它会做同样的事——也就是说“推送本地的 serverfix 分支，将其作为远程仓库的 serverfix 分支” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。\n\n# 重命名远程仓库上的分支名\n\n如果并不想让远程仓库上的分支叫做 serverfix，可以运行 git push origin serverfix:awesomebranch 来将本地的 serverfix 分支推送到远程仓库上的 awesomebranch 分支。\n\nnote   如何避免每次输入密码如果你正在使用 https url 来推送，git 服务器会询问用户名与密码。\n       默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个\n       “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 git config\n       --global credential.helper cache 来设置它。想要了解更多关于不同验证缓存的可用选项，查看\n       凭证存储。\n       \n\n下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 origin/serverfix，指向服务器的 serverfix 分支的引用：\n\n$ git fetch origin\nremote: counting objects: 7, done.\nremote: compressing objects: 100% (2/2), done.\nremote: total 3 (delta 0), reused 3 (delta 0)\nunpacking objects: 100% (3/3), done.\nfrom https://github.com/schacon/simplegit\n * [new branch]      serverfix    -> origin/serverfix\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 serverfix 分支——只有一个不可以修改的 origin/serverfix 指针。\n\n可以运行 git merge origin/serverfix 将这些工作合并到当前所在的分支。 如果想要在自己的 serverfix 分支上工作，可以将其建立在远程跟踪分支之上：\n\n$ git checkout -b serverfix origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n这会给你一个用于工作的本地分支，并且起点位于 origin/serverfix。\n\n\n# 跟踪分支\n\n从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）。 跟踪分支是与远程分支有直接关系的本地分支。 如果在一个跟踪分支上输入 git pull，git 能自动地识别去哪个服务器上抓取、合并到哪个分支。\n\n当克隆一个仓库时，它通常会自动地创建一个跟踪 origin/master 的 master 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 master 分支。 最简单的实例就是像之前看到的那样，运行 git checkout -b <branch> <remote>/<branch>。 这是一个十分常用的操作所以 git 提供了 --track 快捷方式：\n\n$ git checkout --track origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 git 就会为你创建一个跟踪分支：\n\n$ git checkout serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\nswitched to a new branch 'serverfix'\n\n\n1\n2\n3\n\n\n如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：\n\n$ git checkout -b sf origin/serverfix\nbranch sf set up to track remote branch serverfix from origin.\nswitched to a new branch 'sf'\n\n\n1\n2\n3\n\n\n现在，本地分支 sf 会自动从 origin/serverfix 拉取。\n\n设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n\n$ git branch -u origin/serverfix\nbranch serverfix set up to track remote branch serverfix from origin.\n\n\n1\n2\n\n\nnote   上游快捷方式当设置好跟踪分支后，可以通过简写 @{upstream} 或 @{u} 来引用它的上游分支。 所以在\n       master 分支时并且它正在跟踪 origin/master 时，如果愿意的话可以使用 git merge @{u}\n       来取代 git merge origin/master。\n       \n\n\n# 查看跟踪分支\n\n如果想要查看设置的所有跟踪分支，可以使用 git branch 的 -vv 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。\n\n$ git branch -vv\n  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets\n  master    1ae2a45 [origin/master] deploying index fix\n* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it\n  testing   5ea463a trying something new\n\n\n1\n2\n3\n4\n5\n\n\n这里可以看到 iss53 分支正在跟踪 origin/iss53 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 master 分支正在跟踪 origin/master 分支并且是最新的。 接下来可以看到 serverfix 分支正在跟踪 teamone 服务器上的 server-fix-good 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 testing 分支并没有跟踪任何远程分支。\n\n需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 这个命令并没有连接服务器，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：\n\n$ git fetch --all; git branch -vv\n\n\n1\n\n\n\n# 拉取\n\n当 git fetch 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 git pull 在大多数情况下它的含义是一个 git fetch 紧接着一个 git merge 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 clone 或 checkout 命令为你创建的，git pull 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。\n\n由于 git pull 的魔法经常令人困惑所以通常单独显式地使用 fetch 与 merge 命令会更好一些。\n\n\n# 删除远程分支\n\n假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 master 分支（或任何其他稳定代码分支）。 可以运行带有 --delete 选项的 git push 命令来删除一个远程分支。 如果想要从服务器上删除 serverfix 分支，运行下面的命令：\n\n$ git push origin --delete serverfix\nto https://github.com/schacon/simplegit\n - [deleted]         serverfix\n\n\n1\n2\n3\n\n\n基本上这个命令做的只是从服务器上移除这个指针。 git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git分支-变基",frontmatter:{title:"Git分支-变基",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/3a3247/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70.Git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/70.Git分支-变基.md",key:"v-064a931c",path:"/pages/3a3247/",headers:[{level:2,title:"变基的基本操作",slug:"变基的基本操作",normalizedTitle:"变基的基本操作",charIndex:117},{level:3,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:312},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:728},{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:1138},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:1701},{level:2,title:"更有趣的变基例子",slug:"更有趣的变基例子",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"更有趣的变基例子",slug:"更有趣的变基例子-2",normalizedTitle:"更有趣的变基例子",charIndex:1727},{level:3,title:"--onto选项",slug:"onto选项",normalizedTitle:"--onto选项",charIndex:2530},{level:3,title:"省去先切换到源分支的步骤",slug:"省去先切换到源分支的步骤",normalizedTitle:"省去先切换到源分支的步骤",charIndex:2762},{level:2,title:"变基的风险",slug:"变基的风险",normalizedTitle:"变基的风险",charIndex:3415},{level:3,title:"金科玉律",slug:"金科玉律",normalizedTitle:"金科玉律",charIndex:3425},{level:3,title:"变基的实质",slug:"变基的实质",normalizedTitle:"变基的实质",charIndex:3615},{level:2,title:"用变基解决变基",slug:"用变基解决变基",normalizedTitle:"用变基解决变基",charIndex:4412},{level:2,title:"变基 vs. 合并",slug:"变基-vs-合并",normalizedTitle:"变基 vs. 合并",charIndex:5550}],headersStr:"变基的基本操作 概念 原理 步骤 优点 更有趣的变基例子 更有趣的变基例子 --onto选项 省去先切换到源分支的步骤 变基的风险 金科玉律 变基的实质 用变基解决变基 变基 vs. 合并",content:"# Git分支-变基\n\n在 Git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（C3 和 C4）以及二者最近的共同祖先（C2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 C4 中引入的补丁和修改，然后在 C3 的基础上应用一次。 在 Git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nFirst, rewinding head to replay your work on top of it...\nApplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 C2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 C3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 C4 中的修改变基到 C3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，C4' 指向的快照就和 the merge example 中 C5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 C3 和 C4。 然后从 C3 上创建了主题分支 client，为客户端添加了一些功能，提交了 C8 和 C9。 最后，你回到 server 分支，又提交了 C10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 C8 和 C9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中C分支中的但不在B分支里的修改，应用到A分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 C4 和 C6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, Git 将会：\n\n * 检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）\n * 检查其中哪些提交不是合并操作的结果（C2，C3，C4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 C4' 和 C4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 C4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",normalizedContent:"# git分支-变基\n\n在 git 中整合来自不同分支的修改主要有两种方法：merge 以及 rebase。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。\n\n\n# 变基的基本操作\n\n请回顾之前在 分支的合并 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。\n\n\n\n图0. 分叉的提交历史 ▲\n\n之前介绍过，整合分支最容易的方法是 merge 命令。 它会把两个分支的最新快照（c3 和 c4）以及二者最近的共同祖先（c2）进行三方合并，合并的结果是生成一个新的快照（并提交）。\n\n\n\n图1. 通过合并操作来整合分叉的历史 ▲\n\n\n# 概念\n\n变基就是：将某一分支上的所有修改复制到另一分支上\n\n除了merge，还有一种方法：你可以提取在 c4 中引入的补丁和修改，然后在 c3 的基础上应用一次。 在 git 中，这种操作就叫做 变基（rebase）。 你可以使用 rebase 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。\n\n在这个例子中，你可以检出 experiment 分支，然后将它变基到 master 分支上：\n\n$ git checkout experiment\n$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）\nfirst, rewinding head to replay your work on top of it...\napplying: added staged command\n\n\n1\n2\n3\n4\n\n\n它的原理是首先找到这两个分支（即当前分支 experiment、变基操作的目标基底分支 master） 的最近共同祖先 c2，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 c3, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）\n\n\n# 原理\n\n 1. 找到当前分支和目标分支的最近共同祖先\n\n 2. 对比当前分支相对于该共同祖先的历次提交\n\n 3. 提取相应的修改并存为临时文件\n\n 4. 将当前分支指向目标分支\n\n 5. 将之前临时文件的修改依序应用\n\n\n\n图2.将 c4 中的修改变基到 c3 上 ▲\n\n现在回到 master 分支，进行一次快进合并。\n\n$ git checkout master\n$ git merge experiment\n\n\n1\n2\n\n\n\n\n图3.master 分支的快进合并 ▲\n\n\n# 步骤\n\n先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并\n\n# 示意：\ngit checkout <源分支>\ngit (源分支的修改)rebase(到) <目标分支>\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n4\n5\n\n\n此时，c4' 指向的快照就和 the merge example 中 c5 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 变基使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。\n\n一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 origin/master 上，然后再向主项目提交修改。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。\n\n请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。\n\n\n# 优点\n\n变基的优点： 使提交记录更加整洁。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n# 更有趣的变基例子\n\n在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 从一个主题分支里再分出一个主题分支的提交历史 中的例子那样。 你创建了一个主题分支 server，为服务端添加了一些功能，提交了 c3 和 c4。 然后从 c3 上创建了主题分支 client，为客户端添加了一些功能，提交了 c8 和 c9。 最后，你回到 server 分支，又提交了 c10。\n\n\n\n图4.从一个主题分支里再分出一个主题分支的提交历史 ▲\n\n假设你希望将 client 中的修改合并到主分支并发布，但暂时并不想合并 server 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 git rebase 命令的 --onto 选项， 选中在 client 分支里但不在 server 分支里的修改（即 c8 和 c9），将它们在 master 分支上重放：\n\n$ git rebase --onto master server client\n\n\n1\n\n\n以上命令的意思是：“取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样”。这理解起来有一点复杂，不过效果非常酷。\n\n\n# --onto选项\n\n选中c分支中的但不在b分支里的修改，应用到a分支。\n\n\n\n图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲\n\n现在可以快进合并 master 分支了。（如图 快进合并 master 分支，使之包含来自 client 分支的修改）：\n\n$ git checkout master\n$ git merge client\n\n\n1\n2\n\n\n\n\n图6.快进合并 `master` 分支，使之包含来自 `client` 分支的修改 ▲\n\n\n# 省去先切换到源分支的步骤\n\ngit rebase <目标(当前)分支> <源分支> # 将源分支变基到目标分支。执行此命令后会自动切换到源分支\ngit checkout <目标分支>\ngit merge <源分支>\n\n\n1\n2\n3\n\n\n注意：使用这个方法要确保源分支上的代码是最新的。\n\n接下来你决定将 server 分支中的修改也整合进来。 使用 git rebase <basebranch> <topicbranch> 命令可以直接将主题分支 （即本例中的 server）变基到目标分支（即 master）上。 这样做能省去你先切换到 server 分支，再对其执行变基命令的多个步骤。\n\n$ git rebase master server\n\n\n1\n\n\n如图 将 server 中的修改变基到 master 上 所示，server 中的代码被“续”到了 master 后面。\n\n\n\n图7.将 `server` 中的修改变基到 `master` 上 ▲\n\n然后就可以快进合并主分支 master 了：\n\n$ git checkout master\n$ git merge server\n\n\n1\n2\n\n\n至此，client 和 server 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 最终的提交历史 中的样子：\n\n$ git branch -d client\n$ git branch -d server\n\n\n1\n2\n\n\n\n\n图8. 最终的提交历史 ▲\n\n\n# 变基的风险\n\n\n# 金科玉律\n\n呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：\n\n如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。\n\n如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。\n\n提示\n\n例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。\n\n\n# 变基的实质\n\n变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 git rebase 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。\n\n让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：\n\n\n\n图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲\n\n然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：\n\n\n\n图10. 抓取别人的提交，合并到自己的开发分支 ▲\n\n接下来，这个人又决定把合并操作回滚，改用变基；继而又用 git push --force 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。\n\n\n\n图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲\n\n结果就是你们两人的处境都十分尴尬。 如果你执行 git pull 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：\n\n\n\n图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲\n\n此时如果你执行 git log 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 c4 和 c6，因为之前就是他把这两个提交通过变基丢弃的。\n\n\n# 用变基解决变基\n\n如果你 真的 遭遇了类似的处境，git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。\n\n实际上，git 除了对整个提交计算 sha-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。\n\n如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。\n\n举个例子，如果遇到前面提到的 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 那种情境，如果我们不是执行合并，而是执行 git rebase teamone/master, git 将会：\n\n * 检查哪些提交是我们的分支上独有的（c2，c3，c4，c6，c7）\n * 检查其中哪些提交不是合并操作的结果（c2，c3，c4）\n * 检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 c2 和 c3，因为 c4 其实就是 c4'）\n * 把查到的这些提交应用在 teamone/master 上面\n\n从而我们将得到与 你将相同的内容又合并了一次，生成了一个新的提交 中不同的结果，如图 在一个被变基然后强制推送的分支上再次执行变基 所示。\n\n\n\n图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲\n\n要想上述方案有效，还需要对方在变基时确保 c4' 和 c4 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 c4 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。\n\n在本例中另一种简单的方法是使用 git pull --rebase 命令而不是直接 git pull。 又或者你可以自己手动完成这个过程，先 git fetch，再 git rebase teamone/master。\n\n如果你习惯使用 git pull ，同时又希望默认使用选项 --rebase，你可以执行这条语句 git config --global pull.rebase true 来更改 pull.rebase 的默认配置。\n\n如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。\n\n如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 git pull --rebase 命令，这样尽管不能避免伤痛，但能有所缓解。\n\n\n# 变基 vs. 合并\n\n至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。\n\n有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。\n\n另一种观点则正好相反，他们认为提交历史是 项目过程中发生的事。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 rebase 及 filter-branch 等工具来编写故事，怎么方便后来的读者就怎么写。\n\n现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。\n\n总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git工具-查看修订版本",frontmatter:{title:"Git工具-查看修订版本",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/c984d1/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80.Git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.md",key:"v-0436f619",path:"/pages/c984d1/",headers:[{level:2,title:"单个修订版本",slug:"单个修订版本",normalizedTitle:"单个修订版本",charIndex:91},{level:2,title:"简短的 SHA-1",slug:"简短的-sha-1",normalizedTitle:"简短的 sha-1",charIndex:181},{level:3,title:"查看给定SHA-1值的提交",slug:"查看给定sha-1值的提交",normalizedTitle:"查看给定sha-1值的提交",charIndex:956},{level:2,title:"分支引用",slug:"分支引用",normalizedTitle:"分支引用",charIndex:2177},{level:3,title:"查看最后一次提交",slug:"查看最后一次提交",normalizedTitle:"查看最后一次提交",charIndex:2252},{level:2,title:"引用日志",slug:"引用日志",normalizedTitle:"引用日志",charIndex:2696},{level:3,title:"HEAD的指向历史",slug:"head的指向历史",normalizedTitle:"head的指向历史",charIndex:2705},{level:2,title:"祖先引用",slug:"祖先引用",normalizedTitle:"祖先引用",charIndex:4613},{level:2,title:"提交区间",slug:"提交区间",normalizedTitle:"提交区间",charIndex:6634},{level:3,title:"双点",slug:"双点",normalizedTitle:"双点",charIndex:6735},{level:4,title:"查看即将推送到远端的内容",slug:"查看即将推送到远端的内容",normalizedTitle:"查看即将推送到远端的内容",charIndex:7262},{level:3,title:"多点",slug:"多点",normalizedTitle:"多点",charIndex:7606},{level:3,title:"三点",slug:"三点",normalizedTitle:"三点",charIndex:8032}],headersStr:"单个修订版本 简短的 SHA-1 查看给定SHA-1值的提交 分支引用 查看最后一次提交 引用日志 HEAD的指向历史 祖先引用 提交区间 双点 查看即将推送到远端的内容 多点 三点",content:"# Git工具-查看修订版本\n\nGit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 SHA-1\n\nGit 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定SHA-1值的提交\n\n在本例中，假设你想要的提交其 SHA-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\nGit 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nNOTE   关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 SHA-1 值相同， GIT\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 P =\n       (N(N-1)/2) * (1/2^160)) ）。 2^80 是 1.2 X\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 LINUX 内核历史（650 万个 GIT\n       对象）的代码， 并将之提交到一个巨大的 GIT 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 rev-parse 的 Git 探测工具。 你可以在 Git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# HEAD的指向历史\n\n当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 HEAD@{1}: merge phedders/rdocs: Merge made by the 'recursive' strategy.\n1c002dd HEAD@{2}: commit: added some blame and merge stuff\n1c36188 HEAD@{3}: rebase -i (squash): updating HEAD\n95df984 HEAD@{4}: commit: # This is a combination of two commits.\n1c36188 HEAD@{5}: rebase -i (squash): updating HEAD\n7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show HEAD@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nReflog: master@{0} (Scott Chacon <schacon@gmail.com>)\nReflog message: commit: fixed refs handling, added gc auto, updated\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Fri Jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nReflog: master@{1} (Scott Chacon <schacon@gmail.com>)\nReflog message: merge phedders/rdocs: Merge made by recursive.\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show HEAD@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\nTIP   将引用日志想作 GIT 版的 SHELL 历史记录如果你有 UNIX 或者 LINUX 的背景，不妨将引用日志想作\n      GIT 版的 SHELL 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 Merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b Some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 HEAD^ 来查看上一个提交，也就是 “HEAD 的父提交”：\n\n$ git show HEAD^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nMerge: 1c002dd... 35cfb2b...\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 15:08:43 2008 -0800\n\n    Merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nNOTE   在 WINDOWS 上转义脱字符在 WINDOWS 的 CMD.EXE 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ GIT SHOW HEAD^ # 在 WINDOWS 上无法工作 $ GIT\n       SHOW HEAD^^ # 可以 $ GIT SHOW \"HEAD^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nAuthor: Scott Chacon <schacon@gmail.com>\nDate:   Thu Dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nAuthor: Paul Hedderly <paul+git@mjr.org>\nDate:   Wed Dec 10 22:22:03 2008 +0000\n\n    Some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 HEAD~ 和 HEAD^ 是等价的。 而区别在于你在后面加数字的时候。 HEAD~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，HEAD~3 就是\n\n$ git show HEAD~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 HEAD~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show HEAD~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nAuthor: Tom Preston-Werner <tom@mojombo.com>\nDate:   Fri Nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 HEAD~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 Example history for range selection.\n\n\n\nFigure 137. Example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nD\nC\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nF\nE\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..HEAD\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..HEAD 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 HEAD。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refA..refB\n$ git log ^refA refB\n$ git log refB --not refA\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refA 或 refB 包含的但是不被 refC 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refA refB ^refC\n$ git log refA refB --not refC\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nF\nE\nD\nC\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< F\n< E\n> D\n> C\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。",normalizedContent:"# git工具-查看修订版本\n\ngit 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。\n\n修订版本指的是：提交\n\n\n# 单个修订版本\n\n你可以通过任意一个提交的 40 个字符的完整 sha-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。\n\n\n# 简短的 sha-1\n\ngit 十分智能，你只需要提供 sha-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 sha-1 字符数量不得少于 4 个，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 sha-1 开头。\n\n例如，要查看你知道其中添加了某个功能的提交，首先运行 git log 命令来定位该提交：\n\n$ git log\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 查看给定sha-1值的提交\n\n在本例中，假设你想要的提交其 sha-1 以 1c002dd.... 开头， 那么你可以用如下几种 git show 的变体来检视该提交（假设简短的版本没有歧义）：\n\n$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b\n$ git show 1c002dd4b536e7479f\n$ git show 1c002d\n\n\n1\n2\n3\n\n\ngit 可以为 sha-1 值生成出简短且唯一的缩写。 如果你在 git log 后加上 --abbrev-commit 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 sha-1 的歧义，会增加字符数：\n\n$ git log --abbrev-commit --pretty=oneline\nca82a6d changed the version number\n085bb3b removed unnecessary test code\na11bef0 first commit\n\n\n1\n2\n3\n4\n\n\n通常 8 到 10 个字符就已经足够在一个项目中避免 sha-1 的歧义。 例如，到 2019 年 2 月为止，linux 内核这个相当大的 git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。\n\nnote   关于 sha-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 sha-1 值相同。\n       然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 不同 对象的 sha-1 值相同， git\n       会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。\n       如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 sha-1 摘要长度是 20\n       字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 p =\n       (n(n-1)/2) * (1/2^160)) ）。 2^80 是 1.2 x\n       10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 sha-1 冲突。\n       如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 linux 内核历史（650 万个 git\n       对象）的代码， 并将之提交到一个巨大的 git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50%\n       的概率产生一次 sha-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。\n       \n\n\n# 分支引用\n\n引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 git 命令中直接使用该分支的名称。\n\n\n# 查看最后一次提交\n\n例如，你想要查看一个分支的最后一次提交的对象，假设 topic1 分支指向提交 ca82a6d... ， 那么以下的命令是等价的：\n\n$ git show ca82a6dff817ec66f44342007202690a93763949\n$ git show topic1  # topic1是分支名\n\n\n1\n2\n\n\n如果你想知道某个分支指向哪个特定的 sha-1，或者想看任何一个例子中被简写的 sha-1， 你可以使用一个叫做 rev-parse 的 git 探测工具。 你可以在 git 内部原理 中查看更多关于探测工具的信息。 简单来说，rev-parse 是为了底层操作而不是日常操作设计的。 不过，有时你想看 git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 rev-parse\n\n$ git rev-parse topic1\nca82a6dff817ec66f44342007202690a93763949\n\n\n1\n2\n\n\n\n# 引用日志\n\n\n# head的指向历史\n\n当你在工作时， git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 head 和分支引用所指向的历史。\n\n你可以使用 git reflog 来查看引用日志\n\n$ git reflog\n734713b head@{0}: commit: fixed refs handling, added gc auto, updated\nd921970 head@{1}: merge phedders/rdocs: merge made by the 'recursive' strategy.\n1c002dd head@{2}: commit: added some blame and merge stuff\n1c36188 head@{3}: rebase -i (squash): updating head\n95df984 head@{4}: commit: # this is a combination of two commits.\n1c36188 head@{5}: rebase -i (squash): updating head\n7e05da5 head@{6}: rebase -i (pick): updating head\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n每当你的 head 所指向的位置发生了变化，git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 head 在五次前的所指向的提交，你可以使用 @{n} 来引用 reflog 中输出的提交记录。\n\n$ git show head@{5}\n\n\n1\n\n\n你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 master 分支在昨天的时候指向了哪个提交，你可以输入\n\n$ git show master@{yesterday}\n\n\n1\n\n\n就会显示昨天 master 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。\n\n可以运行 git log -g 来查看类似于 git log 输出格式的引用日志信息：\n\n$ git log -g master\ncommit 734713bc047d87bf7eac9674765ae793478c50d3\nreflog: master@{0} (scott chacon <schacon@gmail.com>)\nreflog message: commit: fixed refs handling, added gc auto, updated\nauthor: scott chacon <schacon@gmail.com>\ndate:   fri jan 2 18:32:33 2009 -0800\n\n    fixed refs handling, added gc auto, updated tests\n\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nreflog: master@{1} (scott chacon <schacon@gmail.com>)\nreflog message: merge phedders/rdocs: merge made by recursive.\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n值得注意的是，引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 git show head@{2.months.ago} 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。\n\ntip   将引用日志想作 git 版的 shell 历史记录如果你有 unix 或者 linux 的背景，不妨将引用日志想作\n      git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。\n      \n\n\n# 祖先引用\n\n祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 ^（脱字符）， git 会将其解析为该引用的上一个提交。 假设你的提交历史是：\n\n$ git log --pretty=format:'%h %s' --graph\n* 734713b fixed refs handling, added gc auto, updated tests\n*   d921970 merge commit 'phedders/rdocs'\n|\\\n| * 35cfb2b some rdoc changes\n* | 1c002dd added some blame and merge stuff\n|/\n* 1c36188 ignore *.gem\n* 9b29157 add open3_detach to gemspec file list\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n你可以使用 head^ 来查看上一个提交，也就是 “head 的父提交”：\n\n$ git show head^\ncommit d921970aadf03b3cf0e71becdaab3147ba71cdef\nmerge: 1c002dd... 35cfb2b...\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 15:08:43 2008 -0800\n\n    merge commit 'phedders/rdocs'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nnote   在 windows 上转义脱字符在 windows 的 cmd.exe 中，^ 是一个特殊字符，因此需要区别对待。\n       你可以双写它或者将提交引用放在引号中：$ git show head^ # 在 windows 上无法工作 $ git\n       show head^^ # 可以 $ git show \"head^\" # 可以\n       \n\n你也可以在 ^ 后面添加一个数字来指明想要 哪一个 父提交——例如 d921970^2 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 master），而第二父提交是你所合并的分支（例如 topic）：\n\n$ git show d921970^\ncommit 1c002dd4b536e7479fe34593e72e6c6c1819e53b\nauthor: scott chacon <schacon@gmail.com>\ndate:   thu dec 11 14:58:32 2008 -0800\n\n    added some blame and merge stuff\n\n$ git show d921970^2\ncommit 35cfb2b795a55793d7cc56a6cc2060b4bb732548\nauthor: paul hedderly <paul+git@mjr.org>\ndate:   wed dec 10 22:22:03 2008 +0000\n\n    some rdoc changes\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n另一种指明祖先提交的方法是 ~（波浪号）。 同样是指向第一父提交，因此 head~ 和 head^ 是等价的。 而区别在于你在后面加数字的时候。 head~2 代表“第一父提交的第一父提交”，也就是“祖父提交”——git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，head~3 就是\n\n$ git show head~3\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n也可以写成 head~~~，也是第一父提交的第一父提交的第一父提交：\n\n$ git show head~~~\ncommit 1c3618887afb5fbcbea25b7c013f4e2114448b8d\nauthor: tom preston-werner <tom@mojombo.com>\ndate:   fri nov 7 13:47:59 2008 -0500\n\n    ignore *.gem\n\n\n1\n2\n3\n4\n5\n6\n\n\n你也可以组合使用这两个语法——你可以通过 head~3^2 来取得之前引用的第二父提交（假设它是一个合并提交）。\n\n\n# 提交区间\n\n你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题\n\n\n# 双点\n\n最常用的指明提交区间语法是双点。 这种语法可以让 git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 example history for range selection.\n\n\n\nfigure 137. example history for range selection.\n\n你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 master..experiment 来让 git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：\n\n$ git log master..experiment\nd\nc\n\n\n1\n2\n3\n\n\n反过来，如果你想查看在 master 分支中而不在 experiment 分支中的提交，你只要交换分支名即可。 experiment..master 会显示在 master 分支中而不在 experiment 分支中的提交：\n\n$ git log experiment..master\nf\ne\n\n\n1\n2\n3\n\n\n# 查看即将推送到远端的内容\n\n这可以让你保持 experiment 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：\n\n$ git log origin/master..head\n\n\n1\n\n\n这个命令会输出在你当前分支中而不在远程 origin 中的提交。 如果你执行 git push 并且你的当前分支正在跟踪 origin/master，由 git log origin/master..head 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， git 会默认为 head。 例如， git log origin/master.. 将会输出与之前例子相同的结果 —— git 使用 head 来代替留空的一边。\n\n\n# 多点\n\n双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 git 允许你在任意引用前加上 ^ 字符或者 --not 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：\n\n$ git log refa..refb\n$ git log ^refa refb\n$ git log refb --not refa\n\n\n1\n2\n3\n\n\n这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 refa 或 refb 包含的但是不被 refc 包含的提交，你可以使用以下任意一个命令：\n\n$ git log refa refb ^refc\n$ git log refa refb --not refc\n\n\n1\n2\n\n\n这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。\n\n\n# 三点\n\n最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 之一 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 master 或者 experiment 中包含的但不是两者共有的提交，你可以执行：\n\n$ git log master...experiment\nf\ne\nd\nc\n\n\n1\n2\n3\n4\n5\n\n\n这和通常 log 按日期排序的输出一样，仅仅给出了4个提交的信息。\n\n这种情形下，log 命令的一个常用参数是 --left-right，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。\n\n$ git log --left-right master...experiment\n< f\n< e\n> d\n> c\n\n\n1\n2\n3\n4\n5\n\n\n有了这些工具，你就可以十分方便地查看你 git 仓库中的提交。",charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"Git工具-交互式暂存",frontmatter:{title:"Git工具-交互式暂存",date:"2020-11-18T17:43:57.000Z",permalink:"/pages/76d859/",categories:["《Git》学习笔记"],tags:["Git"],author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"}},regularPath:"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/70.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90.Git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98.html",relativePath:"学习笔记/70.《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.md",key:"v-2b3c7b2a",path:"/pages/76d859/",headers:[{level:2,title:"暂存与取消暂存文件",slug:"暂存与取消暂存文件",normalizedTitle:"暂存与取消暂存文件",charIndex:751},{level:2,title:"暂存补丁",slug:"暂存补丁",normalizedTitle:"暂存补丁",charIndex:3468}],headersStr:"暂存与取消暂存文件 暂存补丁",content:'# Git工具-交互式暂存\n\n本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 What now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nWhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 TODO 和 index.html 文件，可以输入数字：\n\nUpdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 TODO\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nUpdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update>> 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\n\nUpdate>>\nupdated 2 paths\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 r 或 3（撤消）选项：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nRevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** Commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nWhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nReview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ Date Finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\nGit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class SimpleGit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nStage this hunk [y,n,a,d,/,j,J,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nStage this hunk [y,n,a,d,/,j,J,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nJ - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nK - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nWhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 TODO\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',normalizedContent:'# git工具-交互式暂存\n\n本节中的几个交互式 git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 --interactive 选项，git 将会进入一个交互式终端模式，显示类似下面的东西：\n\n$ git add -i\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n\n在这块区域后是“commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。\n\n\n# 暂存与取消暂存文件\n\n如果在 what now> 提示符后键入 u 或 2（更新），它会问你想要暂存哪个文件：\n\nwhat now> u\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n要暂存 todo 和 index.html 文件，可以输入数字：\n\nupdate>> 1,2\n           staged     unstaged path\n* 1:    unchanged        +0/-1 todo\n* 2:    unchanged        +1/-1 index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nupdate>>\n\n\n1\n2\n3\n4\n5\n6\n\n\n每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 update>> 提示符后不输入任何东西并直接按回车，git 将会暂存之前选择的文件：\n\nupdate>>\nupdated 2 paths\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n现在可以看到 todo 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 todo 文件，使用 r 或 3（撤消）选项：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> r\n           staged     unstaged path\n  1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> 1\n           staged     unstaged path\n* 1:        +0/-1      nothing todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\nrevert>> [enter]\nreverted one path\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n再次查看 git 状态，可以看到已经取消暂存 todo 文件：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> s\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:    unchanged        +5/-1 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n如果想要查看已暂存内容的区别，可以使用 d 或 6（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff --cached 非常相似：\n\n*** commands ***\n  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked\n  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp\nwhat now> d\n           staged     unstaged path\n  1:        +1/-1      nothing index.html\nreview diff>> 1\ndiff --git a/index.html b/index.html\nindex 4d07108..4335f49 100644\n--- a/index.html\n+++ b/index.html\n@@ -16,7 +16,7 @@ date finder\n\n <p id="out">...</p>\n\n-<div id="footer">contact : support@github.com</div>\n+<div id="footer">contact : email.support@github.com</div>\n\n <script type="text/javascript">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n\n\n# 暂存补丁\n\ngit 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 p 或 5（补丁）。 git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n\ndiff --git a/lib/simplegit.rb b/lib/simplegit.rb\nindex dd5ecc4..57399e0 100644\n--- a/lib/simplegit.rb\n+++ b/lib/simplegit.rb\n@@ -22,7 +22,7 @@ class simplegit\n   end\n\n   def log(treeish = \'master\')\n-    command("git log -n 25 #{treeish}")\n+    command("git log -n 30 #{treeish}")\n   end\n\n   def blame(path)\nstage this hunk [y,n,a,d,/,j,j,g,e,?]?\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n\nstage this hunk [y,n,a,d,/,j,j,g,e,?]? ?\ny - stage this hunk\nn - do not stage this hunk\na - stage this and all the remaining hunks in the file\nd - do not stage this hunk nor any of the remaining hunks in the file\ng - select a hunk to go to\n/ - search for a hunk matching the given regex\nj - leave this hunk undecided, see next undecided hunk\nj - leave this hunk undecided, see next hunk\nk - leave this hunk undecided, see previous undecided hunk\nk - leave this hunk undecided, see previous hunk\ns - split the current hunk into smaller hunks\ne - manually edit the current hunk\n? - print help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n\nwhat now> 1\n           staged     unstaged path\n  1:    unchanged        +0/-1 todo\n  2:        +1/-1      nothing index.html\n  3:        +1/-1        +4/-0 lib/simplegit.rb\n\n\n1\n2\n3\n4\n5\n\n\nsimplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n\n也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 git add -p 或 git add --patch 来启动同样的脚本。\n\n更进一步地，可以使用 git reset --patch 命令的补丁模式来部分重置文件， 通过 git checkout --patch 命令来部分检出文件与 git stash save --patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。',charsets:{cjk:!0},lastUpdated:"2022/04/28, 18:33:51",lastUpdatedTimestamp:1651142031e3},{title:"java基础",frontmatter:{title:"java基础",date:"2022-04-28T16:29:28.000Z",permalink:"/pages/5aa878/",categories:["知识整理"],tags:["java基础"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/01.java%E5%9F%BA%E7%A1%80.html",relativePath:"知识整理/01.java基础.md",key:"v-48ab307b",path:"/pages/5aa878/",headers:[{level:2,title:"0、常见系统问题",slug:"_0、常见系统问题",normalizedTitle:"0、常见系统问题",charIndex:13},{level:2,title:"1、基础",slug:"_1、基础",normalizedTitle:"1、基础",charIndex:251},{level:3,title:"1.1 理论概念",slug:"_1-1-理论概念",normalizedTitle:"1.1 理论概念",charIndex:260},{level:4,title:"1.1.1 面向对象设计原则",slug:"_1-1-1-面向对象设计原则",normalizedTitle:"1.1.1 面向对象设计原则",charIndex:272},{level:3,title:"1.2 常见基础题",slug:"_1-2-常见基础题",normalizedTitle:"1.2 常见基础题",charIndex:668},{level:4,title:"1.2.1 equals和==区别？",slug:"_1-2-1-equals和-区别",normalizedTitle:"1.2.1 equals和==区别？",charIndex:681},{level:4,title:"1.2.2 java抽象类？",slug:"_1-2-2-java抽象类",normalizedTitle:"1.2.2 java抽象类？",charIndex:996},{level:4,title:"1.2.3 深拷贝和浅拷贝的区别？",slug:"_1-2-3-深拷贝和浅拷贝的区别",normalizedTitle:"1.2.3 深拷贝和浅拷贝的区别？",charIndex:1153},{level:4,title:"1.2.4 java是值传递还是引用传递？",slug:"_1-2-4-java是值传递还是引用传递",normalizedTitle:"1.2.4 java是值传递还是引用传递？",charIndex:1261},{level:4,title:"1.2.5 为什么重写equals还要重写hashcode？",slug:"_1-2-5-为什么重写equals还要重写hashcode",normalizedTitle:"1.2.5 为什么重写equals还要重写hashcode？",charIndex:1360},{level:4,title:"1.2.6 为什么notify(), wait()等函数定义在Object中，而不是Thread中？",slug:"_1-2-6-为什么notify-wait-等函数定义在object中-而不是thread中",normalizedTitle:"1.2.6 为什么notify(), wait()等函数定义在object中，而不是thread中？",charIndex:1524},{level:4,title:"1.2.7 Java中的object九大方法？",slug:"_1-2-7-java中的object九大方法",normalizedTitle:"1.2.7 java中的object九大方法？",charIndex:1613},{level:4,title:"1.2.8 Aspectj与Spring AOP比较？",slug:"_1-2-8-aspectj与spring-aop比较",normalizedTitle:"1.2.8 aspectj与spring aop比较？",charIndex:2164},{level:4,title:"1.2.9 sleep()方法和wait()方法区别和共同点?",slug:"_1-2-9-sleep-方法和wait-方法区别和共同点",normalizedTitle:"1.2.9 sleep()方法和wait()方法区别和共同点?",charIndex:2472},{level:3,title:"1.3 ThreadLocal",slug:"_1-3-threadlocal",normalizedTitle:"1.3 threadlocal",charIndex:2751},{level:4,title:"1.3.1 弱引用",slug:"_1-3-1-弱引用",normalizedTitle:"1.3.1 弱引用",charIndex:2770},{level:5,title:"1.3.1.1 为什么使用弱引用？",slug:"_1-3-1-1-为什么使用弱引用",normalizedTitle:"1.3.1.1 为什么使用弱引用？",charIndex:2783},{level:5,title:"1.3.1.2 如何使用弱引用？",slug:"_1-3-1-2-如何使用弱引用",normalizedTitle:"1.3.1.2 如何使用弱引用？",charIndex:3289},{level:5,title:"1.3.1.3 什么是弱引用？",slug:"_1-3-1-3-什么是弱引用",normalizedTitle:"1.3.1.3 什么是弱引用？",charIndex:3619},{level:5,title:"1.3.1.4 强引用、软引用、虚引用",slug:"_1-3-1-4-强引用、软引用、虚引用",normalizedTitle:"1.3.1.4 强引用、软引用、虚引用",charIndex:3972},{level:4,title:"1.3.2 什么是ThreadLocal？",slug:"_1-3-2-什么是threadlocal",normalizedTitle:"1.3.2 什么是threadlocal？",charIndex:4420},{level:4,title:"1.3.3 Spring如何处理bean多线程下的并发问题？",slug:"_1-3-3-spring如何处理bean多线程下的并发问题",normalizedTitle:"1.3.3 spring如何处理bean多线程下的并发问题？",charIndex:4694},{level:4,title:"1.3.4 Spring如何保证数据库事务在同一个连接下执行？",slug:"_1-3-4-spring如何保证数据库事务在同一个连接下执行",normalizedTitle:"1.3.4 spring如何保证数据库事务在同一个连接下执行？",charIndex:4843},{level:4,title:"1.3.5 Thread,ThreadLocalMap,ThreadLocal三者的逻辑关系？",slug:"_1-3-5-thread-threadlocalmap-threadlocal三者的逻辑关系",normalizedTitle:"1.3.5 thread,threadlocalmap,threadlocal三者的逻辑关系？",charIndex:5022},{level:4,title:"1.3.6 ThreadLocalMap底层结构是什么？",slug:"_1-3-6-threadlocalmap底层结构是什么",normalizedTitle:"1.3.6 threadlocalmap底层结构是什么？",charIndex:5153},{level:4,title:"1.3.7 ThreadLocal为什么可能发生内存泄漏？",slug:"_1-3-7-threadlocal为什么可能发生内存泄漏",normalizedTitle:"1.3.7 threadlocal为什么可能发生内存泄漏？",charIndex:5493},{level:4,title:"1.3.8 ThreadLocal如何避免内存泄露？",slug:"_1-3-8-threadlocal如何避免内存泄露",normalizedTitle:"1.3.8 threadlocal如何避免内存泄露？",charIndex:5803},{level:3,title:"1.4 volatile",slug:"_1-4-volatile",normalizedTitle:"1.4 volatile",charIndex:5864},{level:4,title:"1.4.1 说说你对volatile关键字的理解？",slug:"_1-4-1-说说你对volatile关键字的理解",normalizedTitle:"1.4.1 说说你对volatile关键字的理解？",charIndex:5880},{level:4,title:"1.4.2 详细说一下什么是内存可见性？",slug:"_1-4-2-详细说一下什么是内存可见性",normalizedTitle:"1.4.2 详细说一下什么是内存可见性？",charIndex:5972},{level:4,title:"1.4.3 说一下什么是指令重排序？",slug:"_1-4-3-说一下什么是指令重排序",normalizedTitle:"1.4.3 说一下什么是指令重排序？",charIndex:6653},{level:2,title:"2、数据结构",slug:"_2、数据结构",normalizedTitle:"2、数据结构",charIndex:7427},{level:3,title:"2.1 数组和链表区别？",slug:"_2-1-数组和链表区别",normalizedTitle:"2.1 数组和链表区别？",charIndex:7438},{level:3,title:"2.2 HashMap的数据结构？默认初试容量和负载因子是多少？",slug:"_2-2-hashmap的数据结构-默认初试容量和负载因子是多少",normalizedTitle:"2.2 hashmap的数据结构？默认初试容量和负载因子是多少？",charIndex:7613},{level:3,title:"2.3 hashmap的数组长度为什么要保证是2的幂？",slug:"_2-3-hashmap的数组长度为什么要保证是2的幂",normalizedTitle:"2.3 hashmap的数组长度为什么要保证是2的幂？",charIndex:7717},{level:3,title:"2.4 hashmap的扩容？",slug:"_2-4-hashmap的扩容",normalizedTitle:"2.4 hashmap的扩容？",charIndex:7946},{level:3,title:"2.5 能讲一下ConcurrentHashMap？",slug:"_2-5-能讲一下concurrenthashmap",normalizedTitle:"2.5 能讲一下concurrenthashmap？",charIndex:8047},{level:3,title:"2.6 ConcurrentHashMap 1.7 与 1.8 区别?",slug:"_2-6-concurrenthashmap-1-7-与-1-8-区别",normalizedTitle:"2.6 concurrenthashmap 1.7 与 1.8 区别?",charIndex:8192},{level:2,title:"3、并发加锁",slug:"_3、并发加锁",normalizedTitle:"3、并发加锁",charIndex:8374},{level:3,title:"3.1 Synchronized",slug:"_3-1-synchronized",normalizedTitle:"3.1 synchronized",charIndex:8385},{level:4,title:"3.1.1 CAS与Synchronized的区别？",slug:"_3-1-1-cas与synchronized的区别",normalizedTitle:"3.1.1 cas与synchronized的区别？",charIndex:8405},{level:4,title:"3.1.2 synchronized的加锁方式",slug:"_3-1-2-synchronized的加锁方式",normalizedTitle:"3.1.2 synchronized的加锁方式",charIndex:9626},{level:4,title:"3.1.3 new Object(); 占多少字节？ 16",slug:"_3-1-3-new-object-占多少字节-16",normalizedTitle:"3.1.3 new object(); 占多少字节？ 16",charIndex:9655},{level:4,title:"3.1.4 关于无锁偏向锁轻量级锁重量级锁的理解误区",slug:"_3-1-4-关于无锁偏向锁轻量级锁重量级锁的理解误区",normalizedTitle:"3.1.4 关于无锁偏向锁轻量级锁重量级锁的理解误区",charIndex:9826},{level:4,title:"3.1.5 锁状态转换流程",slug:"_3-1-5-锁状态转换流程",normalizedTitle:"3.1.5 锁状态转换流程",charIndex:9970},{level:3,title:"3.2 AQS",slug:"_3-2-aqs",normalizedTitle:"3.2 aqs",charIndex:9990},{level:4,title:"3.2.1 聊聊你对AQS的理解？",slug:"_3-2-1-聊聊你对aqs的理解",normalizedTitle:"3.2.1 聊聊你对aqs的理解？",charIndex:10001},{level:4,title:"3.2.2 synchronized和ReentrantLock的区别？",slug:"_3-2-2-synchronized和reentrantlock的区别",normalizedTitle:"3.2.2 synchronized和reentrantlock的区别？",charIndex:10878},{level:4,title:"3.2.3 AQS定义的两种队列？",slug:"_3-2-3-aqs定义的两种队列",normalizedTitle:"3.2.3 aqs定义的两种队列？",charIndex:11270},{level:3,title:"3.3 死锁",slug:"_3-3-死锁",normalizedTitle:"3.3 死锁",charIndex:11406},{level:4,title:"3.3.1 什么是死锁？",slug:"_3-3-1-什么是死锁",normalizedTitle:"3.3.1 什么是死锁？",charIndex:11416},{level:4,title:"3.3.2 死锁产生的必要条件？",slug:"_3-3-2-死锁产生的必要条件",normalizedTitle:"3.3.2 死锁产生的必要条件？",charIndex:11489},{level:4,title:"3.3.3 怎么预防死锁？",slug:"_3-3-3-怎么预防死锁",normalizedTitle:"3.3.3 怎么预防死锁？",charIndex:11656},{level:2,title:"4、多线程",slug:"_4、多线程",normalizedTitle:"4、多线程",charIndex:11805},{level:3,title:"4.1 线程的生命周期？",slug:"_4-1-线程的生命周期",normalizedTitle:"4.1 线程的生命周期？",charIndex:11815},{level:3,title:"4.2 线程池有哪些核心参数？",slug:"_4-2-线程池有哪些核心参数",normalizedTitle:"4.2 线程池有哪些核心参数？",charIndex:12345},{level:3,title:"4.3 线程池的执行流程？",slug:"_4-3-线程池的执行流程",normalizedTitle:"4.3 线程池的执行流程？",charIndex:13055},{level:3,title:"4.4 线程池的拒绝策略有哪几种？",slug:"_4-4-线程池的拒绝策略有哪几种",normalizedTitle:"4.4 线程池的拒绝策略有哪几种？",charIndex:13476},{level:3,title:"4.5 线程池的核心线程与最大线程数大小设置多少合适？",slug:"_4-5-线程池的核心线程与最大线程数大小设置多少合适",normalizedTitle:"4.5 线程池的核心线程与最大线程数大小设置多少合适？",charIndex:13765},{level:3,title:"4.6 多线程并行执行，然后汇总结果返回怎么实现？",slug:"_4-6-多线程并行执行-然后汇总结果返回怎么实现",normalizedTitle:"4.6 多线程并行执行，然后汇总结果返回怎么实现？",charIndex:13930}],headersStr:"0、常见系统问题 1、基础 1.1 理论概念 1.1.1 面向对象设计原则 1.2 常见基础题 1.2.1 equals和==区别？ 1.2.2 java抽象类？ 1.2.3 深拷贝和浅拷贝的区别？ 1.2.4 java是值传递还是引用传递？ 1.2.5 为什么重写equals还要重写hashcode？ 1.2.6 为什么notify(), wait()等函数定义在Object中，而不是Thread中？ 1.2.7 Java中的object九大方法？ 1.2.8 Aspectj与Spring AOP比较？ 1.2.9 sleep()方法和wait()方法区别和共同点? 1.3 ThreadLocal 1.3.1 弱引用 1.3.1.1 为什么使用弱引用？ 1.3.1.2 如何使用弱引用？ 1.3.1.3 什么是弱引用？ 1.3.1.4 强引用、软引用、虚引用 1.3.2 什么是ThreadLocal？ 1.3.3 Spring如何处理bean多线程下的并发问题？ 1.3.4 Spring如何保证数据库事务在同一个连接下执行？ 1.3.5 Thread,ThreadLocalMap,ThreadLocal三者的逻辑关系？ 1.3.6 ThreadLocalMap底层结构是什么？ 1.3.7 ThreadLocal为什么可能发生内存泄漏？ 1.3.8 ThreadLocal如何避免内存泄露？ 1.4 volatile 1.4.1 说说你对volatile关键字的理解？ 1.4.2 详细说一下什么是内存可见性？ 1.4.3 说一下什么是指令重排序？ 2、数据结构 2.1 数组和链表区别？ 2.2 HashMap的数据结构？默认初试容量和负载因子是多少？ 2.3 hashmap的数组长度为什么要保证是2的幂？ 2.4 hashmap的扩容？ 2.5 能讲一下ConcurrentHashMap？ 2.6 ConcurrentHashMap 1.7 与 1.8 区别? 3、并发加锁 3.1 Synchronized 3.1.1 CAS与Synchronized的区别？ 3.1.2 synchronized的加锁方式 3.1.3 new Object(); 占多少字节？ 16 3.1.4 关于无锁偏向锁轻量级锁重量级锁的理解误区 3.1.5 锁状态转换流程 3.2 AQS 3.2.1 聊聊你对AQS的理解？ 3.2.2 synchronized和ReentrantLock的区别？ 3.2.3 AQS定义的两种队列？ 3.3 死锁 3.3.1 什么是死锁？ 3.3.2 死锁产生的必要条件？ 3.3.3 怎么预防死锁？ 4、多线程 4.1 线程的生命周期？ 4.2 线程池有哪些核心参数？ 4.3 线程池的执行流程？ 4.4 线程池的拒绝策略有哪几种？ 4.5 线程池的核心线程与最大线程数大小设置多少合适？ 4.6 多线程并行执行，然后汇总结果返回怎么实现？",content:"# Java基础\n\n\n# 0、常见系统问题\n\n0.1 在生产环境 Linux 服务器上，发现某台运行 Java 服务的服务器的 CPU100%，不借助任何可视化工具，怎么进行问题的定位?\n\n1.top 找出进程 CPU 比较高 PID\n\n2.top -Hp PID 打印 该 PID 进程下哪条线程的 CPU 占用比较高 tid\n\n3.printf “%x\\n” tid 将该 id 进行 16 进制转换 tidhex\n\n4.jstack PID |grep tidhex 打印线程的堆栈信息\n\n\n# 1、基础\n\n\n# 1.1 理论概念\n\n# 1.1.1 面向对象设计原则\n\n开闭原则：\n\n对扩展开放，对修改关闭。\n极端要求就是：程序完成后，除非是修改错误，不然不能修改代码，只能扩展代码。\n依赖导致原则：\n\n调用者（客户代码）不依赖于被调用者（实现代码）的实现细节，而是依赖其抽象\n调用者不依赖被调用者的具体实现，而是依赖被调用者的抽象，这样被调用者后续可以被无感替换掉。\n单一职责原则：\n\n一个类，最好只做一件事，只有一个引起它的变化。\n接口隔离原则：\n\n使用多个小的专门的接口，而不要使用一个大的总接口。\n\n最少知道原则：\n\n一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n合成复用原则：\n\n原则是尽量使用合成/聚合的方式，而不是使用继承。\n里氏替换原则：\n\n子类必须能够替换其基类。\n\n类B继承类A时，除添加新的方法完成新增功能P2外，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。\n\n\n# 1.2 常见基础题\n\n# 1.2.1 equals和==区别？\n\n首先明确一点，equals是方法，==是操作符。\n\n1. 如果比较的是基本数据类型：\n\n只讨论==，因为equals是不存在的，因为java中基本数据类型不能调用method的。\n\n2. 如果比较的是引用类型：\n\n**==：**比较两个引用是不是指向同一个对象实例，即相同的地址。\n\n**equals：**equals方法是Object类的方法，默认是直接调用==来实现。如果没有被重写，那么调用equals与==没有区别。但是，在一些类库中这个方法被覆盖了，比如八大基本数据类型的包装类和String类，它们的equals方法比较的是值是否相同，此时equals就与==有区别了。\n\n# 1.2.2 java抽象类？\n\n1.抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n2.由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。\n\n3.在Java中抽象类表示的是继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n# 1.2.3 深拷贝和浅拷贝的区别？\n\n拷贝针对的是引用对象的拷贝。\n\n浅拷贝只复制指向某个对象的引用，不复制内存本身，新旧对象还是共享同一块内存。\n\n深拷贝会复制一个一模一样的对象，新对象跟原对象不共享内存。\n\n# 1.2.4 java是值传递还是引用传递？\n\n形式参数为基本数据类型的，就是值传递，如果为引用数据类型就是引用传递。\n\nJava中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。\n\n# 1.2.5 为什么重写equals还要重写hashcode？\n\n如：重写一个自定义类的equals可以实现我们的意图，即这两个类判断为相等，但它们的hashcode是不同的。\n\n如果我们用hashset去add的时候，由于底层是通过hashcode判断是不是同一对象，这个时候不重写hashcode就会被判断成不同对象。\n\n# 1.2.6 为什么notify(), wait()等函数定义在Object中，而不是Thread中？\n\n锁可以是任意对象，所以任意对象调用方法一定定义在Object类中。\n\n# 1.2.7 Java中的object九大方法？\n\nprotected Object clone() 创建并返回此对象的一个副本。\n\nboolean equals(Object obj) 指示某个其他对象是否与此对象“相等”。\n\nprotected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\n\nClass<? extendsObject> getClass() 返回一个对象的运行时类。\n\nint hashCode() 返回该对象的哈希码值。\n\nvoid notify() 唤醒在此对象监视器上等待的单个线程。\n\nvoid notifyAll() 唤醒在此对象监视器上等待的所有线程。\n\nString toString() 返回该对象的字符串表示。\n\nvoid wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyAll() 方法。\n\nvoid wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或\n\nvoid wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()\n\n# 1.2.8 Aspectj与Spring AOP比较？\n\n1.AspectJ使用编译时和class文件加载时织入时，Spring AOP利用运行时织入。\n\n2.Spring aop是基于代理的aop框架。这意味着, 要实现目标对象的各个方面, 它将创建该对象的代理。\n\n使用以下两种方法之一实现:\n\n1）JDK 动态代理 —— Spring AOP 的首选方式。只要目标对象实现甚至一个接口, 就会使用 JDK 动态代理；\n\n2）CGLIB 代理 —— 如果目标对象没有实现接口, 则可以使用 CGLIB 代理。\n\n3. AspectJ在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的。\n\n\n\n# 1.2.9 sleep()方法和wait()方法区别和共同点?\n\n1.两者最主要的区别在于：**sleep() 方法没有释放锁，而 wait() 方法释放了锁** 。\n\n2.两者都可以暂停线程的执行。\n\n3.wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。\n\n4.wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n\n# 1.3 ThreadLocal\n\n# 1.3.1 弱引用\n\n# 1.3.1.1 为什么使用弱引用？\n\n考虑下面的场景：\n\n有一个Product类代表一种产品，这个类被设计为不可扩展的，此时我们想要为每个产品增加一个编号。\n\n一种解决方案是使用HashMap<Product, Integer>。\n\n于是问题来了，如果我们已经不再需要一个Product对象存在于内存中（比如已经卖出了这件产品），假设指向它的引用为productA，我们这时会给productA赋值为null，然而这时productA过去指向的Product对象并不会被回收，因为它显然还被HashMap引用着。\n\n所以这种情况下，我们想要真正的回收一个Product对象，仅仅把它的强引用赋值为null是不够的，还要把相应的条目从HashMap中移除。\n\n显然“从HashMap中移除不再需要的条目”这个工作我们不想自己完成，我们希望告诉垃圾收集器：在只有HashMap中的key在引用着Product对象的情况下，就可以回收相应Product对象了。\n\n根据前面弱引用的定义，使用弱引用能帮助我们达成这个目的。我们只需要用一个指向Product对象的弱引用对象来作为HashMap中的key就可以了。\n\n# 1.3.1.2 如何使用弱引用？\n\n拿上面介绍的场景举例，我们使用一个指向Product对象的弱引用对象来作为HashMap的key，只需这样定义这个弱引用对象：\n\nProduct productA = new Product(...);\n\nWeakReference<Product> weakProductA = new WeakReference<>(productA);\n\n若引用对象weakProductA就指向了Product对象productA。我们怎么通过weakProduct获取它所指向的Product对象productA呢？很简单，只需要下面这句代码：\n\nProduct product = weakProductA.get();\n\n# 1.3.1.3 什么是弱引用？\n\nJava中的弱引用具体指的是java.lang.ref.WeakReference<T>类，我们首先来看一下官方文档对它做的说明：\n\n弱引用对象的存在不会阻止它所指向的对象被垃圾回收器回收。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。\n\n假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所指定的 引用队列(Reference Queue)中。\n\n# 1.3.1.4 强引用、软引用、虚引用\n\n实际上，Java中存在四种引用，它们由强到弱依次是：强引用、软引用、弱引用、虚引用。下面我们简单介绍下除弱引用外的其他三种引用：\n\n**强引用（Strong Reference）：**通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收。\n\n**软引用（Soft Reference）：**软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些。\n\n**虚引用（Phantom Reference）：**虚引用是Java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。\n\n# 1.3.2 什么是ThreadLocal？\n\n**ThreadLocal是线程局部变量。**这种变量在多线程的情况下访问时能保证各个线程变量相对独立于其他线程中的变量。ThreadLocal实例通常来说是private static类型的，用于关联线程和线程上下文。\n\nThread跟ThreadLocal什么关系：\n\nThread和ThreadLocal是绑定的， ThreadLocal依赖于Thread去执行， Thread将需要隔离的数据存放到ThreadLocal(准确的讲是ThreadLocalMap)中, 来实现多线程处理。\n\n# 1.3.3 Spring如何处理bean多线程下的并发问题？\n\nThreadLocal天生为解决相同变量的访问冲突问题， 所以这个对于spring的默认单例bean的多线程访问是一个完美的解决方案。\n\nSpring也确实是用了ThreadLocal来处理多线程下相同变量并发的线程安全问题。\n\n# 1.3.4 Spring如何保证数据库事务在同一个连接下执行？\n\nDataSourceTransactionManager 是spring的数据源事务管理器， 它会在你调用getConnection()的时候从数据库连接池中获取一个connection， 然后将其与ThreadLocal绑定， 事务完成后解除绑定。这样就保证了事务在同一连接下完成。\n\n# 1.3.5 Thread,ThreadLocalMap,ThreadLocal三者的逻辑关系？\n\n\n\n1.Thread实例和ThreadLocalMap实例是一对一的关系\n\n2.ThreadLocalMap实例和ThreadLocal实例是一对多的关系。\n\n# 1.3.6 ThreadLocalMap底层结构是什么？\n\nThreadLocal中的map数据结构和HashMap不同，它并没有实现Map接口，也不像HashMap一样通过链表来解决hash冲突！\n\n进阶问题：那么ThreadLocal是如何解决hash冲突呢？\n\n答：采用的开放地址法，不是hashmap的链地址法！\n\n\n\n**ThreadLocal是采用数组来存储的。**ThreadLocalMap在存储的时候会给每一个ThreadLocal对象一个threadLocalHashCode，在插入过程中，根据ThreadLocal对象的hash值，定位到table中的位置i，int i = key.threadLocalHashCode & (len-1)。\n\n\n\n# 1.3.7 ThreadLocal为什么可能发生内存泄漏？\n\n当使用ThreadLocal保存一个value时，会在ThreadLocalMap中的数组插入一个Entry对象，按理说key-value都应该以强引用保存在Entry对象中，但在ThreadLocalMap的实现中，key被保存到了WeakReference对象中（弱引用对象）。\n\n这就导致了一个问题：ThreadLocal在没有外部强引用时，发生GC时key会被回收，如果创建ThreadLocal的线程一直持续运行（线程池的情况，线程跑完后会回到线程池，并不会销毁），那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。\n\n# 1.3.8 ThreadLocal如何避免内存泄露？\n\n使用完ThreadLocal之后，调用remove方法。\n\n\n# 1.4 volatile\n\n# 1.4.1 说说你对volatile关键字的理解？\n\n被volatile修饰的共享变量具有2个特性。\n\n1.保证了不同线程之间操作该共享变量的内存可见性。\n\n2.禁止指令重排序\n\n# 1.4.2 详细说一下什么是内存可见性？\n\n1.4.2.1 Java内存模型\n\n关于内存可见性的话，要先提一下Java内存模型（JMM），Java虚拟机里面定义的一种抽象模型。\n\n根据JMM的设计，系统存在一个主内存(Main Memory)，Java中所有变量都储存在主存中，对于所有线程都是共享的。\n\n每条线程都有自己的工作内存(Working Memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。\n\n\n\n但是JMM这个主内存和工作内存跟JVM中的堆、栈内存实际上是没什么关系的。\n\n1.4.2.2 jvm和jmm之间的关系\n\njmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的。\n\n如果一定要勉强对应起来，jmm的主内存可以对应jvm堆中对象实例部分，jmm工作内存可以对应jvm虚拟机栈中的部分区域。\n\n从更低层次上说，主内存就直接对应于物理硬件的内存，\n\n而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。\n\n1.4.2.3 内存可见性\n\nvolatile保证了变量的可见性主要是因为：\n\n1）线程更新volatile变量的时候，先去更新工作内存中这个变量的副本，然后再将改变后副本的值从工作内存刷新到主内存。\n\n2）线程读取volatile变量的时候，先去主内存中读取最新值到工作内存，然后再从工作内存中读取。\n\n# 1.4.3 说一下什么是指令重排序？\n\n1.4.3.1 指令重排序\n\n重排序是指编译器和处理为了优化程序性能而对指令序列进行重新排序的一种手段。\n如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重新排序。\n\n\n\n1.4.3.2 happens-before（先行发生原则）\n\nJava内存模型中会默认保证一定的有序性，就是happens-before规则，指令重排序需要遵循这个规则。\n\n如果2个操作的执行顺序无法重happens-before规则中推导出来，就不能保证他们的有序性，jvm就可能对他们进行重排序。\n\nhappens-before主要有以下几条规则：\n\n1.程序次序规则： 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。（保证单线程的执行结果是正确的，对于无关紧要的重排序是允许的。）\n\n2.锁定规则： 一个unLock操作先行发生于后面对同一个锁的lock操作。\n\n3.volatile变量规则： 对一个变量的写操作先行发生与后面对这个变量的读操作。\n\n4.传递规则： 如果操作A先行发生于操作B，而操作B又先发生于操作C，则可以得出操作A先行发生于操作C。\n\n前四条规则是比较重要的，后四条是比较显而易见的。\n\n1.线程启动规则： Thread对象的start()方法先行发生于此线程的每一个动作\n\n2.线程中断规则： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。\n\n3.线程终结规则： 线程中所有的操作都先行发生于线程的终止检测,我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行。\n\n4.对象终结规则： 一个对象的初始化完成先行发生于他的finalize()方法的开始。\n\n\n# 2、数据结构\n\n\n# 2.1 数组和链表区别？\n\n1.链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。\n\n2.链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难。\n\n3.数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。\n\n\n# 2.2 HashMap的数据结构？默认初试容量和负载因子是多少？\n\n1.数组+链表，链表长度大于8时接红黑树。\n\n2.初始容量（16）和负载因子（0.75）（负载因子就是指填充到多少开始扩大容量）。\n\n\n# 2.3 hashmap的数组长度为什么要保证是2的幂？\n\n在HashMap中通过利用key的hashcode值,来进行位运算\n\n公式:index = e.hash & (newCap - 1)\n\nlength - 1的值是所有二进制位全为1,这种情况下,index的结果等同于hashcode后几位的值\n\n只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的。\n\n所以,HashMap的默认长度为16,是为了降低hash碰撞的几率。\n\n\n# 2.4 hashmap的扩容？\n\nrehash：当Map中的元素大于数组长度的75%时，就会进行扩容，JDK1.7之前扩容时很有可能会造成环链，后续get时则可能会变成死循环，线程不安全。\n\n\n\n\n# 2.5 能讲一下ConcurrentHashMap？\n\nJDK1.7中ConcurrentHashMap采用分段锁，分成16个小的hashMap，锁定当前的小hashMap其他\n\nhashMap不受影响。JDK1.8之后不再采取分段锁，主要采用CAS原子指令实现无锁的高并发操作。\n\n\n# 2.6 ConcurrentHashMap 1.7 与 1.8 区别?\n\n1.JDK1.8 采用 synchronized 代替可重入锁 ReentrantLock。\n\n2.JDK1.8 取消了 Segment 分段锁的数据结构，使用数组+链表+红黑树的结构代替。\n\n3.JDK1.8 对每个数组元素加锁，1.7 对要操作的 Segment 数据段加锁。\n\n\n# 3、并发加锁\n\n\n# 3.1 Synchronized\n\n# 3.1.1 CAS与Synchronized的区别？\n\n1）CAS 是 compare and swap 的缩写，即我们所说的比较交换。\n\ncas 是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。\n\n悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。\n\n而乐观锁采取了 一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据， 性能较悲观锁有很大的提高。\n\nCAS 操作包含三个操作数：内存位置(V)、旧值(A)和新值(B)。如果内存地址里面的值和 A 的值是一样的，那么就将内存里面的值更新成 B。\n\nCAS 是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。\n\njava.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的 (AtomicInteger,AtomicBoolean,AtomicLong)。\n\nCAS存在的问题：\n\n1.1）ABA问题：一个线程把值从A改为B再改回A，另一个线程不知道这个过程。\n\n解决方案：使用版本号，每次修改数据时带上一个版本号。\n\n1.2）循环开销大：CAS通过自旋获取锁，当一直获取不到锁时，会不断空循环。\n\n1.3）不能保证代码块的原子性\n\nCAS 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。\n\n2）Synchronized：悲观锁。\n\nsynchronized主要解决的是多个线程之间的同步问题，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\njdk1.6之前性能较差，主要基于Monitor机制实现，依赖底层操作系统的互斥原语Mutex。线程之间的切换需要操作系统从用户态转换到内核态进行，时间成本很高。jdk1.6之后做了优化，锁分成了4种状态，分别是无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。\n\n\n\n偏向锁：针对没有锁竞争的场合。jvm启动之后默认有4s的延迟，对每个新建的对象都开启偏向锁模式，在这之前新建的都是无锁状态。（可通过配置调整）\n\n\n\n轻量级锁：出现的场景是线程交替执行同步块。通过CAS获取锁（没有自旋），失败膨胀成重量级锁。\n\nA线程执行完加锁模块，线程还没结束，此时B线程去加锁（发现加不了偏向锁：A线程还在执行），升级为轻量级锁。轻量级锁解锁后后直接到无锁状态。（同样，重量级锁解锁的时候也只会到无锁状态。重量级锁解锁时是GC的时候才清掉标识，较慢，可睡眠一两秒后再看。）\n\n重量级锁：出现场景：竞争激烈的情况（A线程的锁还没释放，B线程也去加锁）。去内核态操作前，会先尝试自旋CAS获取锁。\n\n# 3.1.2 synchronized的加锁方式\n\n\n\n# 3.1.3 new Object(); 占多少字节？ 16\n\n对象在内存中存储的布局可以分为三块区域:\n\n对象头(Header)\n\n实例数据 (Instance Data)\n\n对齐填充(Padding)\n\n\n\nMark Word：8字节\n\nMetaData：4字节\n\n数组长度：4字节\n\n长度必须是8的倍数，不够则用“对齐填充”补齐。\n\n# 3.1.4 关于无锁偏向锁轻量级锁重量级锁的理解误区\n\n1. 无锁 --\x3e 偏向锁 --\x3e 轻量级锁 --\x3e 重量级锁。 （不存在无锁 --\x3e 偏向锁）\n\n2. 轻量级锁自旋获取锁失败，会膨胀成重量级锁。 （轻量级锁不存在自旋）\n\n3. 重量级锁不存在自旋。 （重量级锁存在自旋）\n\n# 3.1.5 锁状态转换流程\n\n\n\n\n# 3.2 AQS\n\n# 3.2.1 聊聊你对AQS的理解？\n\nAbstractQueuedSynchronizer，抽象队列同步器\n\nAQS它是JUC（java.util.concurrent）包中多个组件的底层实现。比如像ReentrantLock、Semaphore、CountDownLatch都用到了AQS。\n\nAQS提供了2种锁机制，分别是独占锁和共享锁。\n\n所谓独占锁就是存在多个线程去竞争同一共享资源的时候，同一个时刻，只允许一个线程去访问这个共享资源。也就是多个线程，只有一个能获取锁。比如ReentrantLock就是独占锁。\n\n共享锁就是在同一时刻允许多个线程去获取锁。比如CountDownLatch、Semaphore。\n\n然后，关于AQS的设计，它有几个核心的东西：\n\nAQS对象里面有一个int类型变量：state，代表了加锁状态。独占锁初始状态下是0\n\n还有一个关键变量：加锁线程，用来记录当前加锁的是那个线程。初始状态下是null\n\n另外AQS内部还有一个等待队列，用来专门存放加锁失败的线程。\n\n关于独占锁加锁和释放锁过程：\n\n1.线程过来加锁，通过cas的方式把state从0变成1，同时把“加锁线程”设置成自己。\n\n2.如果加锁的时候发现state不是0，会判断一下“加锁线程”是不是自己，是自己的话state累加，不是的话则加锁失败。\n\n3.加锁失败的会将自己放入同步队列中等待，等其他线程释放锁之后，自己再重新尝试加锁。\n\n4.加锁的线程在执行完自己的业务逻辑代码后释放锁，释放锁会将state变量减1，当state变量为0，则会彻底释放锁，同时把“加锁线程”这个变量设置成null。\n\n5.彻底释放锁后，会从同步队列的队头唤醒线程尝试加锁。\n\n还有一个点：公平锁与非公平锁，AQS支持公平和非公平锁：\n\nAQS的处理方式是：在竞争锁资源的时候，公平锁需要去判断同步等待队列中时候有阻塞的线程，如果有则需要去排队等待。而非公平锁的处理方式是，不管同步等待队列中是否有阻塞线程，它都会直接去尝试更改互斥变量“state”去竞争锁。\n\n# 3.2.2 synchronized和ReentrantLock的区别？\n\n1.synchronized是JVM层次的锁实现，ReentrantLock是JDK层次的锁实现。\n\n2.synchronized的锁状态无法在代码中直接判断，但ReentrantLock可以通过#isLocked判断。\n\n3.synchronized是非公平锁，ReentrantLock是可以是公平也可以是非公平的。\n\n4.synchronized是不可以被中断的，而ReentrantLock#lockInterruptibly方法是可以被中断的。\n\n5.发生异常时synchronized会自动释放锁，而ReentrantLock需要开发者在finally块中显示释放锁。\n\n6.ReentrantLock获取锁的形式有多种:立即返回是否成功的tryLock(),等待指定时长的获取，更灵活;\n\n# 3.2.3 AQS定义的两种队列？\n\n同步等待队列:\n\n主要用于维护获取锁失败时入队的线程。\n\n条件等待队列:\n\n调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal()唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁。\n\n\n# 3.3 死锁\n\n# 3.3.1 什么是死锁？\n\n死锁是指两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞现象，若无外力作用，它们将无法推进下去。\n\n# 3.3.2 死锁产生的必要条件？\n\n1.互斥条件：即在一段时间内某一资源仅能一个线程占用\n\n2.占有且等待条件：当线程因为请求资源而阻塞的时候，对已经获得的资源保持不放。\n\n3.不可剥夺条件：线程对获得的资源为使用完成之前，不能被剥夺，只能使用完时由自己释放。\n\n4.循环等待条件：发生死锁时，必然存在一个进程和资源的环形链。\n\n# 3.3.3 怎么预防死锁？\n\n互斥条件无法被破坏，锁本身就是通过互斥来解决线程安全问题。\n\n1.资源一次性分配（破坏占用且等待的条件）\n\n2.可剥夺资源：进程已经获得部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）\n\n3.资源有序分配：按顺序请求资源（破坏循环等待条件）\n\n\n# 4、多线程\n\n\n# 4.1 线程的生命周期？\n\n线程的生命周期主要包括了5种状态\n\nNEW新建、RUNNABLE就绪、RUNNING运行、BLOCKED阻塞、DEAD死亡。\n\n**NEW：**线程创建\n\n**RUNNABLE：**执行start方法\n\n**RUNNING：**分配到了CPU时间片，开始执行代码\n\nBLOCKED：\n\n• 等待阻塞：调用了o.wait()方法，该线程放入等待队列\n\n• 同步阻塞：获取对象锁时，锁被其他线程占用，该线程进入lock pool\n\n• 其他阻塞：sleep 或者 join方法时\n\n**DEAD：**线程执行完毕，或者抛出异常\n\n\n\n几个重要方法：\n\n**sleep()：**当前线程进入阻塞，但不释放对象锁。\n\n**yield()：**不会阻塞，让出cpu时间。\n\n**t.join()：**方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\n\n**obj.wait()：**当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyAll()唤醒。\n\n**obj.notify()：**唤醒任意在此对象监视器上等待的单个线程。\n\n\n# 4.2 线程池有哪些核心参数？\n\n1、int corePoolSize：核心池的大小。线程池的基本大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。\n\n这里需要注意的是：\n\n在创建ThreadPoolExecutor的时候，线程不会立即启动，要等到有任务提交时才启动，除非调用prestartCoreThread/prestartAllCoreThreads事先启动核心线程。\n\n再考虑到keepAliveTime和allowCoreThreadTimeOut超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corePoolSize。\n\n2、int maximumPoolSize：线程池最大线程数，它表示在线程池中最多能创建多少个线程。\n\n线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。\n\n如果队列中任务已满，并且当前线程个数小于maximumPoolSize，那么会创建新的线程来执行任务。\n\n3、long keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止。\n\n4、TimeUnit unit：参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性。\n\n5、BlockingQueue<Runnable> workQueue：一个阻塞队列，用来存储等待执行的任务。无界、有界、优先级、无缓冲区队列\n\n6、ThreadFactory threadFactory：线程工厂，主要用来创建线程。\n\n7、RejectedExecutionHandler handler：拒绝策略，表示当拒绝处理任务时的策略。\n\n\n# 4.3 线程池的执行流程？\n\n1、如果当前线程池中的线程数目小于corePoolSize，则来一个任务，就创建一个线程去执行这个任务。\n\n2、如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务队列当中。\n\n若添加成功，则该任务会等待空闲线程将其取出去执行。\n\n若添加失败（一般来说是任务缓存队列已满），则尝试创建新的线程去执行这个任务maximumPoolSize。\n\n3、如果当前线程池中的线程数目达到maximumPoolSize（此时线程池的任务缓存队列已满），则会采取任务拒绝策略进行处理；\n\n4、线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；\n\n如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。\n\n\n# 4.4 线程池的拒绝策略有哪几种？\n\n任务拒绝策略，通常有以下四种策略：\n\n1）ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出RejectedExecutionException异常。\n\n2）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。\n\n3）ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务。\n\n4）ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务。\n\n\n# 4.5 线程池的核心线程与最大线程数大小设置多少合适？\n\n核心线程数：\n\nCPU密集型任务应配置尽可能小的线程，如配置NCPU+1个线程的线程池。\n\nIO密集型任务线程并不是一直在执行任务 ，则应配置尽可能多的线程，如2*NCPU 。\n\n最大线程数：\n\n最大线程数 = （最大任务数-队列容量）/每个线程每秒处理能力\n\n\n\n\n# 4.6 多线程并行执行，然后汇总结果返回怎么实现？\n\n",normalizedContent:"# java基础\n\n\n# 0、常见系统问题\n\n0.1 在生产环境 linux 服务器上，发现某台运行 java 服务的服务器的 cpu100%，不借助任何可视化工具，怎么进行问题的定位?\n\n1.top 找出进程 cpu 比较高 pid\n\n2.top -hp pid 打印 该 pid 进程下哪条线程的 cpu 占用比较高 tid\n\n3.printf “%x\\n” tid 将该 id 进行 16 进制转换 tidhex\n\n4.jstack pid |grep tidhex 打印线程的堆栈信息\n\n\n# 1、基础\n\n\n# 1.1 理论概念\n\n# 1.1.1 面向对象设计原则\n\n开闭原则：\n\n对扩展开放，对修改关闭。\n极端要求就是：程序完成后，除非是修改错误，不然不能修改代码，只能扩展代码。\n依赖导致原则：\n\n调用者（客户代码）不依赖于被调用者（实现代码）的实现细节，而是依赖其抽象\n调用者不依赖被调用者的具体实现，而是依赖被调用者的抽象，这样被调用者后续可以被无感替换掉。\n单一职责原则：\n\n一个类，最好只做一件事，只有一个引起它的变化。\n接口隔离原则：\n\n使用多个小的专门的接口，而不要使用一个大的总接口。\n\n最少知道原则：\n\n一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。\n合成复用原则：\n\n原则是尽量使用合成/聚合的方式，而不是使用继承。\n里氏替换原则：\n\n子类必须能够替换其基类。\n\n类b继承类a时，除添加新的方法完成新增功能p2外，尽量不要重写父类a的方法，也尽量不要重载父类a的方法。\n\n\n# 1.2 常见基础题\n\n# 1.2.1 equals和==区别？\n\n首先明确一点，equals是方法，==是操作符。\n\n1. 如果比较的是基本数据类型：\n\n只讨论==，因为equals是不存在的，因为java中基本数据类型不能调用method的。\n\n2. 如果比较的是引用类型：\n\n**==：**比较两个引用是不是指向同一个对象实例，即相同的地址。\n\n**equals：**equals方法是object类的方法，默认是直接调用==来实现。如果没有被重写，那么调用equals与==没有区别。但是，在一些类库中这个方法被覆盖了，比如八大基本数据类型的包装类和string类，它们的equals方法比较的是值是否相同，此时equals就与==有区别了。\n\n# 1.2.2 java抽象类？\n\n1.抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。\n\n2.由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。\n\n3.在java中抽象类表示的是继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。\n\n# 1.2.3 深拷贝和浅拷贝的区别？\n\n拷贝针对的是引用对象的拷贝。\n\n浅拷贝只复制指向某个对象的引用，不复制内存本身，新旧对象还是共享同一块内存。\n\n深拷贝会复制一个一模一样的对象，新对象跟原对象不共享内存。\n\n# 1.2.4 java是值传递还是引用传递？\n\n形式参数为基本数据类型的，就是值传递，如果为引用数据类型就是引用传递。\n\njava中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。\n\n# 1.2.5 为什么重写equals还要重写hashcode？\n\n如：重写一个自定义类的equals可以实现我们的意图，即这两个类判断为相等，但它们的hashcode是不同的。\n\n如果我们用hashset去add的时候，由于底层是通过hashcode判断是不是同一对象，这个时候不重写hashcode就会被判断成不同对象。\n\n# 1.2.6 为什么notify(), wait()等函数定义在object中，而不是thread中？\n\n锁可以是任意对象，所以任意对象调用方法一定定义在object类中。\n\n# 1.2.7 java中的object九大方法？\n\nprotected object clone() 创建并返回此对象的一个副本。\n\nboolean equals(object obj) 指示某个其他对象是否与此对象“相等”。\n\nprotected void finalize() 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。\n\nclass<? extendsobject> getclass() 返回一个对象的运行时类。\n\nint hashcode() 返回该对象的哈希码值。\n\nvoid notify() 唤醒在此对象监视器上等待的单个线程。\n\nvoid notifyall() 唤醒在此对象监视器上等待的所有线程。\n\nstring tostring() 返回该对象的字符串表示。\n\nvoid wait() 导致当前的线程等待，直到其他线程调用此对象的notify()方法或notifyall() 方法。\n\nvoid wait(long timeout) 导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或\n\nvoid wait(long timeout, int nanos) 导致当前的线程等待，直到其他线程调用此对象的 notify()\n\n# 1.2.8 aspectj与spring aop比较？\n\n1.aspectj使用编译时和class文件加载时织入时，spring aop利用运行时织入。\n\n2.spring aop是基于代理的aop框架。这意味着, 要实现目标对象的各个方面, 它将创建该对象的代理。\n\n使用以下两种方法之一实现:\n\n1）jdk 动态代理 —— spring aop 的首选方式。只要目标对象实现甚至一个接口, 就会使用 jdk 动态代理；\n\n2）cglib 代理 —— 如果目标对象没有实现接口, 则可以使用 cglib 代理。\n\n3. aspectj在实际运行之前就完成了织入，所以说它生成的类是没有额外运行时开销的。\n\n\n\n# 1.2.9 sleep()方法和wait()方法区别和共同点?\n\n1.两者最主要的区别在于：**sleep() 方法没有释放锁，而 wait() 方法释放了锁** 。\n\n2.两者都可以暂停线程的执行。\n\n3.wait() 通常被用于线程间交互/通信，sleep() 通常被用于暂停执行。\n\n4.wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyall() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n\n# 1.3 threadlocal\n\n# 1.3.1 弱引用\n\n# 1.3.1.1 为什么使用弱引用？\n\n考虑下面的场景：\n\n有一个product类代表一种产品，这个类被设计为不可扩展的，此时我们想要为每个产品增加一个编号。\n\n一种解决方案是使用hashmap<product, integer>。\n\n于是问题来了，如果我们已经不再需要一个product对象存在于内存中（比如已经卖出了这件产品），假设指向它的引用为producta，我们这时会给producta赋值为null，然而这时producta过去指向的product对象并不会被回收，因为它显然还被hashmap引用着。\n\n所以这种情况下，我们想要真正的回收一个product对象，仅仅把它的强引用赋值为null是不够的，还要把相应的条目从hashmap中移除。\n\n显然“从hashmap中移除不再需要的条目”这个工作我们不想自己完成，我们希望告诉垃圾收集器：在只有hashmap中的key在引用着product对象的情况下，就可以回收相应product对象了。\n\n根据前面弱引用的定义，使用弱引用能帮助我们达成这个目的。我们只需要用一个指向product对象的弱引用对象来作为hashmap中的key就可以了。\n\n# 1.3.1.2 如何使用弱引用？\n\n拿上面介绍的场景举例，我们使用一个指向product对象的弱引用对象来作为hashmap的key，只需这样定义这个弱引用对象：\n\nproduct producta = new product(...);\n\nweakreference<product> weakproducta = new weakreference<>(producta);\n\n若引用对象weakproducta就指向了product对象producta。我们怎么通过weakproduct获取它所指向的product对象producta呢？很简单，只需要下面这句代码：\n\nproduct product = weakproducta.get();\n\n# 1.3.1.3 什么是弱引用？\n\njava中的弱引用具体指的是java.lang.ref.weakreference<t>类，我们首先来看一下官方文档对它做的说明：\n\n弱引用对象的存在不会阻止它所指向的对象被垃圾回收器回收。弱引用最常见的用途是实现规范映射(canonicalizing mappings，比如哈希表）。\n\n假设垃圾收集器在某个时间点决定一个对象是弱可达的(weakly reachable)（也就是说当前指向它的全都是弱引用），这时垃圾收集器会清除所有指向该对象的弱引用，然后把这个弱可达对象标记为可终结(finalizable)的，这样它随后就会被回收。与此同时或稍后，垃圾收集器会把那些刚清除的弱引用放入创建弱引用对象时所指定的 引用队列(reference queue)中。\n\n# 1.3.1.4 强引用、软引用、虚引用\n\n实际上，java中存在四种引用，它们由强到弱依次是：强引用、软引用、弱引用、虚引用。下面我们简单介绍下除弱引用外的其他三种引用：\n\n**强引用（strong reference）：**通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的(strongly reachable)，那么它就不被回收。\n\n**软引用（soft reference）：**软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些。\n\n**虚引用（phantom reference）：**虚引用是java中最弱的引用，那么它弱到什么程度呢？它是如此脆弱以至于我们通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收。\n\n# 1.3.2 什么是threadlocal？\n\n**threadlocal是线程局部变量。**这种变量在多线程的情况下访问时能保证各个线程变量相对独立于其他线程中的变量。threadlocal实例通常来说是private static类型的，用于关联线程和线程上下文。\n\nthread跟threadlocal什么关系：\n\nthread和threadlocal是绑定的， threadlocal依赖于thread去执行， thread将需要隔离的数据存放到threadlocal(准确的讲是threadlocalmap)中, 来实现多线程处理。\n\n# 1.3.3 spring如何处理bean多线程下的并发问题？\n\nthreadlocal天生为解决相同变量的访问冲突问题， 所以这个对于spring的默认单例bean的多线程访问是一个完美的解决方案。\n\nspring也确实是用了threadlocal来处理多线程下相同变量并发的线程安全问题。\n\n# 1.3.4 spring如何保证数据库事务在同一个连接下执行？\n\ndatasourcetransactionmanager 是spring的数据源事务管理器， 它会在你调用getconnection()的时候从数据库连接池中获取一个connection， 然后将其与threadlocal绑定， 事务完成后解除绑定。这样就保证了事务在同一连接下完成。\n\n# 1.3.5 thread,threadlocalmap,threadlocal三者的逻辑关系？\n\n\n\n1.thread实例和threadlocalmap实例是一对一的关系\n\n2.threadlocalmap实例和threadlocal实例是一对多的关系。\n\n# 1.3.6 threadlocalmap底层结构是什么？\n\nthreadlocal中的map数据结构和hashmap不同，它并没有实现map接口，也不像hashmap一样通过链表来解决hash冲突！\n\n进阶问题：那么threadlocal是如何解决hash冲突呢？\n\n答：采用的开放地址法，不是hashmap的链地址法！\n\n\n\n**threadlocal是采用数组来存储的。**threadlocalmap在存储的时候会给每一个threadlocal对象一个threadlocalhashcode，在插入过程中，根据threadlocal对象的hash值，定位到table中的位置i，int i = key.threadlocalhashcode & (len-1)。\n\n\n\n# 1.3.7 threadlocal为什么可能发生内存泄漏？\n\n当使用threadlocal保存一个value时，会在threadlocalmap中的数组插入一个entry对象，按理说key-value都应该以强引用保存在entry对象中，但在threadlocalmap的实现中，key被保存到了weakreference对象中（弱引用对象）。\n\n这就导致了一个问题：threadlocal在没有外部强引用时，发生gc时key会被回收，如果创建threadlocal的线程一直持续运行（线程池的情况，线程跑完后会回到线程池，并不会销毁），那么这个entry对象中的value就有可能一直得不到回收，发生内存泄露。\n\n# 1.3.8 threadlocal如何避免内存泄露？\n\n使用完threadlocal之后，调用remove方法。\n\n\n# 1.4 volatile\n\n# 1.4.1 说说你对volatile关键字的理解？\n\n被volatile修饰的共享变量具有2个特性。\n\n1.保证了不同线程之间操作该共享变量的内存可见性。\n\n2.禁止指令重排序\n\n# 1.4.2 详细说一下什么是内存可见性？\n\n1.4.2.1 java内存模型\n\n关于内存可见性的话，要先提一下java内存模型（jmm），java虚拟机里面定义的一种抽象模型。\n\n根据jmm的设计，系统存在一个主内存(main memory)，java中所有变量都储存在主存中，对于所有线程都是共享的。\n\n每条线程都有自己的工作内存(working memory)，工作内存中保存的是主存中某些变量的拷贝，线程对所有变量的操作都是在工作内存中进行，线程之间无法相互直接访问，变量传递均需要通过主存完成。\n\n\n\n但是jmm这个主内存和工作内存跟jvm中的堆、栈内存实际上是没什么关系的。\n\n1.4.2.2 jvm和jmm之间的关系\n\njmm中的主内存、工作内存与jvm中的java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的。\n\n如果一定要勉强对应起来，jmm的主内存可以对应jvm堆中对象实例部分，jmm工作内存可以对应jvm虚拟机栈中的部分区域。\n\n从更低层次上说，主内存就直接对应于物理硬件的内存，\n\n而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。\n\n1.4.2.3 内存可见性\n\nvolatile保证了变量的可见性主要是因为：\n\n1）线程更新volatile变量的时候，先去更新工作内存中这个变量的副本，然后再将改变后副本的值从工作内存刷新到主内存。\n\n2）线程读取volatile变量的时候，先去主内存中读取最新值到工作内存，然后再从工作内存中读取。\n\n# 1.4.3 说一下什么是指令重排序？\n\n1.4.3.1 指令重排序\n\n重排序是指编译器和处理为了优化程序性能而对指令序列进行重新排序的一种手段。\n如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重新排序。\n\n\n\n1.4.3.2 happens-before（先行发生原则）\n\njava内存模型中会默认保证一定的有序性，就是happens-before规则，指令重排序需要遵循这个规则。\n\n如果2个操作的执行顺序无法重happens-before规则中推导出来，就不能保证他们的有序性，jvm就可能对他们进行重排序。\n\nhappens-before主要有以下几条规则：\n\n1.程序次序规则： 一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作。（保证单线程的执行结果是正确的，对于无关紧要的重排序是允许的。）\n\n2.锁定规则： 一个unlock操作先行发生于后面对同一个锁的lock操作。\n\n3.volatile变量规则： 对一个变量的写操作先行发生与后面对这个变量的读操作。\n\n4.传递规则： 如果操作a先行发生于操作b，而操作b又先发生于操作c，则可以得出操作a先行发生于操作c。\n\n前四条规则是比较重要的，后四条是比较显而易见的。\n\n1.线程启动规则： thread对象的start()方法先行发生于此线程的每一个动作\n\n2.线程中断规则： 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。\n\n3.线程终结规则： 线程中所有的操作都先行发生于线程的终止检测,我们可以通过thread.join()方法结束、thread.isalive()的返回值手段检测到线程已经终止执行。\n\n4.对象终结规则： 一个对象的初始化完成先行发生于他的finalize()方法的开始。\n\n\n# 2、数据结构\n\n\n# 2.1 数组和链表区别？\n\n1.链表通过指针来连接元素与元素，数组则是把所有元素按次序依次存储。\n\n2.链表的插入删除元素相对数组较为简单，不需要移动元素，且较为容易实现长度扩充，但是寻找某个元素较为困难。\n\n3.数组寻找某个元素较为简单，但插入与删除比较复杂，由于最大长度需要再编程一开始时指定，故当达到最大长度时，扩充长度不如链表方便。\n\n\n# 2.2 hashmap的数据结构？默认初试容量和负载因子是多少？\n\n1.数组+链表，链表长度大于8时接红黑树。\n\n2.初始容量（16）和负载因子（0.75）（负载因子就是指填充到多少开始扩大容量）。\n\n\n# 2.3 hashmap的数组长度为什么要保证是2的幂？\n\n在hashmap中通过利用key的hashcode值,来进行位运算\n\n公式:index = e.hash & (newcap - 1)\n\nlength - 1的值是所有二进制位全为1,这种情况下,index的结果等同于hashcode后几位的值\n\n只要输入的hashcode本身分布均匀,hash算法的结果就是均匀的。\n\n所以,hashmap的默认长度为16,是为了降低hash碰撞的几率。\n\n\n# 2.4 hashmap的扩容？\n\nrehash：当map中的元素大于数组长度的75%时，就会进行扩容，jdk1.7之前扩容时很有可能会造成环链，后续get时则可能会变成死循环，线程不安全。\n\n\n\n\n# 2.5 能讲一下concurrenthashmap？\n\njdk1.7中concurrenthashmap采用分段锁，分成16个小的hashmap，锁定当前的小hashmap其他\n\nhashmap不受影响。jdk1.8之后不再采取分段锁，主要采用cas原子指令实现无锁的高并发操作。\n\n\n# 2.6 concurrenthashmap 1.7 与 1.8 区别?\n\n1.jdk1.8 采用 synchronized 代替可重入锁 reentrantlock。\n\n2.jdk1.8 取消了 segment 分段锁的数据结构，使用数组+链表+红黑树的结构代替。\n\n3.jdk1.8 对每个数组元素加锁，1.7 对要操作的 segment 数据段加锁。\n\n\n# 3、并发加锁\n\n\n# 3.1 synchronized\n\n# 3.1.1 cas与synchronized的区别？\n\n1）cas 是 compare and swap 的缩写，即我们所说的比较交换。\n\ncas 是一种基于锁的操作，而且是乐观锁。在java中锁分为乐观锁和悲观锁。\n\n悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。\n\n而乐观锁采取了 一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加 version 来获取数据， 性能较悲观锁有很大的提高。\n\ncas 操作包含三个操作数：内存位置(v)、旧值(a)和新值(b)。如果内存地址里面的值和 a 的值是一样的，那么就将内存里面的值更新成 b。\n\ncas 是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行。\n\njava.util.concurrent.atomic 包下的类大多是使用 cas 操作来实现的 (atomicinteger,atomicboolean,atomiclong)。\n\ncas存在的问题：\n\n1.1）aba问题：一个线程把值从a改为b再改回a，另一个线程不知道这个过程。\n\n解决方案：使用版本号，每次修改数据时带上一个版本号。\n\n1.2）循环开销大：cas通过自旋获取锁，当一直获取不到锁时，会不断空循环。\n\n1.3）不能保证代码块的原子性\n\ncas 机制所保证的知识一个变量的原子性操作，而不能保证整个代码块的原子性。比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized了。\n\n2）synchronized：悲观锁。\n\nsynchronized主要解决的是多个线程之间的同步问题，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。\n\njdk1.6之前性能较差，主要基于monitor机制实现，依赖底层操作系统的互斥原语mutex。线程之间的切换需要操作系统从用户态转换到内核态进行，时间成本很高。jdk1.6之后做了优化，锁分成了4种状态，分别是无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。\n\n\n\n偏向锁：针对没有锁竞争的场合。jvm启动之后默认有4s的延迟，对每个新建的对象都开启偏向锁模式，在这之前新建的都是无锁状态。（可通过配置调整）\n\n\n\n轻量级锁：出现的场景是线程交替执行同步块。通过cas获取锁（没有自旋），失败膨胀成重量级锁。\n\na线程执行完加锁模块，线程还没结束，此时b线程去加锁（发现加不了偏向锁：a线程还在执行），升级为轻量级锁。轻量级锁解锁后后直接到无锁状态。（同样，重量级锁解锁的时候也只会到无锁状态。重量级锁解锁时是gc的时候才清掉标识，较慢，可睡眠一两秒后再看。）\n\n重量级锁：出现场景：竞争激烈的情况（a线程的锁还没释放，b线程也去加锁）。去内核态操作前，会先尝试自旋cas获取锁。\n\n# 3.1.2 synchronized的加锁方式\n\n\n\n# 3.1.3 new object(); 占多少字节？ 16\n\n对象在内存中存储的布局可以分为三块区域:\n\n对象头(header)\n\n实例数据 (instance data)\n\n对齐填充(padding)\n\n\n\nmark word：8字节\n\nmetadata：4字节\n\n数组长度：4字节\n\n长度必须是8的倍数，不够则用“对齐填充”补齐。\n\n# 3.1.4 关于无锁偏向锁轻量级锁重量级锁的理解误区\n\n1. 无锁 --\x3e 偏向锁 --\x3e 轻量级锁 --\x3e 重量级锁。 （不存在无锁 --\x3e 偏向锁）\n\n2. 轻量级锁自旋获取锁失败，会膨胀成重量级锁。 （轻量级锁不存在自旋）\n\n3. 重量级锁不存在自旋。 （重量级锁存在自旋）\n\n# 3.1.5 锁状态转换流程\n\n\n\n\n# 3.2 aqs\n\n# 3.2.1 聊聊你对aqs的理解？\n\nabstractqueuedsynchronizer，抽象队列同步器\n\naqs它是juc（java.util.concurrent）包中多个组件的底层实现。比如像reentrantlock、semaphore、countdownlatch都用到了aqs。\n\naqs提供了2种锁机制，分别是独占锁和共享锁。\n\n所谓独占锁就是存在多个线程去竞争同一共享资源的时候，同一个时刻，只允许一个线程去访问这个共享资源。也就是多个线程，只有一个能获取锁。比如reentrantlock就是独占锁。\n\n共享锁就是在同一时刻允许多个线程去获取锁。比如countdownlatch、semaphore。\n\n然后，关于aqs的设计，它有几个核心的东西：\n\naqs对象里面有一个int类型变量：state，代表了加锁状态。独占锁初始状态下是0\n\n还有一个关键变量：加锁线程，用来记录当前加锁的是那个线程。初始状态下是null\n\n另外aqs内部还有一个等待队列，用来专门存放加锁失败的线程。\n\n关于独占锁加锁和释放锁过程：\n\n1.线程过来加锁，通过cas的方式把state从0变成1，同时把“加锁线程”设置成自己。\n\n2.如果加锁的时候发现state不是0，会判断一下“加锁线程”是不是自己，是自己的话state累加，不是的话则加锁失败。\n\n3.加锁失败的会将自己放入同步队列中等待，等其他线程释放锁之后，自己再重新尝试加锁。\n\n4.加锁的线程在执行完自己的业务逻辑代码后释放锁，释放锁会将state变量减1，当state变量为0，则会彻底释放锁，同时把“加锁线程”这个变量设置成null。\n\n5.彻底释放锁后，会从同步队列的队头唤醒线程尝试加锁。\n\n还有一个点：公平锁与非公平锁，aqs支持公平和非公平锁：\n\naqs的处理方式是：在竞争锁资源的时候，公平锁需要去判断同步等待队列中时候有阻塞的线程，如果有则需要去排队等待。而非公平锁的处理方式是，不管同步等待队列中是否有阻塞线程，它都会直接去尝试更改互斥变量“state”去竞争锁。\n\n# 3.2.2 synchronized和reentrantlock的区别？\n\n1.synchronized是jvm层次的锁实现，reentrantlock是jdk层次的锁实现。\n\n2.synchronized的锁状态无法在代码中直接判断，但reentrantlock可以通过#islocked判断。\n\n3.synchronized是非公平锁，reentrantlock是可以是公平也可以是非公平的。\n\n4.synchronized是不可以被中断的，而reentrantlock#lockinterruptibly方法是可以被中断的。\n\n5.发生异常时synchronized会自动释放锁，而reentrantlock需要开发者在finally块中显示释放锁。\n\n6.reentrantlock获取锁的形式有多种:立即返回是否成功的trylock(),等待指定时长的获取，更灵活;\n\n# 3.2.3 aqs定义的两种队列？\n\n同步等待队列:\n\n主要用于维护获取锁失败时入队的线程。\n\n条件等待队列:\n\n调用await()的时候会释放锁，然后线程会加入到条件队列，调用signal()唤醒的时候会把条件队列中的线程节点移动到同步队列中，等待再次获得锁。\n\n\n# 3.3 死锁\n\n# 3.3.1 什么是死锁？\n\n死锁是指两个或两个以上的线程在执行过程中，由于竞争资源而造成的一种阻塞现象，若无外力作用，它们将无法推进下去。\n\n# 3.3.2 死锁产生的必要条件？\n\n1.互斥条件：即在一段时间内某一资源仅能一个线程占用\n\n2.占有且等待条件：当线程因为请求资源而阻塞的时候，对已经获得的资源保持不放。\n\n3.不可剥夺条件：线程对获得的资源为使用完成之前，不能被剥夺，只能使用完时由自己释放。\n\n4.循环等待条件：发生死锁时，必然存在一个进程和资源的环形链。\n\n# 3.3.3 怎么预防死锁？\n\n互斥条件无法被破坏，锁本身就是通过互斥来解决线程安全问题。\n\n1.资源一次性分配（破坏占用且等待的条件）\n\n2.可剥夺资源：进程已经获得部分资源，但得不到其他资源，则释放已占有的资源（破坏不可剥夺条件）\n\n3.资源有序分配：按顺序请求资源（破坏循环等待条件）\n\n\n# 4、多线程\n\n\n# 4.1 线程的生命周期？\n\n线程的生命周期主要包括了5种状态\n\nnew新建、runnable就绪、running运行、blocked阻塞、dead死亡。\n\n**new：**线程创建\n\n**runnable：**执行start方法\n\n**running：**分配到了cpu时间片，开始执行代码\n\nblocked：\n\n• 等待阻塞：调用了o.wait()方法，该线程放入等待队列\n\n• 同步阻塞：获取对象锁时，锁被其他线程占用，该线程进入lock pool\n\n• 其他阻塞：sleep 或者 join方法时\n\n**dead：**线程执行完毕，或者抛出异常\n\n\n\n几个重要方法：\n\n**sleep()：**当前线程进入阻塞，但不释放对象锁。\n\n**yield()：**不会阻塞，让出cpu时间。\n\n**t.join()：**方法只会使主线程进入等待池并等待t线程执行完毕后才会被唤醒。并不影响同一时刻处在运行状态的其他线程。\n\n**obj.wait()：**当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()/notifyall()唤醒。\n\n**obj.notify()：**唤醒任意在此对象监视器上等待的单个线程。\n\n\n# 4.2 线程池有哪些核心参数？\n\n1、int corepoolsize：核心池的大小。线程池的基本大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。\n\n这里需要注意的是：\n\n在创建threadpoolexecutor的时候，线程不会立即启动，要等到有任务提交时才启动，除非调用prestartcorethread/prestartallcorethreads事先启动核心线程。\n\n再考虑到keepalivetime和allowcorethreadtimeout超时参数的影响，所以没有任务需要执行的时候，线程池的大小不一定是corepoolsize。\n\n2、int maximumpoolsize：线程池最大线程数，它表示在线程池中最多能创建多少个线程。\n\n线程池中允许的最大线程数，线程池中的当前线程数目不会超过该值。\n\n如果队列中任务已满，并且当前线程个数小于maximumpoolsize，那么会创建新的线程来执行任务。\n\n3、long keepalivetime：表示线程没有任务执行时最多保持多久时间会终止。\n\n4、timeunit unit：参数keepalivetime的时间单位，有7种取值，在timeunit类中有7种静态属性。\n\n5、blockingqueue<runnable> workqueue：一个阻塞队列，用来存储等待执行的任务。无界、有界、优先级、无缓冲区队列\n\n6、threadfactory threadfactory：线程工厂，主要用来创建线程。\n\n7、rejectedexecutionhandler handler：拒绝策略，表示当拒绝处理任务时的策略。\n\n\n# 4.3 线程池的执行流程？\n\n1、如果当前线程池中的线程数目小于corepoolsize，则来一个任务，就创建一个线程去执行这个任务。\n\n2、如果当前线程池中的线程数目>=corepoolsize，则每来一个任务，会尝试将其添加到任务队列当中。\n\n若添加成功，则该任务会等待空闲线程将其取出去执行。\n\n若添加失败（一般来说是任务缓存队列已满），则尝试创建新的线程去执行这个任务maximumpoolsize。\n\n3、如果当前线程池中的线程数目达到maximumpoolsize（此时线程池的任务缓存队列已满），则会采取任务拒绝策略进行处理；\n\n4、线程池中的线程数量大于corepoolsize时，如果某线程空闲时间超过keepalivetime，线程将被终止，直至线程池中的线程数目不大于corepoolsize；\n\n如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepalivetime，线程也会被终止。\n\n\n# 4.4 线程池的拒绝策略有哪几种？\n\n任务拒绝策略，通常有以下四种策略：\n\n1）threadpoolexecutor.abortpolicy：丢弃任务并抛出rejectedexecutionexception异常。\n\n2）threadpoolexecutor.discardpolicy：也是丢弃任务，但是不抛出异常。\n\n3）threadpoolexecutor.discardoldestpolicy：丢弃队列最前面的任务，然后重新尝试执行任务。\n\n4）threadpoolexecutor.callerrunspolicy：由调用线程（提交任务的线程）处理该任务。\n\n\n# 4.5 线程池的核心线程与最大线程数大小设置多少合适？\n\n核心线程数：\n\ncpu密集型任务应配置尽可能小的线程，如配置ncpu+1个线程的线程池。\n\nio密集型任务线程并不是一直在执行任务 ，则应配置尽可能多的线程，如2*ncpu 。\n\n最大线程数：\n\n最大线程数 = （最大任务数-队列容量）/每个线程每秒处理能力\n\n\n\n\n# 4.6 多线程并行执行，然后汇总结果返回怎么实现？\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"JVM",frontmatter:{title:"JVM",date:"2022-04-28T17:45:13.000Z",permalink:"/pages/98788c/",categories:["知识整理"],tags:["JVM"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/02.jvm.html",relativePath:"知识整理/02.jvm.md",key:"v-a63cde52",path:"/pages/98788c/",headers:[{level:2,title:"-1、云路生产环境节点配置",slug:"_1、云路生产环境节点配置",normalizedTitle:"-1、云路生产环境节点配置",charIndex:10},{level:2,title:"0、JAVA虚拟机补充说明",slug:"_0、java虚拟机补充说明",normalizedTitle:"0、java虚拟机补充说明",charIndex:385},{level:2,title:"1、JVM内存模型",slug:"_1、jvm内存模型",normalizedTitle:"1、jvm内存模型",charIndex:731},{level:3,title:"1.1 内存模型图",slug:"_1-1-内存模型图",normalizedTitle:"1.1 内存模型图",charIndex:745},{level:3,title:"1.2 JVM内存参数设置",slug:"_1-2-jvm内存参数设置",normalizedTitle:"1.2 jvm内存参数设置",charIndex:761},{level:3,title:"1.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）？",slug:"_1-3-为什么要将永久代-permgen-替换为元空间-metaspace",normalizedTitle:"1.3 为什么要将永久代（permgen）替换为元空间（metaspace）？",charIndex:837},{level:3,title:"1.4 JVM内存模型包括哪些数据区域？",slug:"_1-4-jvm内存模型包括哪些数据区域",normalizedTitle:"1.4 jvm内存模型包括哪些数据区域？",charIndex:931},{level:4,title:"1.4.1 方法区（元空间）",slug:"_1-4-1-方法区-元空间",normalizedTitle:"1.4.1 方法区（元空间）",charIndex:1027},{level:4,title:"1.4.2 堆",slug:"_1-4-2-堆",normalizedTitle:"1.4.2 堆",charIndex:1106},{level:4,title:"1.4.3 栈",slug:"_1-4-3-栈",normalizedTitle:"1.4.3 栈",charIndex:1224},{level:4,title:"1.4.4 本地方法栈",slug:"_1-4-4-本地方法栈",normalizedTitle:"1.4.4 本地方法栈",charIndex:1466},{level:4,title:"1.4.5 程序计数器",slug:"_1-4-5-程序计数器",normalizedTitle:"1.4.5 程序计数器",charIndex:1620},{level:2,title:"2、类加载",slug:"_2、类加载",normalizedTitle:"2、类加载",charIndex:1666},{level:3,title:"2.1 说一下类的加载流程？",slug:"_2-1-说一下类的加载流程",normalizedTitle:"2.1 说一下类的加载流程？",charIndex:1676},{level:4,title:"2.1.1 加载",slug:"_2-1-1-加载",normalizedTitle:"2.1.1 加载",charIndex:1713},{level:4,title:"2.1.2 验证",slug:"_2-1-2-验证",normalizedTitle:"2.1.2 验证",charIndex:1839},{level:4,title:"2.1.3 准备",slug:"_2-1-3-准备",normalizedTitle:"2.1.3 准备",charIndex:1881},{level:4,title:"2.1.4 解析",slug:"_2-1-4-解析",normalizedTitle:"2.1.4 解析",charIndex:1914},{level:4,title:"2.1.5 初始化",slug:"_2-1-5-初始化",normalizedTitle:"2.1.5 初始化",charIndex:1977},{level:4,title:"2.1.6 卸载",slug:"_2-1-6-卸载",normalizedTitle:"2.1.6 卸载",charIndex:2015},{level:3,title:"2.2 双亲委派机制",slug:"_2-2-双亲委派机制",normalizedTitle:"2.2 双亲委派机制",charIndex:2173},{level:4,title:"2.2.1 为什么要设计双亲委派机制?",slug:"_2-2-1-为什么要设计双亲委派机制",normalizedTitle:"2.2.1 为什么要设计双亲委派机制?",charIndex:2187},{level:4,title:"2.2.2 双亲委派的加载顺序？",slug:"_2-2-2-双亲委派的加载顺序",normalizedTitle:"2.2.2 双亲委派的加载顺序？",charIndex:2332},{level:4,title:"2.2.3 怎么实现自定义加载器？",slug:"_2-2-3-怎么实现自定义加载器",normalizedTitle:"2.2.3 怎么实现自定义加载器？",charIndex:2614},{level:4,title:"2.2.4 怎么打破双亲委派机制？",slug:"_2-2-4-怎么打破双亲委派机制",normalizedTitle:"2.2.4 怎么打破双亲委派机制？",charIndex:2746},{level:2,title:"3、虚拟机对象",slug:"_3、虚拟机对象",normalizedTitle:"3、虚拟机对象",charIndex:2784},{level:3,title:"3.1 对象的创建包含哪些步骤？",slug:"_3-1-对象的创建包含哪些步骤",normalizedTitle:"3.1 对象的创建包含哪些步骤？",charIndex:2796},{level:4,title:"3.1.1 类加载检查",slug:"_3-1-1-类加载检查",normalizedTitle:"3.1.1 类加载检查",charIndex:2818},{level:4,title:"3.1.2内存分配",slug:"_3-1-2内存分配",normalizedTitle:"3.1.2内存分配",charIndex:2957},{level:5,title:"3.1.2.1 内存分配有哪些方式？",slug:"_3-1-2-1-内存分配有哪些方式",normalizedTitle:"3.1.2.1 内存分配有哪些方式？",charIndex:3053},{level:6,title:"1 指针碰撞",slug:"_1-指针碰撞",normalizedTitle:"1 指针碰撞",charIndex:3157},{level:6,title:"2 空闲列表",slug:"_2-空闲列表",normalizedTitle:"2 空闲列表",charIndex:3296},{level:5,title:"3.1.2.2 内存分配的并发问题怎么解决？",slug:"_3-1-2-2-内存分配的并发问题怎么解决",normalizedTitle:"3.1.2.2 内存分配的并发问题怎么解决？",charIndex:3412},{level:6,title:"1 CAS+失败重试",slug:"_1-cas-失败重试",normalizedTitle:"1 cas+失败重试",charIndex:3481},{level:6,title:"2 TLAB",slug:"_2-tlab",normalizedTitle:"2 tlab",charIndex:3526},{level:4,title:"3.1.3 初始化零值",slug:"_3-1-3-初始化零值",normalizedTitle:"3.1.3 初始化零值",charIndex:3668},{level:4,title:"3.1.4 设置对象头",slug:"_3-1-4-设置对象头",normalizedTitle:"3.1.4 设置对象头",charIndex:3741},{level:4,title:"3.1.5 执行init方法",slug:"_3-1-5-执行init方法",normalizedTitle:"3.1.5 执行init方法",charIndex:3871},{level:3,title:"3.2 对象栈上分配",slug:"_3-2-对象栈上分配",normalizedTitle:"3.2 对象栈上分配",charIndex:3939},{level:4,title:"3.2.1 对象逃逸分析",slug:"_3-2-1-对象逃逸分析",normalizedTitle:"3.2.1 对象逃逸分析",charIndex:4144},{level:4,title:"3.2.2 标量替换",slug:"_3-2-2-标量替换",normalizedTitle:"3.2.2 标量替换",charIndex:4217},{level:3,title:"3.3 对象的内存布局",slug:"_3-3-对象的内存布局",normalizedTitle:"3.3 对象的内存布局",charIndex:4368},{level:4,title:"3.3.1 对象头",slug:"_3-3-1-对象头",normalizedTitle:"3.3.1 对象头",charIndex:4417},{level:5,title:"1 Mark Word",slug:"_1-mark-word",normalizedTitle:"1 mark word",charIndex:4474},{level:5,title:"2 指向类的指针",slug:"_2-指向类的指针",normalizedTitle:"2 指向类的指针",charIndex:4561},{level:5,title:"3 数组长度（只有数组对象有）",slug:"_3-数组长度-只有数组对象有",normalizedTitle:"3 数组长度（只有数组对象有）",charIndex:4633},{level:4,title:"3.3.2 实例数据",slug:"_3-3-2-实例数据",normalizedTitle:"3.3.2 实例数据",charIndex:4680},{level:4,title:"3.3.3 对齐填充",slug:"_3-3-3-对齐填充",normalizedTitle:"3.3.3 对齐填充",charIndex:4727},{level:3,title:"3.4 对象的访问定位",slug:"_3-4-对象的访问定位",normalizedTitle:"3.4 对象的访问定位",charIndex:4831},{level:4,title:"3.4.1 句柄",slug:"_3-4-1-句柄",normalizedTitle:"3.4.1 句柄",charIndex:4983},{level:4,title:"3.4.2 直接指针",slug:"_3-4-2-直接指针",normalizedTitle:"3.4.2 直接指针",charIndex:5066},{level:4,title:"3.4.3 两种访问方式各有什么优势？",slug:"_3-4-3-两种访问方式各有什么优势",normalizedTitle:"3.4.3 两种访问方式各有什么优势？",charIndex:5126},{level:2,title:"4、垃圾回收",slug:"_4、垃圾回收",normalizedTitle:"4、垃圾回收",charIndex:5254},{level:3,title:"4.1 JAVA堆的内存分配与回收",slug:"_4-1-java堆的内存分配与回收",normalizedTitle:"4.1 java堆的内存分配与回收",charIndex:5353},{level:3,title:"4.2 空间分配担保",slug:"_4-2-空间分配担保",normalizedTitle:"4.2 空间分配担保",charIndex:5548},{level:3,title:"4.3 怎么判断对象已经死亡？",slug:"_4-3-怎么判断对象已经死亡",normalizedTitle:"4.3 怎么判断对象已经死亡？",charIndex:5686},{level:4,title:"4.3.1 引用计数法",slug:"_4-3-1-引用计数法",normalizedTitle:"4.3.1 引用计数法",charIndex:5705},{level:4,title:"4.3.2 可达性分析算法",slug:"_4-3-2-可达性分析算法",normalizedTitle:"4.3.2 可达性分析算法",charIndex:5849},{level:5,title:"1 介绍",slug:"_1-介绍",normalizedTitle:"1 介绍",charIndex:5866},{level:5,title:"2 哪些对象可以作为GC Roots呢？",slug:"_2-哪些对象可以作为gc-roots呢",normalizedTitle:"2 哪些对象可以作为gc roots呢？",charIndex:6028},{level:3,title:"4.4 怎么判断一个类是无用的类？",slug:"_4-4-怎么判断一个类是无用的类",normalizedTitle:"4.4 怎么判断一个类是无用的类？",charIndex:6130},{level:3,title:"4.5 垃圾收集算法",slug:"_4-5-垃圾收集算法",normalizedTitle:"4.5 垃圾收集算法",charIndex:6311},{level:4,title:"4.5.1 标记-清除算法",slug:"_4-5-1-标记-清除算法",normalizedTitle:"4.5.1 标记-清除算法",charIndex:6325},{level:4,title:"4.5.2 标记-复制算法",slug:"_4-5-2-标记-复制算法",normalizedTitle:"4.5.2 标记-复制算法",charIndex:6483},{level:4,title:"4.5.3 标记-整理算法",slug:"_4-5-3-标记-整理算法",normalizedTitle:"4.5.3 标记-整理算法",charIndex:6596},{level:4,title:"4.5.4 分代收集算法",slug:"_4-5-4-分代收集算法",normalizedTitle:"4.5.4 分代收集算法",charIndex:6686},{level:3,title:"4.6 垃圾收集器",slug:"_4-6-垃圾收集器",normalizedTitle:"4.6 垃圾收集器",charIndex:6942},{level:4,title:"4.6.1 Serial收集器",slug:"_4-6-1-serial收集器",normalizedTitle:"4.6.1 serial收集器",charIndex:6955},{level:4,title:"4.6.2 ParNew收集器(-XX:+UseParNewGC)",slug:"_4-6-2-parnew收集器-xx-useparnewgc",normalizedTitle:"4.6.2 parnew收集器(-xx:+useparnewgc)",charIndex:7122},{level:4,title:"4.6.3 Parallel Scanvenge 收集器",slug:"_4-6-3-parallel-scanvenge-收集器",normalizedTitle:"4.6.3 parallel scanvenge 收集器",charIndex:7244},{level:4,title:"4.6.4 CMS收集器（4-8G）",slug:"_4-6-4-cms收集器-4-8g",normalizedTitle:"4.6.4 cms收集器（4-8g）",charIndex:7371},{level:5,title:"4.6.4.1介绍",slug:"_4-6-4-1介绍",normalizedTitle:"4.6.4.1介绍",charIndex:7423},{level:5,title:"4.6.4.2 CMS优缺点",slug:"_4-6-4-2-cms优缺点",normalizedTitle:"4.6.4.2 cms优缺点",charIndex:8014},{level:4,title:"4.6.5 G1收集器",slug:"_4-6-5-g1收集器",normalizedTitle:"4.6.5 g1收集器",charIndex:8393},{level:4,title:"4.6.6 如何选择垃圾收集器？",slug:"_4-6-6-如何选择垃圾收集器",normalizedTitle:"4.6.6 如何选择垃圾收集器？",charIndex:8558},{level:3,title:"4.7 三色标记",slug:"_4-7-三色标记",normalizedTitle:"4.7 三色标记",charIndex:8799},{level:4,title:"4.7.1 介绍",slug:"_4-7-1-介绍",normalizedTitle:"4.7.1 介绍",charIndex:8811},{level:4,title:"4.7.2 浮动垃圾（多标）",slug:"_4-7-2-浮动垃圾-多标",normalizedTitle:"4.7.2 浮动垃圾（多标）",charIndex:9266},{level:4,title:"4.7.3 漏标",slug:"_4-7-3-漏标",normalizedTitle:"4.7.3 漏标",charIndex:9497},{level:3,title:"4.8 GC安全点与安全区域",slug:"_4-8-gc安全点与安全区域",normalizedTitle:"4.8 gc安全点与安全区域",charIndex:9770},{level:4,title:"4.8.1 GC安全点",slug:"_4-8-1-gc安全点",normalizedTitle:"4.8.1 gc安全点",charIndex:9788},{level:4,title:"4.8.2 安全区域",slug:"_4-8-2-安全区域",normalizedTitle:"4.8.2 安全区域",charIndex:9959},{level:2,title:"5、工具命令",slug:"_5、工具命令",normalizedTitle:"5、工具命令",charIndex:10104},{level:3,title:"5.1 jmap",slug:"_5-1-jmap",normalizedTitle:"5.1 jmap",charIndex:10115},{level:3,title:"5.2 jstack",slug:"_5-2-jstack",normalizedTitle:"5.2 jstack",charIndex:10375},{level:3,title:"5.3 jinfo",slug:"_5-3-jinfo",normalizedTitle:"5.3 jinfo",charIndex:10523},{level:3,title:"5.4 jstat",slug:"_5-4-jstat",normalizedTitle:"5.4 jstat",charIndex:10566},{level:2,title:"6、阿尔萨斯（Arthas）",slug:"_6、阿尔萨斯-arthas",normalizedTitle:"6、阿尔萨斯（arthas）",charIndex:11359},{level:3,title:"6.1 trace",slug:"_6-1-trace",normalizedTitle:"6.1 trace",charIndex:11378},{level:3,title:"6.2 reset",slug:"_6-2-reset",normalizedTitle:"6.2 reset",charIndex:11617},{level:3,title:"6.3 quit-stop",slug:"_6-3-quit-stop",normalizedTitle:"6.3 quit-stop",charIndex:11768},{level:3,title:"6.4 thread",slug:"_6-4-thread",normalizedTitle:"6.4 thread",charIndex:11975},{level:3,title:"6.5 sysprop",slug:"_6-5-sysprop",normalizedTitle:"6.5 sysprop",charIndex:12037},{level:3,title:"6.6 heapdump",slug:"_6-6-heapdump",normalizedTitle:"6.6 heapdump",charIndex:12070},{level:3,title:"6.7 dashboard",slug:"_6-7-dashboard",normalizedTitle:"6.7 dashboard",charIndex:12136},{level:3,title:"6.8 watch",slug:"_6-8-watch",normalizedTitle:"6.8 watch",charIndex:12185}],headersStr:"-1、云路生产环境节点配置 0、JAVA虚拟机补充说明 1、JVM内存模型 1.1 内存模型图 1.2 JVM内存参数设置 1.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）？ 1.4 JVM内存模型包括哪些数据区域？ 1.4.1 方法区（元空间） 1.4.2 堆 1.4.3 栈 1.4.4 本地方法栈 1.4.5 程序计数器 2、类加载 2.1 说一下类的加载流程？ 2.1.1 加载 2.1.2 验证 2.1.3 准备 2.1.4 解析 2.1.5 初始化 2.1.6 卸载 2.2 双亲委派机制 2.2.1 为什么要设计双亲委派机制? 2.2.2 双亲委派的加载顺序？ 2.2.3 怎么实现自定义加载器？ 2.2.4 怎么打破双亲委派机制？ 3、虚拟机对象 3.1 对象的创建包含哪些步骤？ 3.1.1 类加载检查 3.1.2内存分配 3.1.2.1 内存分配有哪些方式？ 1 指针碰撞 2 空闲列表 3.1.2.2 内存分配的并发问题怎么解决？ 1 CAS+失败重试 2 TLAB 3.1.3 初始化零值 3.1.4 设置对象头 3.1.5 执行init方法 3.2 对象栈上分配 3.2.1 对象逃逸分析 3.2.2 标量替换 3.3 对象的内存布局 3.3.1 对象头 1 Mark Word 2 指向类的指针 3 数组长度（只有数组对象有） 3.3.2 实例数据 3.3.3 对齐填充 3.4 对象的访问定位 3.4.1 句柄 3.4.2 直接指针 3.4.3 两种访问方式各有什么优势？ 4、垃圾回收 4.1 JAVA堆的内存分配与回收 4.2 空间分配担保 4.3 怎么判断对象已经死亡？ 4.3.1 引用计数法 4.3.2 可达性分析算法 1 介绍 2 哪些对象可以作为GC Roots呢？ 4.4 怎么判断一个类是无用的类？ 4.5 垃圾收集算法 4.5.1 标记-清除算法 4.5.2 标记-复制算法 4.5.3 标记-整理算法 4.5.4 分代收集算法 4.6 垃圾收集器 4.6.1 Serial收集器 4.6.2 ParNew收集器(-XX:+UseParNewGC) 4.6.3 Parallel Scanvenge 收集器 4.6.4 CMS收集器（4-8G） 4.6.4.1介绍 4.6.4.2 CMS优缺点 4.6.5 G1收集器 4.6.6 如何选择垃圾收集器？ 4.7 三色标记 4.7.1 介绍 4.7.2 浮动垃圾（多标） 4.7.3 漏标 4.8 GC安全点与安全区域 4.8.1 GC安全点 4.8.2 安全区域 5、工具命令 5.1 jmap 5.2 jstack 5.3 jinfo 5.4 jstat 6、阿尔萨斯（Arthas） 6.1 trace 6.2 reset 6.3 quit-stop 6.4 thread 6.5 sysprop 6.6 heapdump 6.7 dashboard 6.8 watch",content:'# JVM\n\n\n# -1、云路生产环境节点配置\n\n-XX:+UseContainerSupport\n\n此参数用于使 JVM 在分配堆大小时考虑容器内存限制，而不是主机配置。\n\n-XX:MaxRAMPercentage=60.0\n\n堆最大内存大小（容器总内存的百分比）\n\n-XX:InitialRAMPercentage=60.0\n\n初始堆大小（容器总内存的百分比）\n\n-XX:MinRAMPercentage=60.0\n\n堆最小内存大小（容器总内存的百分比）\n\n-XX:NewRatio=2\n\n老年代除以新生代比例，2代表新生代占1，老年代占2，年轻代占整个堆内存的1/3。\n\n-Xss512k\n\n栈内存的大小（决定方法调用深度）\n\n-XX:MetaspaceSize=256M\n\n元空间\n\n-XX:MaxMetaspaceSize=512M\n\n最大元空间大小\n\n\n# 0、JAVA虚拟机补充说明\n\n从Java SE 7开始，HotSpot VM就是Java规范的“参考实现”。把它叫做“标准JVM”完全不为过。\n\n当大家说起“Java性能如何如何”、“Java有多少种GC”、“JVM如何调优”云云，经常默认说的就是特指HotSpot VM。可见其“主流性”。\n\nJDK8的HotSpot VM已经是以前的HotSpot VM与JRockit VM的合并版，也就是传说中的“HotRockit”，只是产品里名字还是叫HotSpot VM。\n\n这个合并并不是要把JRockit的部分代码插进HotSpot里，而是把前者一些有价值的功能在后者里重新实现一遍。移除PermGen、Java Flight Recorder、jcmd等都属于合并项目的一部分。\n\n\n# 1、JVM内存模型\n\n\n# 1.1 内存模型图\n\n\n\n\n# 1.2 JVM内存参数设置\n\n\n\n-Xss设越小count值越小，说明一个线程栈里能分配的栈帧就越少，但对JVM整体来说能开启的线程数会更多。\n\n\n# 1.3 为什么要将永久代（PermGen）替换为元空间（MetaSpace）？\n\n1.永久代受限于JVM本身设置的固定大小上限。元空间使用的是直接内存，只受本机可用内存限制。\n\n\n\n\n# 1.4 JVM内存模型包括哪些数据区域？\n\n主要包括5大块。\n\n1.方法区（元空间），堆都为数据共享区域，有线程安全问题。\n\n2.栈、本地方法栈、程序计数器为独享区域，不存在线程问题。\n\n# 1.4.1 方法区（元空间）\n\n存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码等数据。方法区还有一个别名叫Non-Heap（非堆）。\n\n# 1.4.2 堆\n\n此内存区域的唯一目的就是存放对象实例，几乎所有对象实例以及数组都在这里分配内存。\n\nJDK1.7之后开始默认开启逃逸分析：如果某些方法中的对象没有被返回或者未被外面引用（未逃逸），那么该对象可以在栈上分配内存。\n\n# 1.4.3 栈\n\n栈也就是Java虚拟机栈，由一个个栈帧组成，每个栈帧拥有：\n\n局部变量表、操作数栈、动态链接、方法出口信息。\n\n局部变量表主要存放编译期可知的各种数据类型（byte、short、int、long、float、double、boolean、char）、对象引用。\n\n每一次方法的调用都会有一个对应的栈帧被压入java栈，方法调用结束后，栈帧弹出。\n\nJava方法有2种返回方式：\n\n1.return语句。\n\n2.抛出异常。\n\n不管哪种返回方式都会导致栈帧弹出。\n\n# 1.4.4 本地方法栈\n\n和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈执行的是Java方法服务，本地方法栈执行的是Native方法服务。\n\n本地方法执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n本地方法执行完毕后也会出栈并释放内存空间。\n\n# 1.4.5 程序计数器\n\n每条线程都有独立的程序计数器，各线程之间计数器互不影响。\n\n\n# 2、类加载\n\n\n# 2.1 说一下类的加载流程？\n\n一个类的完整生命周期如下：\n\n\n\n\n\n# 2.1.1 加载\n\n类加载过程的第一步，主要完成3件事情：\n\n1.通过全类名获取定义此类的二进制字节流。\n\n2.将字节流信息转换成方法区的数据结构。\n\n3.在方法区（元空间）内存中生成一个代表该类的Class对象，作为方法区这些数据的访问入口。\n\n# 2.1.2 验证\n\n确保加载的类符合JVM规范和安全，其实就是一个安全检查。\n\n# 2.1.3 准备\n\n为静态变量分配内存并赋予默认值的阶段。\n\n# 2.1.4 解析\n\n虚拟机将常量池内的符号引用替换为直接引用。\n\n也就是得到类或者字段、方法在内存中的指针或者偏移量。\n\n# 2.1.5 初始化\n\n初始化静态变量为指定的值，执行静态代码块。\n\n\n\n# 2.1.6 卸载\n\n卸载类即该类的Class对象被GC。\n\n卸载需要满足3个条件：\n\n1.该类的所有实例对象已被GC。\n\n2.该类没有在其他任何地方被引用。\n\n3.该类的类加载器的实例已被GC。\n\n所以，在JVM生命周期内，由jvm自带的类加载器加载的类是不会被卸载的。自定义的类加载器加载的类可能被卸载。\n\n\n# 2.2 双亲委派机制\n\n# 2.2.1 为什么要设计双亲委派机制?\n\n1）沙箱安全机制:自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改。\n\n2）避免类的重复加载:当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性。\n\n# 2.2.2 双亲委派的加载顺序？\n\n\n\n双亲委派加载顺序为什么要从:\n\nAppcClassLoader -> ExtClassLoader -> BootstrapClassLoader -> ExtClassLoader -> AppcClassLoader\n\n为什么不直接:\n\nBootstrapClassLoader -> ExtClassLoader -> AppcClassLoader\n\n答：开发的应用中大部分用到的是appclassloader，第一次加载会麻烦一点，但是第二次加载如果发现该类已经加载过（c++实现），则直接用该加载器加载。\n\n# 2.2.3 怎么实现自定义加载器？\n\n继承ClassLoader，重写ClassLoader类中的findClass方法。\n\n除了BootstrapClassLoader，其他类加载器均由Java实现且全部继承自java.lang.ClassLoader。\n\n# 2.2.4 怎么打破双亲委派机制？\n\n重写loadClass方法。\n\n\n# 3、虚拟机对象\n\n\n# 3.1 对象的创建包含哪些步骤？\n\n\n\n# 3.1.1 类加载检查\n\n虚拟机遇到一条new指令时，首先去检查这个指令的参数能否在Class常量池中定位到一个类的符号引用，且检查这个符号引用代表的类是否已加载、解析和初始化过。如果没有，先执行相应的类加载过程。\n\nnew指令指：new关键词、对象克隆、对象序列化等。\n\n# 3.1.2内存分配\n\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。\n\n对象所需的内存大小在类加载完成后便可确定，为对象分配内存等同把一块确定大小的内存从java堆中划分出来。\n\n# 3.1.2.1 内存分配有哪些方式？\n\n分配内存的方式有 指针碰撞 和 空闲列表 2种。\n\n选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否有压缩整理功能决定。\n\n# 1 指针碰撞\n\n适用场合：堆内存规整（即没有内存碎片）的情况下。\n\n原理：所有用过的内存全部整合到一边，没有用过的内存放在另外一边，中间有一个分界指针，只需要向着没用过的内存方向将指针移动对象内存大小位置即可。\n\n使用该分配方式的GC收集器：Serial，ParNew。\n\n# 2 空闲列表\n\n适用场合：堆内存不规整的情况下。\n\n原理：JVM维护一个列表，该列表会记录哪些内存块是可用的，在分配内存的时候，找到一块足够大的内存块划分给对象实例，最后更新列表记录。\n\n使用该分配方式的GC收集器：CMS。\n\n# 3.1.2.2 内存分配的并发问题怎么解决？\n\n创建对象是很频繁的问题，需保证线程安全。目前，虚拟机采用了2种方式来保证线程安全：\n\n# 1 CAS+失败重试\n\nCAS操作失败就重试，直到成功为止。保证更新操作的原子性。\n\n# 2 TLAB\n\n缓冲区（Thread Local Allocation Buffer）\n\nJVM为每一个线程预先在Eden区分配一块内存，给线程中的对象分配内存时，先在TLAB上分配，当对象大于TLAB的剩余内存或TLAB的内存用尽时，采用 CAS+失败重试 的方式分配内存。\n\n# 3.1.3 初始化零值\n\n内存分配完成后，JVM将分配到的内存空间都初始化为零值。\n\n这一步保证了对象的实例字段可以不赋初始值就直接使用。\n\n# 3.1.4 设置对象头\n\n初始化零值完成后，JVM开始设置对象头。\n\n对象头主要包括2部分信息（如果是数组对象，还有一个数组长度）：\n\n1.哈希码、GC分代年龄、锁状态标识等。\n\n2.指向类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例。\n\n# 3.1.5 执行init方法\n\n执行innit方法，对应到语言层面上讲，就是为属性赋值（与上面的赋零值不同），和执行构造方法。\n\n\n# 3.2 对象栈上分配\n\n通过创建对象时的内存分配可以知道JAVA中的对象都是在堆上进行分配，需要依靠GC进行内存回收，如果对象数量较多的时候，会给GC带来较大压力，间接影响应用的性能。\n\nJVM通过逃逸分析来确定方法内的对象会不会被外部访问（即会不会“逃逸”），如果不会逃逸就可以在栈上给该对象分配内存，这样该对象所占用的内存空间就可以随着栈帧的出栈而销毁。\n\n栈上分配一般同时依赖逃逸分析和标量替换。\n\n# 3.2.1 对象逃逸分析\n\n就是分析方法内对象是否会被外部引用（是否逃逸），未逃逸的对象在栈上分配内存。\n\nJDK7之后默认开启逃逸分析。\n\n# 3.2.2 标量替换\n\n标量和聚合量：\n\n1.基础类型和对象的引用可以理解为标量，它们不能被进一步分解。\n\n2.能被进一步分解的就是聚合量，比如：对象。\n\n标量替换：将对象成员变量分解成分散的变量，这些分散的变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。\n\n\n# 3.3 对象的内存布局\n\n对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充。\n\n# 3.3.1 对象头\n\n对象头主要由3部分组成：Mark Word、指向类的指针、数组长度（只有数组对象有）\n\n# 1 Mark Word\n\nMark Word记录了哈希码、GC分代年龄、锁标识等信息。\n\n在32位的JVM中长度是32bit，在64位的JVM中长度是64bit。\n\n\n\n# 2 指向类的指针\n\nJAVA对象的类数据保存在方法区。\n\n该指针在32位的JVM中长度是32bit，在64位的JVM中长度是64bit。\n\n# 3 数组长度（只有数组对象有）\n\n该对象在32位和64位的JVM中长度都是32bit。\n\n# 3.3.2 实例数据\n\n对象真正存储的有效信息，也就是程序中定义的各种类型的字段内容。\n\n# 3.3.3 对齐填充\n\n对齐填充不是必然存在的，只是因为Hotspot要求对象大小必须是8字节的整数倍。\n\n而对象头部分是8字节的倍数（1倍或2倍），所以实例数据部分没有对齐时，需要对齐填充来补全。\n\n\n# 3.4 对象的访问定位\n\nJAVA程序通过栈上的reference数据来操作堆上的具体对象。由于reference类型在JVM规范中只定义了一个指向对象的引用，没有说明这个引用通过何种方式去定位、访问堆中对象的具体位置，所以访问的方式取决于JVM的实现。目前主要的访问方式由2种：句柄和直接指针。\n\n# 3.4.1 句柄\n\nJAVA堆中会划分出一块内存来作为句柄池，reference存放的是对象的句柄地址，而句柄中包括对象实例的地址和对象Class的地址。\n\n\n\n# 3.4.2 直接指针\n\nreference存放的是对象实例地址。对象实例数据的对象头里包含Class的地址。\n\n\n\n# 3.4.3 两种访问方式各有什么优势？\n\n1.句柄访问最大的好处是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针，reference不需要修改。\n\n2.直接指针访问的好处是速度快，减少了一次指针定位的时间开销。\n\n\n# 4、垃圾回收\n\n内存回收很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。\n\n\n# 4.1 JAVA堆的内存分配与回收\n\n堆空间的基本结构：\n\n\n\n1.大部分情况下，对象首先在Eden区域分配。\n\n2.在一次新生代垃圾回收后（Eden区和Survivor区回收），如果对象还存活，则进入s0或s1，并且年龄加1。\n\n3.当对象年龄增加到一定程度（默认大于15），就会被晋升到老年代。\n\n晋升到老年代的年龄设置可以通过指定参数配置，但这个值会在虚拟机运行过程中调整。\n\n\n# 4.2 空间分配担保\n\n空间分配担保是为了确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间。\n\n空间分配担保的规则为：\n\n只要老年代的连续空间大于新生代对象的总大小或者大于历次晋升的平均大小，就会进行Minor GC，\n\n否则进行Full GC。\n\n\n# 4.3 怎么判断对象已经死亡？\n\n# 4.3.1 引用计数法\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\n\n这个方法使用简单，效率高，但是主流的虚拟机都没有用它来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。\n\n# 4.3.2 可达性分析算法\n\n# 1 介绍\n\n将指定类型的对象作为GC Roots节点，从这些节点开始搜索，将有引用的节点串成一条引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\n\n下图中Object6 ~ Object10之间虽有引用关系，但他们到GC Roots不可达，因此为需要被回收的对象。\n\n\n\n# 2 哪些对象可以作为GC Roots呢？\n\n1.虚拟机栈中引用的对象\n\n2.本地方法栈中引用的对象\n\n3.方法区中类静态属性引用的对象\n\n4.方法区中常量引用的对象\n\n5.所有被同步锁持有的对象\n\n\n# 4.4 怎么判断一个类是无用的类？\n\n方法区主要回收的是无用的类，判断一个类无用，需要同时满足以下3个条件：\n\n1.该类的所有实例都已经被回收，也就是JVM堆中不存在该类的任何实例。\n\n2.加载该类的加载器ClassLoader已经被回收。\n\n3.该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射的方式访问该类。\n\n\n# 4.5 垃圾收集算法\n\n# 4.5.1 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n1.效率问题\n\n2.空间问题（标记清除后会产生大量不连续的碎片）\n\n\n\n# 4.5.2 标记-复制算法\n\n将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n\n\n# 4.5.3 标记-整理算法\n\n标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n\n# 4.5.4 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。\n\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。\n\n而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 4.6 垃圾收集器\n\n# 4.6.1 Serial收集器\n\nSerial（串行）收集器：单线程收集器。仅用一条线程完成垃圾收集工作，且运行期间必须暂停其他所有工作线程（Stop The World），直到它收集结束。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n缺点：暂停所有线程影响用户体验。\n\n优点：简单高效，没有线程交互的开销。\n\n# 4.6.2 ParNew收集器(-XX:+UseParNewGC)\n\nParNew收集器其实就是Serial收集器的多线程版本，除了多线程，其他行为一样。\n\n它可以和CMS收集器配合使用（新生代使用ParNew，老年代使用CMS）。\n\n\n\n# 4.6.3 Parallel Scanvenge 收集器\n\nJDK1.8的默认收集器，新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n看上去几乎和ParNew都一样。Parallel Scavenge收集器主要在于高效率的利用CPU。\n\n# 4.6.4 CMS收集器（4-8G）\n\n-XX:+UseConcMarkSweepGC(old)\n\n# 4.6.4.1介绍\n\nCMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。\n\n它非常符合在注重用户体验的应用上使用，它是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。\n\n从名字中的Mark Sweep这两个词可以看出，CMS收集器是一种 “标记-清除”算法实现的，它的运作过程相对复杂一些。整个过程分为四个步骤:\n\n\n\n1 初始标记\n\n暂停所有的其他线程(STW)，并记录下gc roots直接能引用的对象，速度很快。\n\n2 并发标记\n\n并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。\n\n3 重新标记\n\n重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记。\n\n4 并发清理\n\n开启用户线程，同时GC线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。\n\n5 并发重置\n\n重置本次GC过程中的标记数据。\n\n# 4.6.4.2 CMS优缺点\n\n优点:\n\n并发收集、低停顿。\n\n缺点:\n\n1）对CPU资源敏感(会和服务抢资源)。\n\n2）无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾要等到下一次gc再清理)。\n\n3）它使用的回收算法是“标记-清除”算法，会导致收集结束时会有大量空间碎片产生。当然通过参数- XX:+UseCMSCompactAtFullCollection可以让jvm在执行完标记清除后再做整理。\n\n4）执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并 发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是"concurrent mode failure"，此时会进入stop the world，用serial old垃圾收集器来回收。\n\n# 4.6.5 G1收集器\n\nG1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。具备高吞吐量性能特征。\n\nG1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。\n\nG1收集器具备以下特点：\n\n1.并行与并发\n\n2.分代收集\n\n3.空间整合\n\n4.可预测的停顿\n\n# 4.6.6 如何选择垃圾收集器？\n\nJDK1.8默认使用Parallel。JDK1.9默认使用G1。\n\nES、KAFKA内存较大的可使用G1。\n\n1.如果内存小于100M，使用串行收集器。\n\n2.如果是单核，并且没有停顿时间要求，串行或者JVM自己选择。\n\n3.如果响应时间最重要，并且不能超过1秒，使用并发收集器。\n\n1.内存4G以下可以用Parallel。\n\n2.内存4-8G可以用ParNew+CMS。\n\n3.内存8G以上可以用G1。\n\n4.内存几百G以上用ZGC。\n\n\n# 4.7 三色标记\n\n# 4.7.1 介绍\n\nJVM中的垃圾回收是基于标记-复制、标记清除和标记-整理三种模式的，其中最重要的是如何标记。\n\n像Serial、ParNew这类回收器，本质是暂停用户线程进行全面标记的算法。缺点是标记时间长导致STW时间也长，影响体验。\n\n像CMS、G1这类回收器，使用的是并发标记，可以在不暂停用户线程的情况下进行标记，从而可以用极少的时间或者没有中断来进行GC。实现并发标记的算法就是三色标记法。\n\n\n\n标记过程：\n\n1.在GC标记刚开始的阶段，所有对象均为白色集合。\n\n2.将所有GC Roots直接引用的对象标记成灰色集合。\n\n3.判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将所有子引用对象放入灰色集合，当前对象放入黑色集合。\n\n4.按照步骤3，以此类推，直到灰色集合中所有对象变成黑色后，本轮标记完成。当前白色集合内所有对象称为不可达对象，即垃圾对象。\n\n问题：\n\n三色标记过程是跟用户线程并发运行的，对象引用处于随时可变的情况，可能出现多标或漏标问题。\n\n# 4.7.2 浮动垃圾（多标）\n\n本来应该是标记白色的对象，结果被标记成灰色或黑色，造成该对象不会被回收。\n\n比如E对象被D对象引用着，刚好GC在扫描，将E对象标记成灰色，此时，D对E的引用被置空，这时候E对象以及后续子引用应该被当成垃圾回收，但是因为E已经被标记为灰色，导致没有被及时清理掉，变成浮动垃圾。\n\n还有一种情况，并发标记开始后产生的新对象，通常做法是直接当成黑色，本轮不会进行清除。但是这部分对象也有可能变成垃圾，所以也算是浮动垃圾的一部分。\n\n# 4.7.3 漏标\n\n灰色对象指向白色对象的引用消失了，然后一个黑色对象重新引用了白色对象。\n\n按照三色标记算法，黑色对象是已完成状态，不会再去找子引用，这样会导致这个白色对象虽然正在被线程使用中，但是无法被标记为灰色或者黑色，造成一个正在使用的对象被错误回收。\n\n总结：漏标只有同时满足以下两个条件才会发生：\n\n1.灰色对象断开了白色对象的引用。\n\n2.黑色对象重新引用了该白色对象。\n\n解决方案：\n\nCMS：Incremental Update算法\n\n当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。\n\n\n# 4.8 GC安全点与安全区域\n\n# 4.8.1 GC安全点\n\n当垃圾收集需要回收线程时，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程中会去查询这个标志位，一旦发现标志位为true时就自己在最近的安全点上主动中断挂起。查询标志位的地方跟安全点是重合的。\n\n触发点：\n\n1.方法返回之前。\n\n2.调用某个方法之后。\n\n3.抛出异常的位置。\n\n4.循环的末尾。\n\n# 4.8.2 安全区域\n\n安全点是针对正在执行的线程设定的。\n\n如果一个线程处在Sleep或者中断状态，它就不能响应JVM的中断请求，再运行到安全点上。\n\n因此JVM引入了安全区域的概念。\n\n安全区域是指在一段代码中，引用关系不会发生变化。在这个区域内的任意地方开始GC都是安全的。\n\n\n# 5、工具命令\n\n\n# 5.1 jmap\n\njps\n\n14660 jar\n\njmap -histo 14660 > ./log.txt\n\n此命令可查看内存信息，实例个数以及占用内存大小\n\n\n\njmap -heap 14660\n\n查看堆信息\n\n\n\njmap -dump:format=b,file=test.hprof 14660\n\n也可以设置内存溢出自动导出dump文件（内存很大的时候，可能会导不出来）\n\n1.-XX:+HeapDumpOnOutOfMemoryError\n\n2.-XX:HeapDumpPath=./ （路径）\n\n\n\n\n# 5.2 jstack\n\n找出占用cpu最高的线程堆栈信息\n\ntop\n\n\n\ntop -p 24\n\n\n\n按H，获取每个线程的内存情况\n\n\n\n1.找到内存和cpu占用最高的线程pid，比如797，转换成16进制得到0x31D\n\n2.执行jstack 24 | grep -A 10 31D\n\n\n\n\n# 5.3 jinfo\n\njinfo -flags 24\n\n查看jvm的参数\n\n\n\n\n# 5.4 jstat\n\njstat -gc 24\n\njstat -gc pid 最常用，可以评估程序内存使用及gc压力整体情况\n\n\n\n可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对 象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。\n\nS0C：第一个幸存区的大小，单位KB\n\nS1C：第二个幸存区的大小\n\nS0U：第一个幸存区的使用大小\n\nS1U：第二个幸存区的使用大小\n\nEC：伊甸园区的大小\n\nEU：伊甸园区的使用大小\n\nOC：老年代大小\n\nOU：老年代使用大小\n\nMC：方法区大小（元空间）\n\nMU：方法区使用大小\n\nCCSC：压缩类空间大小\n\nCCSU：压缩类空间使用大小\n\nYGC：年轻代垃圾回收次数\n\nYGCT：年轻代垃圾回收消耗时间，单位s\n\nFGC：老年代垃圾回收次数\n\nFGCT：老年代垃圾回收消耗时间，单位s\n\nGCT：垃圾回收消耗总时间，单位s\n\n优化思路其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。\n\n内存泄漏的一种情况：一般电商架构可能会使用多级缓存架构，就是redis加上JVM级缓存，大多数同学可能为了图方便对于JVM级缓存就 简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老 年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存 资源，时间长了除了导致full gc，还有可能导致OOM。\n\n\n# 6、阿尔萨斯（Arthas）\n\n\n# 6.1 trace\n\n利用trace命令追踪方法耗时。\n\nhttps://arthas.aliyun.com/doc/trace.html\n\n\n\ncurl -O https://arthas.aliyun.com/arthas-boot.jar\n\njava -jar arthas-boot.jar\n\ntrace com.yl.mhs.api.stream.kafka.receiver.WaybillOggApiReceiver doOggWaybillHandel\n\n\n# 6.2 reset\n\n通过reset命令可以重置增强类，将被 Arthas 增强过的类全部还原，Arthas 服务端关闭 时会重置所有增强过的类。\n\nArthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行reset命令，可以清除掉这些增强代码。\n\n\n# 6.3 quit-stop\n\n退出Arthas\n\n用exit或者quit命令可以退出Arthas。\n\nexit quit\n\n退出Arthas之后，还可以再次用 java -jar arthas-boot.jar来连接。\n\n彻底退出Arthas\n\nexit/quit命令只是退出当前session，arthas server还在目标进程中运行。\n\n想完成退出Arthas，可以执行stop命令。\n\nstop\n\n\n# 6.4 thread\n\n查看当前线程信息，查看线程的堆栈。\n\nthread -b\n\n找出当前阻塞其他线程的线程\n\n\n\n\n# 6.5 sysprop\n\n查看当前JVM的系统属性。\n\n\n\n\n# 6.6 heapdump\n\n类似jmap命令的heap dump功能。\n\nheapdump /tmp/dump.hprof\n\n\n# 6.7 dashboard\n\ndashboard命令可以查看当前系统的实时数据面板。\n\n\n\n\n# 6.8 watch\n\n观察指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 OGNL 表达式进行对应变量的查看。\n\n\n\n观察异常信息的例子：\n\nwatch demo.MathGame primeFactors "{params[0],throwExp}" -e -x 2\n\n',normalizedContent:'# jvm\n\n\n# -1、云路生产环境节点配置\n\n-xx:+usecontainersupport\n\n此参数用于使 jvm 在分配堆大小时考虑容器内存限制，而不是主机配置。\n\n-xx:maxrampercentage=60.0\n\n堆最大内存大小（容器总内存的百分比）\n\n-xx:initialrampercentage=60.0\n\n初始堆大小（容器总内存的百分比）\n\n-xx:minrampercentage=60.0\n\n堆最小内存大小（容器总内存的百分比）\n\n-xx:newratio=2\n\n老年代除以新生代比例，2代表新生代占1，老年代占2，年轻代占整个堆内存的1/3。\n\n-xss512k\n\n栈内存的大小（决定方法调用深度）\n\n-xx:metaspacesize=256m\n\n元空间\n\n-xx:maxmetaspacesize=512m\n\n最大元空间大小\n\n\n# 0、java虚拟机补充说明\n\n从java se 7开始，hotspot vm就是java规范的“参考实现”。把它叫做“标准jvm”完全不为过。\n\n当大家说起“java性能如何如何”、“java有多少种gc”、“jvm如何调优”云云，经常默认说的就是特指hotspot vm。可见其“主流性”。\n\njdk8的hotspot vm已经是以前的hotspot vm与jrockit vm的合并版，也就是传说中的“hotrockit”，只是产品里名字还是叫hotspot vm。\n\n这个合并并不是要把jrockit的部分代码插进hotspot里，而是把前者一些有价值的功能在后者里重新实现一遍。移除permgen、java flight recorder、jcmd等都属于合并项目的一部分。\n\n\n# 1、jvm内存模型\n\n\n# 1.1 内存模型图\n\n\n\n\n# 1.2 jvm内存参数设置\n\n\n\n-xss设越小count值越小，说明一个线程栈里能分配的栈帧就越少，但对jvm整体来说能开启的线程数会更多。\n\n\n# 1.3 为什么要将永久代（permgen）替换为元空间（metaspace）？\n\n1.永久代受限于jvm本身设置的固定大小上限。元空间使用的是直接内存，只受本机可用内存限制。\n\n\n\n\n# 1.4 jvm内存模型包括哪些数据区域？\n\n主要包括5大块。\n\n1.方法区（元空间），堆都为数据共享区域，有线程安全问题。\n\n2.栈、本地方法栈、程序计数器为独享区域，不存在线程问题。\n\n# 1.4.1 方法区（元空间）\n\n存储已被虚拟机加载的类信息、常量、静态变量，即编译器编译后的代码等数据。方法区还有一个别名叫non-heap（非堆）。\n\n# 1.4.2 堆\n\n此内存区域的唯一目的就是存放对象实例，几乎所有对象实例以及数组都在这里分配内存。\n\njdk1.7之后开始默认开启逃逸分析：如果某些方法中的对象没有被返回或者未被外面引用（未逃逸），那么该对象可以在栈上分配内存。\n\n# 1.4.3 栈\n\n栈也就是java虚拟机栈，由一个个栈帧组成，每个栈帧拥有：\n\n局部变量表、操作数栈、动态链接、方法出口信息。\n\n局部变量表主要存放编译期可知的各种数据类型（byte、short、int、long、float、double、boolean、char）、对象引用。\n\n每一次方法的调用都会有一个对应的栈帧被压入java栈，方法调用结束后，栈帧弹出。\n\njava方法有2种返回方式：\n\n1.return语句。\n\n2.抛出异常。\n\n不管哪种返回方式都会导致栈帧弹出。\n\n# 1.4.4 本地方法栈\n\n和虚拟机栈发挥的作用非常相似，区别是：虚拟机栈执行的是java方法服务，本地方法栈执行的是native方法服务。\n\n本地方法执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。\n\n本地方法执行完毕后也会出栈并释放内存空间。\n\n# 1.4.5 程序计数器\n\n每条线程都有独立的程序计数器，各线程之间计数器互不影响。\n\n\n# 2、类加载\n\n\n# 2.1 说一下类的加载流程？\n\n一个类的完整生命周期如下：\n\n\n\n\n\n# 2.1.1 加载\n\n类加载过程的第一步，主要完成3件事情：\n\n1.通过全类名获取定义此类的二进制字节流。\n\n2.将字节流信息转换成方法区的数据结构。\n\n3.在方法区（元空间）内存中生成一个代表该类的class对象，作为方法区这些数据的访问入口。\n\n# 2.1.2 验证\n\n确保加载的类符合jvm规范和安全，其实就是一个安全检查。\n\n# 2.1.3 准备\n\n为静态变量分配内存并赋予默认值的阶段。\n\n# 2.1.4 解析\n\n虚拟机将常量池内的符号引用替换为直接引用。\n\n也就是得到类或者字段、方法在内存中的指针或者偏移量。\n\n# 2.1.5 初始化\n\n初始化静态变量为指定的值，执行静态代码块。\n\n\n\n# 2.1.6 卸载\n\n卸载类即该类的class对象被gc。\n\n卸载需要满足3个条件：\n\n1.该类的所有实例对象已被gc。\n\n2.该类没有在其他任何地方被引用。\n\n3.该类的类加载器的实例已被gc。\n\n所以，在jvm生命周期内，由jvm自带的类加载器加载的类是不会被卸载的。自定义的类加载器加载的类可能被卸载。\n\n\n# 2.2 双亲委派机制\n\n# 2.2.1 为什么要设计双亲委派机制?\n\n1）沙箱安全机制:自己写的java.lang.string.class类不会被加载，这样便可以防止核心api库被随意篡改。\n\n2）避免类的重复加载:当父亲已经加载了该类时，就没有必要子classloader再加载一次，保证被加载类的唯一性。\n\n# 2.2.2 双亲委派的加载顺序？\n\n\n\n双亲委派加载顺序为什么要从:\n\nappcclassloader -> extclassloader -> bootstrapclassloader -> extclassloader -> appcclassloader\n\n为什么不直接:\n\nbootstrapclassloader -> extclassloader -> appcclassloader\n\n答：开发的应用中大部分用到的是appclassloader，第一次加载会麻烦一点，但是第二次加载如果发现该类已经加载过（c++实现），则直接用该加载器加载。\n\n# 2.2.3 怎么实现自定义加载器？\n\n继承classloader，重写classloader类中的findclass方法。\n\n除了bootstrapclassloader，其他类加载器均由java实现且全部继承自java.lang.classloader。\n\n# 2.2.4 怎么打破双亲委派机制？\n\n重写loadclass方法。\n\n\n# 3、虚拟机对象\n\n\n# 3.1 对象的创建包含哪些步骤？\n\n\n\n# 3.1.1 类加载检查\n\n虚拟机遇到一条new指令时，首先去检查这个指令的参数能否在class常量池中定位到一个类的符号引用，且检查这个符号引用代表的类是否已加载、解析和初始化过。如果没有，先执行相应的类加载过程。\n\nnew指令指：new关键词、对象克隆、对象序列化等。\n\n# 3.1.2内存分配\n\n在类加载检查通过后，接下来虚拟机将为新生对象分配内存。\n\n对象所需的内存大小在类加载完成后便可确定，为对象分配内存等同把一块确定大小的内存从java堆中划分出来。\n\n# 3.1.2.1 内存分配有哪些方式？\n\n分配内存的方式有 指针碰撞 和 空闲列表 2种。\n\n选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否有压缩整理功能决定。\n\n# 1 指针碰撞\n\n适用场合：堆内存规整（即没有内存碎片）的情况下。\n\n原理：所有用过的内存全部整合到一边，没有用过的内存放在另外一边，中间有一个分界指针，只需要向着没用过的内存方向将指针移动对象内存大小位置即可。\n\n使用该分配方式的gc收集器：serial，parnew。\n\n# 2 空闲列表\n\n适用场合：堆内存不规整的情况下。\n\n原理：jvm维护一个列表，该列表会记录哪些内存块是可用的，在分配内存的时候，找到一块足够大的内存块划分给对象实例，最后更新列表记录。\n\n使用该分配方式的gc收集器：cms。\n\n# 3.1.2.2 内存分配的并发问题怎么解决？\n\n创建对象是很频繁的问题，需保证线程安全。目前，虚拟机采用了2种方式来保证线程安全：\n\n# 1 cas+失败重试\n\ncas操作失败就重试，直到成功为止。保证更新操作的原子性。\n\n# 2 tlab\n\n缓冲区（thread local allocation buffer）\n\njvm为每一个线程预先在eden区分配一块内存，给线程中的对象分配内存时，先在tlab上分配，当对象大于tlab的剩余内存或tlab的内存用尽时，采用 cas+失败重试 的方式分配内存。\n\n# 3.1.3 初始化零值\n\n内存分配完成后，jvm将分配到的内存空间都初始化为零值。\n\n这一步保证了对象的实例字段可以不赋初始值就直接使用。\n\n# 3.1.4 设置对象头\n\n初始化零值完成后，jvm开始设置对象头。\n\n对象头主要包括2部分信息（如果是数组对象，还有一个数组长度）：\n\n1.哈希码、gc分代年龄、锁状态标识等。\n\n2.指向类元数据的指针，jvm通过这个指针来确定这个对象是哪个类的实例。\n\n# 3.1.5 执行init方法\n\n执行innit方法，对应到语言层面上讲，就是为属性赋值（与上面的赋零值不同），和执行构造方法。\n\n\n# 3.2 对象栈上分配\n\n通过创建对象时的内存分配可以知道java中的对象都是在堆上进行分配，需要依靠gc进行内存回收，如果对象数量较多的时候，会给gc带来较大压力，间接影响应用的性能。\n\njvm通过逃逸分析来确定方法内的对象会不会被外部访问（即会不会“逃逸”），如果不会逃逸就可以在栈上给该对象分配内存，这样该对象所占用的内存空间就可以随着栈帧的出栈而销毁。\n\n栈上分配一般同时依赖逃逸分析和标量替换。\n\n# 3.2.1 对象逃逸分析\n\n就是分析方法内对象是否会被外部引用（是否逃逸），未逃逸的对象在栈上分配内存。\n\njdk7之后默认开启逃逸分析。\n\n# 3.2.2 标量替换\n\n标量和聚合量：\n\n1.基础类型和对象的引用可以理解为标量，它们不能被进一步分解。\n\n2.能被进一步分解的就是聚合量，比如：对象。\n\n标量替换：将对象成员变量分解成分散的变量，这些分散的变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配。\n\n\n# 3.3 对象的内存布局\n\n对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充。\n\n# 3.3.1 对象头\n\n对象头主要由3部分组成：mark word、指向类的指针、数组长度（只有数组对象有）\n\n# 1 mark word\n\nmark word记录了哈希码、gc分代年龄、锁标识等信息。\n\n在32位的jvm中长度是32bit，在64位的jvm中长度是64bit。\n\n\n\n# 2 指向类的指针\n\njava对象的类数据保存在方法区。\n\n该指针在32位的jvm中长度是32bit，在64位的jvm中长度是64bit。\n\n# 3 数组长度（只有数组对象有）\n\n该对象在32位和64位的jvm中长度都是32bit。\n\n# 3.3.2 实例数据\n\n对象真正存储的有效信息，也就是程序中定义的各种类型的字段内容。\n\n# 3.3.3 对齐填充\n\n对齐填充不是必然存在的，只是因为hotspot要求对象大小必须是8字节的整数倍。\n\n而对象头部分是8字节的倍数（1倍或2倍），所以实例数据部分没有对齐时，需要对齐填充来补全。\n\n\n# 3.4 对象的访问定位\n\njava程序通过栈上的reference数据来操作堆上的具体对象。由于reference类型在jvm规范中只定义了一个指向对象的引用，没有说明这个引用通过何种方式去定位、访问堆中对象的具体位置，所以访问的方式取决于jvm的实现。目前主要的访问方式由2种：句柄和直接指针。\n\n# 3.4.1 句柄\n\njava堆中会划分出一块内存来作为句柄池，reference存放的是对象的句柄地址，而句柄中包括对象实例的地址和对象class的地址。\n\n\n\n# 3.4.2 直接指针\n\nreference存放的是对象实例地址。对象实例数据的对象头里包含class的地址。\n\n\n\n# 3.4.3 两种访问方式各有什么优势？\n\n1.句柄访问最大的好处是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针，reference不需要修改。\n\n2.直接指针访问的好处是速度快，减少了一次指针定位的时间开销。\n\n\n# 4、垃圾回收\n\n内存回收很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc。\n\n\n# 4.1 java堆的内存分配与回收\n\n堆空间的基本结构：\n\n\n\n1.大部分情况下，对象首先在eden区域分配。\n\n2.在一次新生代垃圾回收后（eden区和survivor区回收），如果对象还存活，则进入s0或s1，并且年龄加1。\n\n3.当对象年龄增加到一定程度（默认大于15），就会被晋升到老年代。\n\n晋升到老年代的年龄设置可以通过指定参数配置，但这个值会在虚拟机运行过程中调整。\n\n\n# 4.2 空间分配担保\n\n空间分配担保是为了确保在minor gc之前老年代本身还有容纳新生代所有对象的剩余空间。\n\n空间分配担保的规则为：\n\n只要老年代的连续空间大于新生代对象的总大小或者大于历次晋升的平均大小，就会进行minor gc，\n\n否则进行full gc。\n\n\n# 4.3 怎么判断对象已经死亡？\n\n# 4.3.1 引用计数法\n\n给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效时，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。\n\n这个方法使用简单，效率高，但是主流的虚拟机都没有用它来管理内存，主要原因是它很难解决对象之间相互循环引用的问题。\n\n# 4.3.2 可达性分析算法\n\n# 1 介绍\n\n将指定类型的对象作为gc roots节点，从这些节点开始搜索，将有引用的节点串成一条引用链，当一个对象到gc roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。\n\n下图中object6 ~ object10之间虽有引用关系，但他们到gc roots不可达，因此为需要被回收的对象。\n\n\n\n# 2 哪些对象可以作为gc roots呢？\n\n1.虚拟机栈中引用的对象\n\n2.本地方法栈中引用的对象\n\n3.方法区中类静态属性引用的对象\n\n4.方法区中常量引用的对象\n\n5.所有被同步锁持有的对象\n\n\n# 4.4 怎么判断一个类是无用的类？\n\n方法区主要回收的是无用的类，判断一个类无用，需要同时满足以下3个条件：\n\n1.该类的所有实例都已经被回收，也就是jvm堆中不存在该类的任何实例。\n\n2.加载该类的加载器classloader已经被回收。\n\n3.该类对应的java.lang.class对象没有在任何地方被引用，无法在任何地方通过反射的方式访问该类。\n\n\n# 4.5 垃圾收集算法\n\n# 4.5.1 标记-清除算法\n\n该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：\n\n1.效率问题\n\n2.空间问题（标记清除后会产生大量不连续的碎片）\n\n\n\n# 4.5.2 标记-复制算法\n\n将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。\n\n\n\n# 4.5.3 标记-整理算法\n\n标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。\n\n\n\n# 4.5.4 分代收集算法\n\n当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。\n\n一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。\n\n比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。\n\n而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。\n\n\n# 4.6 垃圾收集器\n\n# 4.6.1 serial收集器\n\nserial（串行）收集器：单线程收集器。仅用一条线程完成垃圾收集工作，且运行期间必须暂停其他所有工作线程（stop the world），直到它收集结束。\n\n新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n缺点：暂停所有线程影响用户体验。\n\n优点：简单高效，没有线程交互的开销。\n\n# 4.6.2 parnew收集器(-xx:+useparnewgc)\n\nparnew收集器其实就是serial收集器的多线程版本，除了多线程，其他行为一样。\n\n它可以和cms收集器配合使用（新生代使用parnew，老年代使用cms）。\n\n\n\n# 4.6.3 parallel scanvenge 收集器\n\njdk1.8的默认收集器，新生代采用标记-复制算法，老年代采用标记-整理算法。\n\n\n\n看上去几乎和parnew都一样。parallel scavenge收集器主要在于高效率的利用cpu。\n\n# 4.6.4 cms收集器（4-8g）\n\n-xx:+useconcmarksweepgc(old)\n\n# 4.6.4.1介绍\n\ncms(concurrent mark sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。\n\n它非常符合在注重用户体验的应用上使用，它是hotspot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程 (基本上)同时工作。\n\n从名字中的mark sweep这两个词可以看出，cms收集器是一种 “标记-清除”算法实现的，它的运作过程相对复杂一些。整个过程分为四个步骤:\n\n\n\n1 初始标记\n\n暂停所有的其他线程(stw)，并记录下gc roots直接能引用的对象，速度很快。\n\n2 并发标记\n\n并发标记阶段就是从gc roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。因为用户程序继续运行，可能会有导致已经标记过的对象状态发生改变。\n\n3 重新标记\n\n重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。主要用到三色标记里的增量更新算法做重新标记。\n\n4 并发清理\n\n开启用户线程，同时gc线程开始对未标记的区域做清扫。这个阶段如果有新增对象会被标记为黑色不做任何处理。\n\n5 并发重置\n\n重置本次gc过程中的标记数据。\n\n# 4.6.4.2 cms优缺点\n\n优点:\n\n并发收集、低停顿。\n\n缺点:\n\n1）对cpu资源敏感(会和服务抢资源)。\n\n2）无法处理浮动垃圾(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾要等到下一次gc再清理)。\n\n3）它使用的回收算法是“标记-清除”算法，会导致收集结束时会有大量空间碎片产生。当然通过参数- xx:+usecmscompactatfullcollection可以让jvm在执行完标记清除后再做整理。\n\n4）执行过程中的不确定性，会存在上一次垃圾回收还没执行完，然后垃圾回收又被触发的情况，特别是在并 发标记和并发清理阶段会出现，一边回收，系统一边运行，也许没回收完就再次触发full gc，也就是"concurrent mode failure"，此时会进入stop the world，用serial old垃圾收集器来回收。\n\n# 4.6.5 g1收集器\n\ng1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。具备高吞吐量性能特征。\n\ng1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的region。\n\ng1收集器具备以下特点：\n\n1.并行与并发\n\n2.分代收集\n\n3.空间整合\n\n4.可预测的停顿\n\n# 4.6.6 如何选择垃圾收集器？\n\njdk1.8默认使用parallel。jdk1.9默认使用g1。\n\nes、kafka内存较大的可使用g1。\n\n1.如果内存小于100m，使用串行收集器。\n\n2.如果是单核，并且没有停顿时间要求，串行或者jvm自己选择。\n\n3.如果响应时间最重要，并且不能超过1秒，使用并发收集器。\n\n1.内存4g以下可以用parallel。\n\n2.内存4-8g可以用parnew+cms。\n\n3.内存8g以上可以用g1。\n\n4.内存几百g以上用zgc。\n\n\n# 4.7 三色标记\n\n# 4.7.1 介绍\n\njvm中的垃圾回收是基于标记-复制、标记清除和标记-整理三种模式的，其中最重要的是如何标记。\n\n像serial、parnew这类回收器，本质是暂停用户线程进行全面标记的算法。缺点是标记时间长导致stw时间也长，影响体验。\n\n像cms、g1这类回收器，使用的是并发标记，可以在不暂停用户线程的情况下进行标记，从而可以用极少的时间或者没有中断来进行gc。实现并发标记的算法就是三色标记法。\n\n\n\n标记过程：\n\n1.在gc标记刚开始的阶段，所有对象均为白色集合。\n\n2.将所有gc roots直接引用的对象标记成灰色集合。\n\n3.判断若灰色集合中的对象不存在子引用，则将其放入黑色集合，若存在子引用对象，则将所有子引用对象放入灰色集合，当前对象放入黑色集合。\n\n4.按照步骤3，以此类推，直到灰色集合中所有对象变成黑色后，本轮标记完成。当前白色集合内所有对象称为不可达对象，即垃圾对象。\n\n问题：\n\n三色标记过程是跟用户线程并发运行的，对象引用处于随时可变的情况，可能出现多标或漏标问题。\n\n# 4.7.2 浮动垃圾（多标）\n\n本来应该是标记白色的对象，结果被标记成灰色或黑色，造成该对象不会被回收。\n\n比如e对象被d对象引用着，刚好gc在扫描，将e对象标记成灰色，此时，d对e的引用被置空，这时候e对象以及后续子引用应该被当成垃圾回收，但是因为e已经被标记为灰色，导致没有被及时清理掉，变成浮动垃圾。\n\n还有一种情况，并发标记开始后产生的新对象，通常做法是直接当成黑色，本轮不会进行清除。但是这部分对象也有可能变成垃圾，所以也算是浮动垃圾的一部分。\n\n# 4.7.3 漏标\n\n灰色对象指向白色对象的引用消失了，然后一个黑色对象重新引用了白色对象。\n\n按照三色标记算法，黑色对象是已完成状态，不会再去找子引用，这样会导致这个白色对象虽然正在被线程使用中，但是无法被标记为灰色或者黑色，造成一个正在使用的对象被错误回收。\n\n总结：漏标只有同时满足以下两个条件才会发生：\n\n1.灰色对象断开了白色对象的引用。\n\n2.黑色对象重新引用了该白色对象。\n\n解决方案：\n\ncms：incremental update算法\n\n当一个白色对象被一个黑色对象引用，将黑色对象重新标记为灰色，让垃圾回收器重新扫描。\n\n\n# 4.8 gc安全点与安全区域\n\n# 4.8.1 gc安全点\n\n当垃圾收集需要回收线程时，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程中会去查询这个标志位，一旦发现标志位为true时就自己在最近的安全点上主动中断挂起。查询标志位的地方跟安全点是重合的。\n\n触发点：\n\n1.方法返回之前。\n\n2.调用某个方法之后。\n\n3.抛出异常的位置。\n\n4.循环的末尾。\n\n# 4.8.2 安全区域\n\n安全点是针对正在执行的线程设定的。\n\n如果一个线程处在sleep或者中断状态，它就不能响应jvm的中断请求，再运行到安全点上。\n\n因此jvm引入了安全区域的概念。\n\n安全区域是指在一段代码中，引用关系不会发生变化。在这个区域内的任意地方开始gc都是安全的。\n\n\n# 5、工具命令\n\n\n# 5.1 jmap\n\njps\n\n14660 jar\n\njmap -histo 14660 > ./log.txt\n\n此命令可查看内存信息，实例个数以及占用内存大小\n\n\n\njmap -heap 14660\n\n查看堆信息\n\n\n\njmap -dump:format=b,file=test.hprof 14660\n\n也可以设置内存溢出自动导出dump文件（内存很大的时候，可能会导不出来）\n\n1.-xx:+heapdumponoutofmemoryerror\n\n2.-xx:heapdumppath=./ （路径）\n\n\n\n\n# 5.2 jstack\n\n找出占用cpu最高的线程堆栈信息\n\ntop\n\n\n\ntop -p 24\n\n\n\n按h，获取每个线程的内存情况\n\n\n\n1.找到内存和cpu占用最高的线程pid，比如797，转换成16进制得到0x31d\n\n2.执行jstack 24 | grep -a 10 31d\n\n\n\n\n# 5.3 jinfo\n\njinfo -flags 24\n\n查看jvm的参数\n\n\n\n\n# 5.4 jstat\n\njstat -gc 24\n\njstat -gc pid 最常用，可以评估程序内存使用及gc压力整体情况\n\n\n\n可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察eu(eden区的使用)来估算每秒eden大概新增多少对 象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。\n\ns0c：第一个幸存区的大小，单位kb\n\ns1c：第二个幸存区的大小\n\ns0u：第一个幸存区的使用大小\n\ns1u：第二个幸存区的使用大小\n\nec：伊甸园区的大小\n\neu：伊甸园区的使用大小\n\noc：老年代大小\n\nou：老年代使用大小\n\nmc：方法区大小（元空间）\n\nmu：方法区使用大小\n\nccsc：压缩类空间大小\n\nccsu：压缩类空间使用大小\n\nygc：年轻代垃圾回收次数\n\nygct：年轻代垃圾回收消耗时间，单位s\n\nfgc：老年代垃圾回收次数\n\nfgct：老年代垃圾回收消耗时间，单位s\n\ngct：垃圾回收消耗总时间，单位s\n\n优化思路其实简单来说就是尽量让每次young gc后的存活对象小于survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年 代。尽量减少full gc的频率，避免频繁full gc对jvm性能的影响。\n\n内存泄漏的一种情况：一般电商架构可能会使用多级缓存架构，就是redis加上jvm级缓存，大多数同学可能为了图方便对于jvm级缓存就 简单使用一个hashmap，于是不断往里面放缓存数据，但是很少考虑这个map的容量问题，结果这个缓存map越来越大，一直占用着老 年代的很多空间，时间长了就会导致full gc非常频繁，这就是一种内存泄漏，对于一些老旧数据没有及时清理导致一直占用着宝贵的内存 资源，时间长了除了导致full gc，还有可能导致oom。\n\n\n# 6、阿尔萨斯（arthas）\n\n\n# 6.1 trace\n\n利用trace命令追踪方法耗时。\n\nhttps://arthas.aliyun.com/doc/trace.html\n\n\n\ncurl -o https://arthas.aliyun.com/arthas-boot.jar\n\njava -jar arthas-boot.jar\n\ntrace com.yl.mhs.api.stream.kafka.receiver.waybilloggapireceiver dooggwaybillhandel\n\n\n# 6.2 reset\n\n通过reset命令可以重置增强类，将被 arthas 增强过的类全部还原，arthas 服务端关闭 时会重置所有增强过的类。\n\narthas在 watch/trace 等命令时，实际上是修改了应用的字节码，插入增强的代码。显式执行reset命令，可以清除掉这些增强代码。\n\n\n# 6.3 quit-stop\n\n退出arthas\n\n用exit或者quit命令可以退出arthas。\n\nexit quit\n\n退出arthas之后，还可以再次用 java -jar arthas-boot.jar来连接。\n\n彻底退出arthas\n\nexit/quit命令只是退出当前session，arthas server还在目标进程中运行。\n\n想完成退出arthas，可以执行stop命令。\n\nstop\n\n\n# 6.4 thread\n\n查看当前线程信息，查看线程的堆栈。\n\nthread -b\n\n找出当前阻塞其他线程的线程\n\n\n\n\n# 6.5 sysprop\n\n查看当前jvm的系统属性。\n\n\n\n\n# 6.6 heapdump\n\n类似jmap命令的heap dump功能。\n\nheapdump /tmp/dump.hprof\n\n\n# 6.7 dashboard\n\ndashboard命令可以查看当前系统的实时数据面板。\n\n\n\n\n# 6.8 watch\n\n观察指定方法的调用情况。能观察到的范围为：返回值、抛出异常、入参，通过编写 ognl 表达式进行对应变量的查看。\n\n\n\n观察异常信息的例子：\n\nwatch demo.mathgame primefactors "{params[0],throwexp}" -e -x 2\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"设计模式",frontmatter:{title:"设计模式",date:"2022-04-28T18:05:42.000Z",permalink:"/pages/f8ee2e/",categories:["知识整理"],tags:["设计模式"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/03.%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"知识整理/03.设计模式.md",key:"v-49b9f1b0",path:"/pages/f8ee2e/",headers:[{level:2,title:"1、责任链模式",slug:"_1、责任链模式",normalizedTitle:"1、责任链模式",charIndex:11},{level:2,title:"2、建造者模式",slug:"_2、建造者模式",normalizedTitle:"2、建造者模式",charIndex:133},{level:2,title:"3、工厂模式（结合注解）",slug:"_3、工厂模式-结合注解",normalizedTitle:"3、工厂模式（结合注解）",charIndex:216},{level:2,title:"4、模版方法模式",slug:"_4、模版方法模式",normalizedTitle:"4、模版方法模式",charIndex:831},{level:2,title:"5、策略模式",slug:"_5、策略模式",normalizedTitle:"5、策略模式",charIndex:848}],headersStr:"1、责任链模式 2、建造者模式 3、工厂模式（结合注解） 4、模版方法模式 5、策略模式",content:"# 设计模式\n\n\n# 1、责任链模式\n\n为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。可以通过数据链表来实现职责链模式。\n\n\n\n\n# 2、建造者模式\n\n将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n\n\n\n\n# 3、工厂模式（结合注解）\n\n\n\n-----------------------------------------------------------------------\n\n@ConditionalOnBean:当IOC容器中有waybillOperationProcessor接口的实现类时，才会向容器中注入WaybillOperationProcessorFactory\n\n\n\n------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n# 4、模版方法模式\n\n\n\n\n\n\n# 5、策略模式",normalizedContent:"# 设计模式\n\n\n# 1、责任链模式\n\n为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。可以通过数据链表来实现职责链模式。\n\n\n\n\n# 2、建造者模式\n\n将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n\n\n\n\n# 3、工厂模式（结合注解）\n\n\n\n-----------------------------------------------------------------------\n\n@conditionalonbean:当ioc容器中有waybilloperationprocessor接口的实现类时，才会向容器中注入waybilloperationprocessorfactory\n\n\n\n------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n\n-----------------------------------------------------------------------\n\n\n# 4、模版方法模式\n\n\n\n\n\n\n# 5、策略模式",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"排序算法",frontmatter:{title:"排序算法",date:"2022-04-28T18:06:58.000Z",permalink:"/pages/86f5d7/",categories:["知识整理"],tags:["排序算法"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/04.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html",relativePath:"知识整理/04.排序算法.md",key:"v-0a21df14",path:"/pages/86f5d7/",headers:[{level:2,title:"0、时间复杂度",slug:"_0、时间复杂度",normalizedTitle:"0、时间复杂度",charIndex:11},{level:2,title:"1、七种经典排序",slug:"_1、七种经典排序",normalizedTitle:"1、七种经典排序",charIndex:179},{level:3,title:"1.1 冒泡排序",slug:"_1-1-冒泡排序",normalizedTitle:"1.1 冒泡排序",charIndex:192},{level:3,title:"1.2 选择排序",slug:"_1-2-选择排序",normalizedTitle:"1.2 选择排序",charIndex:957},{level:3,title:"1.3 快速排序",slug:"_1-3-快速排序",normalizedTitle:"1.3 快速排序",charIndex:1863},{level:3,title:"1.4 插入排序",slug:"_1-4-插入排序",normalizedTitle:"1.4 插入排序",charIndex:3593},{level:3,title:"1.5 希尔排序",slug:"_1-5-希尔排序",normalizedTitle:"1.5 希尔排序",charIndex:4366},{level:3,title:"1.6 归并排序",slug:"_1-6-归并排序",normalizedTitle:"1.6 归并排序",charIndex:5542},{level:3,title:"1.7 堆排序",slug:"_1-7-堆排序",normalizedTitle:"1.7 堆排序",charIndex:8157},{level:2,title:"2、场景题",slug:"_2、场景题",normalizedTitle:"2、场景题",charIndex:10201},{level:3,title:"2.1 一亿数据取最大前10000个?",slug:"_2-1-一亿数据取最大前10000个",normalizedTitle:"2.1 一亿数据取最大前10000个?",charIndex:10211},{level:3,title:"2.2 一百亿数据排序？",slug:"_2-2-一百亿数据排序",normalizedTitle:"2.2 一百亿数据排序？",charIndex:10473},{level:3,title:"2.3 链表反转？",slug:"_2-3-链表反转",normalizedTitle:"2.3 链表反转？",charIndex:11106}],headersStr:"0、时间复杂度 1、七种经典排序 1.1 冒泡排序 1.2 选择排序 1.3 快速排序 1.4 插入排序 1.5 希尔排序 1.6 归并排序 1.7 堆排序 2、场景题 2.1 一亿数据取最大前10000个? 2.2 一百亿数据排序？ 2.3 链表反转？",content:'# 排序算法\n\n\n# 0、时间复杂度\n\n\n\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。\n不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。\n时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\n空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\n\n\n# 1、七种经典排序\n\n\n# 1.1 冒泡排序\n\n\n\npublic class BubbleSort {\n        public static void main(String[] args) {\n            int[] array = {3, 5, 90, 1, 6, 43, 2};\n            bubbleSort(array);\n        }\n\n        public static void bubbleSort(int[] array) {\n            for (int i = 0; i < array.length - 1; i++) {\n                for (int j = 0; j < array.length - 1 - i; j++) {\n                    if (array[j] > array[j + 1]) {\n                        int tmp = array[j];\n                        array[j] = array[j + 1];\n                        array[j + 1] = tmp;\n                    }\n                }\n            }\n            for (int k : array) {\n                System.out.print(k + " ");\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 1.2 选择排序\n\n遍历数组，每次找出当次循环中最小的数\n\n\n\n  public class SelectSort {\n        public static void main(String[] args) {\n            int[] array = {3, 50, 90, 1, 6, 43, 2};\n            selectSort(array);\n        }\n\n        public static void selectSort(int[] array) {\n            for (int i = 0; i < array.length - 1; i++) {\n                int index = i;\n                for (int j = i + 1; j < array.length; j++) {\n                    if (array[index] > array[j]) {\n                        index = j;\n                    }\n                }\n                if (index != i) {\n                    int tmp = array[i];\n                    array[i] = array[index];\n                    array[index] = tmp;\n                }\n            }\n            for (int k : array) {\n                System.out.print(k + " ");\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 1.3 快速排序\n\n\n\n分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。\n\n\n\n首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。交换哨兵i和哨兵j所指向的元素的值。\n\n\n\n到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换。\n\n\n\n第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。\n\n\n\n到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。\n\n public class QuickSort {\n        public static void main(String[] args) {\n            int[] array = {3, 50, 90, 1, 6, 43, 27};\n            quickSort(array, 0, array.length - 1);\n            for (int k : array) {\n                System.out.print(k + " ");\n            }\n        }\n\n        public static void quickSort(int[] array, int left, int right) {\n            if (left >= right) {\n                return;\n            }\n            int index = left;\n            int l = left;\n            int r = right;\n            while (l < r) {\n                while (l < r && array[r] >= array[index]) {\n                    r--;\n                }\n                while (l < r && array[l] <= array[index]) {\n                    l++;\n                }\n                int temp = array[r];\n                array[r] = array[l];\n                array[l] = temp;\n            }\n            int temp = array[index];\n            array[index] = array[l];\n            array[l] = temp;\n\n            quickSort(array, left, l);\n            quickSort(array, l + 1, right);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 1.4 插入排序\n\n\n\npublic class InsertSort {\n        public static void main(String[] args) {\n            int[] array = {4, 8, 6, 1, 2, 3};\n            insertSort(array);\n            for (int k : array) {\n                System.out.print(k + " ");\n            }\n        }\n\n        public static void insertSort(int[] a) {\n            for (int i = 0; i < a.length; i++) {\n                for (int j = i; j > 0; j--) {\n                    if (a[j] < a[j - 1]) {\n                        int temp = a[j];\n                        a[j] = a[j - 1];\n                        a[j - 1] = temp;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.5 希尔排序\n\n希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。\n\n\n\n\n\npublic class ShellSort {\n        public static void main(String[] args) {\n            int[] data = new int[]{26, 53, 67, 48, 57, 13, 48, 32, 60, 50};\n            shellSortSmallToBig(data);\n            for (int k : data) {\n                System.out.print(k + " ");\n            }\n        }\n\n        public static void shellSortSmallToBig(int[] data) {\n            int j = 0;\n            int temp = 0;\n            for (int increment = data.length / 2; increment > 0; increment /= 2) {\n                for (int i = increment; i < data.length; i++) {\n                    temp = data[i];\n                    for (j = i - increment; j >= 0; j -= increment) {\n                        if (temp < data[j]) {\n                            data[j + increment] = data[j];\n                        } else {\n                            break;\n                        }\n                    }\n                    data[j + increment] = temp;\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 1.6 归并排序\n\n\n\n可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。\n\n\n\n归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort()采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。\n\npublic class MergeSort {\n        public static void main(String[] args) {\n            int[] a = {5, 9, 11, 13, 12, 88, 1, 8, 7};\n            System.out.println("初始：" + printArray(a));\n            recursive(a, 0, a.length - 1);\n            System.out.println("排序：" + printArray(a));\n        }\n\n        public static void recursive(int[] array, int left, int right) {\n\n            if (left < right) {\n                int mid = (left + right) / 2;\n                recursive(array, left, mid);\n                recursive(array, mid + 1, right);\n                merge(array, left, mid, right);\n            }\n        }\n\n        public static void merge(int[] array, int left, int middle, int right) {\n            int array_l = left;\n            int array_r = middle + 1;\n            int[] temp = new int[right - left + 1]; //临时数组，存放比较后结果  \n            int temp_l = 0; //临时数组左下标  \n            while (array_l <= middle && array_r <= right) {\n                if (array[array_l] <= array[array_r]) {\n                    temp[temp_l++] = array[array_l++];\n                } else {\n                    temp[temp_l++] = array[array_r++];\n                }\n            }\n            while (array_l <= middle) {\n                temp[temp_l++] = array[array_l++];\n            }\n            while (array_r <= right) {\n                temp[temp_l++] = array[array_r++];\n            }\n            System.out.println("left:" + left + " middle:" + middle + " right:" + right);\n            System.out.println(printArray(temp));\n            System.out.println("----------------------------");\n            //临时数组数据塞回原数组  \n            temp_l = 0;\n            while (left <= right) {\n                array[left++] = temp[temp_l++];\n            }\n        }\n\n        public static String printArray(int[] array) {\n            StringBuilder sb = new StringBuilder();\n            sb.append("【");\n            for (int i = 0; i < array.length; i++) {\n                sb.append(array[i]);\n                if (i != array.length - 1) {\n                    sb.append(",");\n                }\n            }\n            sb.append("】");\n            return sb.toString();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 1.7 堆排序\n\n什么是堆？\n\n堆是一种非线性结构，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组但堆并不一定是完全二叉树\n\n按照堆的特点可以把堆分为大顶堆和小顶堆\n\n**大顶堆：**每个结点的值都大于或等于其左右孩子结点的值\n\n**小顶堆：**每个结点的值都小于或等于其左右孩子结点的值\n\n使用堆的原因？\n\n如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。但是如果我们的需求是对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。显然如果是线性结构，每次插入之后，假设原数组是有序的，那使用二分把它放在正确的位置也未尝不可，但是插入的时候从数组中留出空位就需要O(n)的时间复杂度，删除的时候亦然。\n\n可是如果我们将序列看作是一个集合，我们需要的是这个集合的一个最小值或者最大值，并且，在它被任意划分成为若干个子集的时候，这些子集的最小值或者最大值我们也是知道的，这些子集被不断划分，我们依然知道这些再次被划分出来的子集的最小值或者最大值。而且我们去想办法去保持这样的一个性质，那么这个问题是不是变得非常好解决了呢？那么问题就转换成了一种集合之间的关系，并且是非常明显的一种包含关系，那么最适合于解决这种集合上的关系的数据结构是什么呢？那么就是树，所以就形成了这样的一种树，他的每一个节点都比它的子节点们小或者大。 当我们插入一个新的节点的时候，实际上我们需要去调整的大部分时候只是这棵树上的一条路径，也就是决定它在哪一个集合里面，树上的路径长度相对于这个集合，由于是对数级别的，所以非常可以接受，那么这种数据结构也就应运而生，而这个数据结构为什么叫做堆，那就不知道了。\n\n\n\npublic class HeapSort {\n        public static void main(String[] args) {\n            int[] array = {20, 7, 18, 2, 5, 17, 16};\n            for (int i = array.length / 2 - 1; i >= 0; i--) {\n                adjust(array, i, array.length);\n            }\n            for (int pos = array.length - 1; pos > 0; pos--) {\n                int temp = array[0];\n                array[0] = array[pos];\n                array[pos] = temp;\n                adjust(array, 0, pos);\n            }\n            \n            for (int k : array) {\n                System.out.print(k + " ");\n            }\n        }\n\n        public static void adjust(int[] a, int index, int len) {\n            int endPos = len - 1;\n            int left = 2 * index + 1; //左节点  \n\n            int pos = left; //指针指向左节点  \n            if (left > endPos) { //左节点超过数组长度  \n                return;\n            }\n            if (left < endPos && a[left + 1] > a[left]) {\n                pos = left + 1; //指针指向右节点  \n            }\n            if (a[index] < a[pos]) {\n                int temp = a[index];\n                a[index] = a[pos];\n                a[pos] = temp;\n                adjust(a, pos, len);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2、场景题\n\n\n# 2.1 一亿数据取最大前10000个?\n\n采用最小堆法，首先读入前 10000 个数来创建大小为 10000 的最小堆，建堆的时间复 杂度为 O(mlogm)(m 为数组的大小即为 10000)，然后遍历后续的数字，并于堆顶(最小)数字进行比较。如果比最小的数小，则继续读取后续数字;如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有 10000 个数字。该算法的时间复杂度为 O (nmlogm)，空间复杂度是 10000(常数)。\n\n\n# 2.2 一百亿数据排序？\n\n\n\n假设为int型，则：\n\n100亿数字 = 4 * 100 0000 0000 B = 4 * 9765625K（约等于400 0000 0 K） = 4 * 9536M（约等于40000M） = 37.25G（约等于40G）\n\n1.把这个37GB的大文件，用哈希分成1000个小文件，每个小文件平均37MB左右（理想情况），把100亿个数字对1000取模，模出来的结果在0到999之间，每个结果对应一个文件，所以我这里取的哈希函数是 h = x % 1000，哈希函数取得”好”，能使冲突减小，结果分布均匀。\n\n2.拆分完了之后，得到一些几十MB的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。\n\n3.1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。\n\n首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素\n\n然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。\n\n按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了。\n\n\n# 2.3 链表反转？\n\n public static void main(String[] args) {\n        Node node3 = new Node(3, null);\n        Node node2 = new Node(2, node3);\n        Node node1 = new Node(1, node2);\n        reverse(node1);\n        Node current = node3;\n        while (current != null) {\n            System.out.println(current.getCurrentId());\n            current = current.getNext();\n        }\n    }\n\n    public static void reverse(Node head) {\n        Node current = head;\n        Node prev = null;\n        Node next = null;\n        while (current != null) {\n            next = current.getNext();\n            current.setNext(prev);\n            prev = current;\n            current = next;\n        }\n    }\n\n\t\tpublic class Node {\n    \t\tprivate Node next;\n      \tprivate Integer currentId;\n      \n      \tpublic Node(Integer currentId, Node next) {\n        \tthis.next = next;\n        \tthis.currentId currentId;\n      \t}\n      \n      \tpublic Node getNext() {\n        \treturn this.next;\n      \t}\n      \n      \tpublic void setNext(Node next) {\n        \tthis.next = next;\n      \t}\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',normalizedContent:'# 排序算法\n\n\n# 0、时间复杂度\n\n\n\n稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。\n不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。\n时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。\n空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。\n\n\n# 1、七种经典排序\n\n\n# 1.1 冒泡排序\n\n\n\npublic class bubblesort {\n        public static void main(string[] args) {\n            int[] array = {3, 5, 90, 1, 6, 43, 2};\n            bubblesort(array);\n        }\n\n        public static void bubblesort(int[] array) {\n            for (int i = 0; i < array.length - 1; i++) {\n                for (int j = 0; j < array.length - 1 - i; j++) {\n                    if (array[j] > array[j + 1]) {\n                        int tmp = array[j];\n                        array[j] = array[j + 1];\n                        array[j + 1] = tmp;\n                    }\n                }\n            }\n            for (int k : array) {\n                system.out.print(k + " ");\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 1.2 选择排序\n\n遍历数组，每次找出当次循环中最小的数\n\n\n\n  public class selectsort {\n        public static void main(string[] args) {\n            int[] array = {3, 50, 90, 1, 6, 43, 2};\n            selectsort(array);\n        }\n\n        public static void selectsort(int[] array) {\n            for (int i = 0; i < array.length - 1; i++) {\n                int index = i;\n                for (int j = i + 1; j < array.length; j++) {\n                    if (array[index] > array[j]) {\n                        index = j;\n                    }\n                }\n                if (index != i) {\n                    int tmp = array[i];\n                    array[i] = array[index];\n                    array[index] = tmp;\n                }\n            }\n            for (int k : array) {\n                system.out.print(k + " ");\n            }\n        }\n\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 1.3 快速排序\n\n\n\n分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从右往左找一个小于6的数，再从左往右找一个大于6的数，然后交换他们。\n\n\n\n首先哨兵j开始出动。因为此处设置的基准数是最左边的数，所以需要让哨兵j先出动，这一点非常重要（请自己想一想为什么）。哨兵j一步一步地向左挪动（即j–），直到找到一个小于6的数停下来。接下来哨兵i再一步一步向右挪动（即i++），直到找到一个数大于6的数停下来。最后哨兵j停在了数字5面前，哨兵i停在了数字7面前。交换哨兵i和哨兵j所指向的元素的值。\n\n\n\n到此，第一次交换结束。接下来开始哨兵j继续向左挪动（再友情提醒，每次必须是哨兵j先出发）。他发现了4（比基准数6要小，满足要求）之后停了下来。哨兵i也继续向右挪动的，他发现了9（比基准数6要大，满足要求）之后停了下来。此时再次进行交换。\n\n\n\n第二次交换结束，“探测”继续。哨兵j继续向左挪动，他发现了3（比基准数6要小，满足要求）之后又停了下来。哨兵i继续向右移动，糟啦！此时哨兵i和哨兵j相遇了，哨兵i和哨兵j都走到3面前。说明此时“探测”结束。我们将基准数6和3进行交换。\n\n\n\n到此第一轮“探测”真正结束。此时以基准数6为分界点，6左边的数都小于等于6，6右边的数都大于等于6。\n\n public class quicksort {\n        public static void main(string[] args) {\n            int[] array = {3, 50, 90, 1, 6, 43, 27};\n            quicksort(array, 0, array.length - 1);\n            for (int k : array) {\n                system.out.print(k + " ");\n            }\n        }\n\n        public static void quicksort(int[] array, int left, int right) {\n            if (left >= right) {\n                return;\n            }\n            int index = left;\n            int l = left;\n            int r = right;\n            while (l < r) {\n                while (l < r && array[r] >= array[index]) {\n                    r--;\n                }\n                while (l < r && array[l] <= array[index]) {\n                    l++;\n                }\n                int temp = array[r];\n                array[r] = array[l];\n                array[l] = temp;\n            }\n            int temp = array[index];\n            array[index] = array[l];\n            array[l] = temp;\n\n            quicksort(array, left, l);\n            quicksort(array, l + 1, right);\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 1.4 插入排序\n\n\n\npublic class insertsort {\n        public static void main(string[] args) {\n            int[] array = {4, 8, 6, 1, 2, 3};\n            insertsort(array);\n            for (int k : array) {\n                system.out.print(k + " ");\n            }\n        }\n\n        public static void insertsort(int[] a) {\n            for (int i = 0; i < a.length; i++) {\n                for (int j = i; j > 0; j--) {\n                    if (a[j] < a[j - 1]) {\n                        int temp = a[j];\n                        a[j] = a[j - 1];\n                        a[j - 1] = temp;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 1.5 希尔排序\n\n希尔排序也成为“缩小增量排序”，其基本原理是，现将待排序的数组元素分成多个子序列，使得每个子序列的元素个数相对较少，然后对各个子序列分别进行直接插入排序，待整个待排序列“基本有序”后，最后在对所有元素进行一次直接插入排序。\n\n\n\n\n\npublic class shellsort {\n        public static void main(string[] args) {\n            int[] data = new int[]{26, 53, 67, 48, 57, 13, 48, 32, 60, 50};\n            shellsortsmalltobig(data);\n            for (int k : data) {\n                system.out.print(k + " ");\n            }\n        }\n\n        public static void shellsortsmalltobig(int[] data) {\n            int j = 0;\n            int temp = 0;\n            for (int increment = data.length / 2; increment > 0; increment /= 2) {\n                for (int i = increment; i < data.length; i++) {\n                    temp = data[i];\n                    for (j = i - increment; j >= 0; j -= increment) {\n                        if (temp < data[j]) {\n                            data[j + increment] = data[j];\n                        } else {\n                            break;\n                        }\n                    }\n                    data[j + increment] = temp;\n                }\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 1.6 归并排序\n\n\n\n可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。\n\n\n\n归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中arrays.sort()采用了一种名为timsort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为o(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为o(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为o(nlogn)。\n\npublic class mergesort {\n        public static void main(string[] args) {\n            int[] a = {5, 9, 11, 13, 12, 88, 1, 8, 7};\n            system.out.println("初始：" + printarray(a));\n            recursive(a, 0, a.length - 1);\n            system.out.println("排序：" + printarray(a));\n        }\n\n        public static void recursive(int[] array, int left, int right) {\n\n            if (left < right) {\n                int mid = (left + right) / 2;\n                recursive(array, left, mid);\n                recursive(array, mid + 1, right);\n                merge(array, left, mid, right);\n            }\n        }\n\n        public static void merge(int[] array, int left, int middle, int right) {\n            int array_l = left;\n            int array_r = middle + 1;\n            int[] temp = new int[right - left + 1]; //临时数组，存放比较后结果  \n            int temp_l = 0; //临时数组左下标  \n            while (array_l <= middle && array_r <= right) {\n                if (array[array_l] <= array[array_r]) {\n                    temp[temp_l++] = array[array_l++];\n                } else {\n                    temp[temp_l++] = array[array_r++];\n                }\n            }\n            while (array_l <= middle) {\n                temp[temp_l++] = array[array_l++];\n            }\n            while (array_r <= right) {\n                temp[temp_l++] = array[array_r++];\n            }\n            system.out.println("left:" + left + " middle:" + middle + " right:" + right);\n            system.out.println(printarray(temp));\n            system.out.println("----------------------------");\n            //临时数组数据塞回原数组  \n            temp_l = 0;\n            while (left <= right) {\n                array[left++] = temp[temp_l++];\n            }\n        }\n\n        public static string printarray(int[] array) {\n            stringbuilder sb = new stringbuilder();\n            sb.append("【");\n            for (int i = 0; i < array.length; i++) {\n                sb.append(array[i]);\n                if (i != array.length - 1) {\n                    sb.append(",");\n                }\n            }\n            sb.append("】");\n            return sb.tostring();\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 1.7 堆排序\n\n什么是堆？\n\n堆是一种非线性结构，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组但堆并不一定是完全二叉树\n\n按照堆的特点可以把堆分为大顶堆和小顶堆\n\n**大顶堆：**每个结点的值都大于或等于其左右孩子结点的值\n\n**小顶堆：**每个结点的值都小于或等于其左右孩子结点的值\n\n使用堆的原因？\n\n如果仅仅是需要得到一个有序的序列，使用排序就可以很快完成，并不需要去组织一个新的数据结构。但是如果我们的需求是对于一个随时会有更新的序列，我要随时知道这个序列的最小值或最大值是什么。显然如果是线性结构，每次插入之后，假设原数组是有序的，那使用二分把它放在正确的位置也未尝不可，但是插入的时候从数组中留出空位就需要o(n)的时间复杂度，删除的时候亦然。\n\n可是如果我们将序列看作是一个集合，我们需要的是这个集合的一个最小值或者最大值，并且，在它被任意划分成为若干个子集的时候，这些子集的最小值或者最大值我们也是知道的，这些子集被不断划分，我们依然知道这些再次被划分出来的子集的最小值或者最大值。而且我们去想办法去保持这样的一个性质，那么这个问题是不是变得非常好解决了呢？那么问题就转换成了一种集合之间的关系，并且是非常明显的一种包含关系，那么最适合于解决这种集合上的关系的数据结构是什么呢？那么就是树，所以就形成了这样的一种树，他的每一个节点都比它的子节点们小或者大。 当我们插入一个新的节点的时候，实际上我们需要去调整的大部分时候只是这棵树上的一条路径，也就是决定它在哪一个集合里面，树上的路径长度相对于这个集合，由于是对数级别的，所以非常可以接受，那么这种数据结构也就应运而生，而这个数据结构为什么叫做堆，那就不知道了。\n\n\n\npublic class heapsort {\n        public static void main(string[] args) {\n            int[] array = {20, 7, 18, 2, 5, 17, 16};\n            for (int i = array.length / 2 - 1; i >= 0; i--) {\n                adjust(array, i, array.length);\n            }\n            for (int pos = array.length - 1; pos > 0; pos--) {\n                int temp = array[0];\n                array[0] = array[pos];\n                array[pos] = temp;\n                adjust(array, 0, pos);\n            }\n            \n            for (int k : array) {\n                system.out.print(k + " ");\n            }\n        }\n\n        public static void adjust(int[] a, int index, int len) {\n            int endpos = len - 1;\n            int left = 2 * index + 1; //左节点  \n\n            int pos = left; //指针指向左节点  \n            if (left > endpos) { //左节点超过数组长度  \n                return;\n            }\n            if (left < endpos && a[left + 1] > a[left]) {\n                pos = left + 1; //指针指向右节点  \n            }\n            if (a[index] < a[pos]) {\n                int temp = a[index];\n                a[index] = a[pos];\n                a[pos] = temp;\n                adjust(a, pos, len);\n            }\n        }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 2、场景题\n\n\n# 2.1 一亿数据取最大前10000个?\n\n采用最小堆法，首先读入前 10000 个数来创建大小为 10000 的最小堆，建堆的时间复 杂度为 o(mlogm)(m 为数组的大小即为 10000)，然后遍历后续的数字，并于堆顶(最小)数字进行比较。如果比最小的数小，则继续读取后续数字;如果比堆顶数字大，则替换堆顶元素并重新调整堆为最小堆。整个过程直至1亿个数全部遍历完为止。然后按照中序遍历的方式输出当前堆中的所有 10000 个数字。该算法的时间复杂度为 o (nmlogm)，空间复杂度是 10000(常数)。\n\n\n# 2.2 一百亿数据排序？\n\n\n\n假设为int型，则：\n\n100亿数字 = 4 * 100 0000 0000 b = 4 * 9765625k（约等于400 0000 0 k） = 4 * 9536m（约等于40000m） = 37.25g（约等于40g）\n\n1.把这个37gb的大文件，用哈希分成1000个小文件，每个小文件平均37mb左右（理想情况），把100亿个数字对1000取模，模出来的结果在0到999之间，每个结果对应一个文件，所以我这里取的哈希函数是 h = x % 1000，哈希函数取得”好”，能使冲突减小，结果分布均匀。\n\n2.拆分完了之后，得到一些几十mb的小文件，那么就可以放进内存里排序了，可以用快速排序，归并排序，堆排序等等。\n\n3.1000个小文件内部排好序之后，就要把这些内部有序的小文件，合并成一个大的文件，可以用二叉堆来做1000路合并的操作，每个小文件是一路，合并后的大文件仍然有序。\n\n首先遍历1000个文件，每个文件里面取第一个数字，组成 (数字, 文件号) 这样的组合加入到堆里（假设是从小到大排序，用小顶堆），遍历完后堆里有1000个 (数字，文件号) 这样的元素\n\n然后不断从堆顶拿元素出来，每拿出一个元素，把它的文件号读取出来，然后去对应的文件里，加一个元素进入堆，直到那个文件被读取完。拿出来的元素当然追加到最终结果的文件里。\n\n按照上面的操作，直到堆被取空了，此时最终结果文件里的全部数字就是有序的了。\n\n\n# 2.3 链表反转？\n\n public static void main(string[] args) {\n        node node3 = new node(3, null);\n        node node2 = new node(2, node3);\n        node node1 = new node(1, node2);\n        reverse(node1);\n        node current = node3;\n        while (current != null) {\n            system.out.println(current.getcurrentid());\n            current = current.getnext();\n        }\n    }\n\n    public static void reverse(node head) {\n        node current = head;\n        node prev = null;\n        node next = null;\n        while (current != null) {\n            next = current.getnext();\n            current.setnext(prev);\n            prev = current;\n            current = next;\n        }\n    }\n\n\t\tpublic class node {\n    \t\tprivate node next;\n      \tprivate integer currentid;\n      \n      \tpublic node(integer currentid, node next) {\n        \tthis.next = next;\n        \tthis.currentid currentid;\n      \t}\n      \n      \tpublic node getnext() {\n        \treturn this.next;\n      \t}\n      \n      \tpublic void setnext(node next) {\n        \tthis.next = next;\n      \t}\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"系统架构设计",frontmatter:{title:"系统架构设计",date:"2022-04-28T18:08:07.000Z",permalink:"/pages/427643/",categories:["知识整理"],tags:["架构设计"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/05.%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"知识整理/05.系统架构设计.md",key:"v-5fea683d",path:"/pages/427643/",headers:[{level:2,title:"0、前言",slug:"_0、前言",normalizedTitle:"0、前言",charIndex:13},{level:2,title:"1、高性能",slug:"_1、高性能",normalizedTitle:"1、高性能",charIndex:82},{level:3,title:"1.1 服务拆分",slug:"_1-1-服务拆分",normalizedTitle:"1.1 服务拆分",charIndex:92},{level:3,title:"1.2 缓存",slug:"_1-2-缓存",normalizedTitle:"1.2 缓存",charIndex:143},{level:3,title:"1.3 消息队列解耦削峰",slug:"_1-3-消息队列解耦削峰",normalizedTitle:"1.3 消息队列解耦削峰",charIndex:186},{level:3,title:"1.4 负载均衡",slug:"_1-4-负载均衡",normalizedTitle:"1.4 负载均衡",charIndex:226},{level:3,title:"1.5 读写分离&分库分表",slug:"_1-5-读写分离-分库分表",normalizedTitle:"1.5 读写分离&amp;分库分表",charIndex:null},{level:4,title:"1.5.1 读写分离会带来什么问题？",slug:"_1-5-1-读写分离会带来什么问题",normalizedTitle:"1.5.1 读写分离会带来什么问题？",charIndex:373},{level:4,title:"1.5.2 主从复制的原理了解吗？",slug:"_1-5-2-主从复制的原理了解吗",normalizedTitle:"1.5.2 主从复制的原理了解吗？",charIndex:528},{level:4,title:"1.5.3 分库分表会带来什么问题？",slug:"_1-5-3-分库分表会带来什么问题",normalizedTitle:"1.5.3 分库分表会带来什么问题？",charIndex:710},{level:4,title:"1.5.4 分库分表后，数据怎么迁移？",slug:"_1-5-4-分库分表后-数据怎么迁移",normalizedTitle:"1.5.4 分库分表后，数据怎么迁移？",charIndex:824},{level:2,title:"2、高可用",slug:"_2、高可用",normalizedTitle:"2、高可用",charIndex:897},{level:3,title:"2.1 怎么衡量是否高可用？",slug:"_2-1-怎么衡量是否高可用",normalizedTitle:"2.1 怎么衡量是否高可用？",charIndex:907},{level:3,title:"2.2 硬件层面保证高可用",slug:"_2-2-硬件层面保证高可用",normalizedTitle:"2.2 硬件层面保证高可用",charIndex:1141},{level:4,title:"2.2.1 什么是灾备设计？",slug:"_2-2-1-什么是灾备设计",normalizedTitle:"2.2.1 什么是灾备设计？",charIndex:1158},{level:4,title:"2.2.2 什么是异地多活？",slug:"_2-2-2-什么是异地多活",normalizedTitle:"2.2.2 什么是异地多活？",charIndex:1253},{level:4,title:"2.2.3 灾备到异地多活的演变过程？",slug:"_2-2-3-灾备到异地多活的演变过程",normalizedTitle:"2.2.3 灾备到异地多活的演变过程？",charIndex:1326},{level:3,title:"2.3 系统及代码层面保证高可用",slug:"_2-3-系统及代码层面保证高可用",normalizedTitle:"2.3 系统及代码层面保证高可用",charIndex:2057},{level:4,title:"2.3.1 集群",slug:"_2-3-1-集群",normalizedTitle:"2.3.1 集群",charIndex:2077},{level:4,title:"2.3.2 版本可回滚",slug:"_2-3-2-版本可回滚",normalizedTitle:"2.3.2 版本可回滚",charIndex:2103},{level:4,title:"2.3.3 超时重试",slug:"_2-3-3-超时重试",normalizedTitle:"2.3.3 超时重试",charIndex:2147},{level:4,title:"2.3.4 降级",slug:"_2-3-4-降级",normalizedTitle:"2.3.4 降级",charIndex:2173},{level:4,title:"2.3.5 熔断",slug:"_2-3-5-熔断",normalizedTitle:"2.3.5 熔断",charIndex:2238},{level:4,title:"2.3.6 限流",slug:"_2-3-6-限流",normalizedTitle:"2.3.6 限流",charIndex:2310},{level:5,title:"2.3.6.1 常见限流方案",slug:"_2-3-6-1-常见限流方案",normalizedTitle:"2.3.6.1 常见限流方案",charIndex:2322},{level:6,title:"1.计数器法",slug:"_1-计数器法",normalizedTitle:"1.计数器法",charIndex:2340},{level:6,title:"2.漏桶算法",slug:"_2-漏桶算法",normalizedTitle:"2.漏桶算法",charIndex:2503},{level:6,title:"3.令牌桶算法（推荐）",slug:"_3-令牌桶算法-推荐",normalizedTitle:"3.令牌桶算法（推荐）",charIndex:2647},{level:5,title:"2.3.6.2 Guava限流工具类",slug:"_2-3-6-2-guava限流工具类",normalizedTitle:"2.3.6.2 guava限流工具类",charIndex:2828},{level:6,title:"1.说明",slug:"_1-说明",normalizedTitle:"1.说明",charIndex:2850},{level:6,title:"2.代码示例",slug:"_2-代码示例",normalizedTitle:"2.代码示例",charIndex:3316},{level:2,title:"3、机器评估",slug:"_3、机器评估",normalizedTitle:"3、机器评估",charIndex:3391},{level:3,title:"3.1 pv｜qps｜tps",slug:"_3-1-pv-qps-tps",normalizedTitle:"3.1 pv｜qps｜tps",charIndex:3402},{level:3,title:"3.2 如何进行容量设计",slug:"_3-2-如何进行容量设计",normalizedTitle:"3.2 如何进行容量设计",charIndex:3934},{level:3,title:"3.3 tomcat",slug:"_3-3-tomcat",normalizedTitle:"3.3 tomcat",charIndex:4442},{level:4,title:"3.3.1 tomcat支持多少并发量",slug:"_3-3-1-tomcat支持多少并发量",normalizedTitle:"3.3.1 tomcat支持多少并发量",charIndex:4456},{level:4,title:"3.3.2 tomcat参数",slug:"_3-3-2-tomcat参数",normalizedTitle:"3.3.2 tomcat参数",charIndex:4892}],headersStr:"0、前言 1、高性能 1.1 服务拆分 1.2 缓存 1.3 消息队列解耦削峰 1.4 负载均衡 1.5 读写分离&分库分表 1.5.1 读写分离会带来什么问题？ 1.5.2 主从复制的原理了解吗？ 1.5.3 分库分表会带来什么问题？ 1.5.4 分库分表后，数据怎么迁移？ 2、高可用 2.1 怎么衡量是否高可用？ 2.2 硬件层面保证高可用 2.2.1 什么是灾备设计？ 2.2.2 什么是异地多活？ 2.2.3 灾备到异地多活的演变过程？ 2.3 系统及代码层面保证高可用 2.3.1 集群 2.3.2 版本可回滚 2.3.3 超时重试 2.3.4 降级 2.3.5 熔断 2.3.6 限流 2.3.6.1 常见限流方案 1.计数器法 2.漏桶算法 3.令牌桶算法（推荐） 2.3.6.2 Guava限流工具类 1.说明 2.代码示例 3、机器评估 3.1 pv｜qps｜tps 3.2 如何进行容量设计 3.3 tomcat 3.3.1 tomcat支持多少并发量 3.3.2 tomcat参数",content:"# 系统架构设计\n\n\n# 0、前言\n\n一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要。\n\n\n# 1、高性能\n\n\n# 1.1 服务拆分\n\n按功能纬度、读写维度（如yl-nwm-waybillouter-api）\n\n\n# 1.2 缓存\n\n浏览器缓存、cdn缓存、应用层缓存（redis、内存缓存等）\n\n\n# 1.3 消息队列解耦削峰\n\n运单收发到派签消息通过RabbitMQ发送\n\n\n# 1.4 负载均衡\n\n常见的负载均衡系统包括3种：\n\nDNS负载均衡：一般用来实现地理级别的均衡。\n\n硬件负载均衡：通过独立的硬件设备，比如F5，实现负载均衡功能（硬件价格一般较贵）。\n\n软件负载均衡：通过软件的方式，比如Nginx，实现负载均衡功能。\n\n\n# 1.5 读写分离&分库分表\n\n# 1.5.1 读写分离会带来什么问题？\n\n主库和从库数据同步存在延迟，写完数据马上读取时可能读不到最新数据。\n\n解决方法：\n\n1.强制将读请求路由到主库处理\n\n比如 Sharding-JDBC，可以通过 HintManager 分片键值管理器强制使用主库。\n\n\n\n2.延迟读取\n\n这种方式不太合适 ...\n\n# 1.5.2 主从复制的原理了解吗？\n\n1.主库将数据变化写入binlog。\n\n2.从库创建一个I/O线程向主库请求更新的binlog。\n\n3.主库创建一个线程发送binlog，从库I/O线程负责接收。\n\n4.从库I/O线程接收的binlog写入到relay log中。\n\n5.从库的SQL线程读取relay log同步数据到本地（也就是再执行一遍SQL）。\n\n# 1.5.3 分库分表会带来什么问题？\n\n1.join操作：表分布到不同数据库，导致无法进行连表操作。\n\n2.事务问题：操作不同数据库的表，自带的事务无法支持。\n\n3.分布式id：自增主键等方式无法使用，需引入分布式ID。\n\n# 1.5.4 分库分表后，数据怎么迁移？\n\n使用数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。\n\n\n# 2、高可用\n\n\n# 2.1 怎么衡量是否高可用？\n\n高可用通常通常用两个指标来衡量。\n\n平均故障时间间隔：表示两次故障的时间间隔，也就是系统正常运行平均时间。这个时间越长越稳定。\n\n故障恢复时间：系统发生故障后的恢复时间。这个时间越短，对用户影响越小。\n\n可用性跟这两个指标之间的关系为：\n\n可用性 = 平均故障时间间隔 / (平均故障时间间隔 + 故障恢复时间) * 100%\n\n这个公式得出的结果是一个「比例」，通常我们会用**「N 个 9」**来描述一个系统的可用性。\n\n\n\n\n# 2.2 硬件层面保证高可用\n\n# 2.2.1 什么是灾备设计？\n\n灾备设计 = 容灾 + 备份\n\n容灾：建立两个相同的系统。当其中一个系统出问题时，可以直接切换另一个系统使用。\n\n备份：将系统产生的重要数据进行备份。\n\n# 2.2.2 什么是异地多活？\n\n将服务部署到异地，并且多地服务能同时对外提供服务。\n\n异地多活主要应对突发情况，如火灾、地震、人为灾害等。\n\n# 2.2.3 灾备到异地多活的演变过程？\n\n同城灾备分为「冷备」和「热备」，「冷备」只备份数据，不提供服务。「热备」实时同步数据，做好随时切换的准备。\n\n\n\n同城双活比同城灾备的优势在于，两个机房都可以接入「读写」流量。提高可用性的同时也提高系统性能。（由于机房部署同一城市，可不考虑网络延迟问题。光纤传输的速度大概为 300km/ms）\n\n\n\n两地三中心是在同城双活基础上再部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害。但启用灾备机房需要耗费一定时间。（两地是指两个城市，三中心是指三个机房）\n\n\n\n异地双活才是抵御「城市」级别灾害的更好方案。异地两个机房同时提供服务，有故障随时切换，可用性高。但是实现也很复杂。异地双活要两个机房都可以读写（不同城市的两个机房如果只有一个机房数据库做主库，会导致另一个只读的机房查数据延迟很高）。MySQL本身提供了双主架构，支持双向复制数据，但是像redis、mq等都不支持双向同步数据，需要另外开发。\n\n\n\n此外，还需要在业务上将数据区分开，保证指定数据操作指定机房，避免各种脏数据的产生。这样，需要在接入层之上再部署一个**「路由层」（通常部署在云服务器上）**，自己可以配置不同路由规则，将用户分流到不同的机房内。\n\n\n\n异地多活是在异地双活的基础上扩展多个机房，这样不仅保证了高可用，还保证了高性能，可以应对更大规模的流量压力。是实现高可用的最终方案。\n\n\n\n这种星状的方案必须要设立一个**「中心机房」**，任意机房写入数据后要先同步到中心机房，再由中心机房同步到其他机房。中心机房的稳定性要求比较高，不过中心机房如果发生故障的话，可以把任意一个机房提升为中心机房，继续按照之前的架构提供服务。\n\n\n# 2.3 系统及代码层面保证高可用\n\n# 2.3.1 集群\n\n使用集群，减少单点故障。\n\n# 2.3.2 版本可回滚\n\n应用部署支持版本回滚。\n\n数据库脚本也需要有回滚脚本。\n\n# 2.3.3 超时重试\n\n重试次数一般为3次。\n\n# 2.3.4 降级\n\n同步改异步（如同步导出通过配置调整成异步导出）。\n\n直接读缓存（关键功能本来查库的调整成临时查缓存）。\n\n# 2.3.5 熔断\n\n熔断和降级是两个容易混淆的概念，这两者的含义并不一样。\n\n降级针对的是自身系统的故障，而熔断是要应对其他系统的故障。\n\n# 2.3.6 限流\n\n# 2.3.6.1 常见限流方案\n\n# 1.计数器法\n\n原理：在单位时间段内，对请求数进行计数，如果数量超过了单位时间的限制，则执行限流策略，当单位时间结束后，计数器清零，这个过程周而复始，就是计数器法。\n\n缺点：不能均衡限流，在一个单位时间的末尾和下一个单位时间的开始，很可能会有两个访问的峰值，导致系统崩溃。\n\n改进方式：可以通过减小单位时间来提高精度。\n\n# 2.漏桶算法\n\n原理：假设有一个水桶，水桶有一定的容量，所有请求不论速度都会注入到水桶中，然后水桶以一个恒定的速度向外将请求放出，当水桶满了的时候，新的请求被丢弃。\n\n优点：可以平滑请求，削减峰值。\n\n缺点：瓶颈会在漏出的速度，可能会拖慢整个系统，且不能有效地利用系统的资源。\n\n\n\n# 3.令牌桶算法（推荐）\n\n原理：有一个令牌桶，单位时间内令牌会以恒定的数量（即令牌的加入速度）加入到令牌桶中，所有请求都需要获取令牌才可正常访问。当令牌桶中没有令牌可取的时候，则拒绝请求。\n\n优点：相比漏桶算法，令牌桶算法允许一定的突发流量，但是又不会让突发流量超过我们给定的限制（单位时间窗口内的令牌数）。即限制了我们所说的 QPS(每秒查询率)。\n\n\n\n# 2.3.6.2 Guava限流工具类\n\n# 1.说明\n\nGoogle开源工具包Guava提供了限流工具类RateLimiter，基于令牌桶算法实现。\n\n常用方法：\n\ncreate(Double permitsPerSecond) 方法根据参数（令牌:单位时间（1s））比例为令牌生成速率。\ntryAcquire() 方法尝试获取一个令牌，立即返回true/false，不阻塞，重载方法具备设置获取令牌个数、获取最大等待时间等参数。\nacquire() 方法与tryAcquire类似，但是会阻塞，尝试获取一个令牌，没有时则阻塞直到获取成功。\n\n可能有人在想既然是令牌桶算法，应该有个类似定时器的东东来持续往桶放令牌才对啊，我刚开始也是这么想的，看了代码觉得自己还是太嫩了，如果开启一个定时器无可厚非，但如果系统需要N个不同速率的桶来针对不同的场景或用户，就会极大的消耗系统资源。\n\nRateLimiter用了一种类似于延迟计算的方法，把桶里令牌数量的计算放在下一个请求中计算，即桶里的令牌数 storedPermits 不是实时更新的，而是等到下一个请求过来时才更新。\n\n# 2.代码示例\n\n\n\n需关注好服务监控指标，如qps，响应时间，tomcat线程信息等（acceptcount,maxConnections）\n\n\n# 3、机器评估\n\n\n# 3.1 pv｜qps｜tps\n\npv PV(page view)，即页面浏览量。\n\nqps Queries Per Second 秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。\n\n原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间\n\n公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)\n\n机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器\n\n问：每天300w PV 的在单台机器上，这台机器需要多少QPS？\n\n答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)\n\n问：如果一台机器的QPS是58，需要几台机器来支持？\n\n答：139 / 58 = 3\n\ntps Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。\n\n一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的TPS值。\n\n\n# 3.2 如何进行容量设计\n\n**1.评估总访问量：**询问业务、产品、运营\n\n2.评估平均QPS：假设按天来计算，\n\n1天的总访问量（假设8000w） / 12小时（假设只有白天有流量）\n\n= 8000w / 约4万秒\n\n= 2000QPS\n\n3.评估高峰的QPS：需要根据具体业务特性，通过业务访问曲线来评估，\n\n如：\n\n\n\n峰值QPS约为平均QPS的2.5倍，即2000 * 2.5 = 5000QPS\n\n4.评估系统、单机的极限QPS：需要通过压测\n\n\n\n假设系统架构如上图，5000QPS的1%流量打到mysql，即500QPS，mysql还是可以轻松应对，另外99%打到redis也没有任何问题。则需要考虑的主要在web层，tomcat能不能扛的住。假设通过压测发现tomcat能扛1200QPS，线上系统一般不会泡满到极限，大概打个8折，差不多1000QPS。所以单机线上允许跑1000QPS。\n\n5.线上机器评估：假设线上部署了2台机器，\n\n1）机器能扛得住吗：峰值5000QPS，单机能扛1000QPS，2台机器扛不住。\n\n2）扛不住要加多少机器：需要额外3台，另外预留多1台，给4台更稳。\n\n\n# 3.3 tomcat\n\n# 3.3.1 tomcat支持多少并发量\n\nTomcat的最大并发数是可以配置的，实际运用中，最大并发数与硬件性能和CPU数量都有很大关系的。更好的硬件，更多的处理器都会使Tomcat支持更多的并发。\n\nTomcat默认的HTTP实现是采用阻塞式的Socket通信，每个请求都需要创建一个线程处理，当一个进程有500个线程在跑的话，那性能已经是很低很低了。Tomcat 默认配置的最大请求数是150，也就是说同时支持150个并发。具体能承载多少并发，需要看硬件的配置，CPU越多性能越高，分配给JVM的内存越多性能也就越高，但也会加重GC的负担。\n\n当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。\n\n操作系统对于进程中的线程数有一定的限制：\n\nWindows 每个进程中的线程数不允许超过 2000\n\nLinux 每个进程中的线程数不允许超过 1000\n\n在Java中每开启一个线程需要耗用1MB的JVM内存空间用于作为线程栈之用，此处也应考虑。\n\n# 3.3.2 tomcat参数\n\nmaxConnections、maxThreads、acceptCount关系\n\n用一个形象的比喻，通俗易懂的解释一下tomcat的最大线程数（maxThreads）、**最大等待数（acceptCount）和最大连接数（maxConnections）**三者之间的关系。\n\n我们可以把tomcat比做一个火锅店，流程是取号、入座、叫服务员，可以做一下三个形象的类比：\n\n（1）acceptCount 最大等待数\n\n可以类比为火锅店的排号处能够容纳排号的最大数量；排号的数量不是无限制的，火锅店的排号到了一定数据量之后，服务往往会说：已经客满。\n\n（2）maxConnections 最大连接数\n\n可以类比为火锅店的大堂的餐桌数量，也就是可以就餐的桌数。如果所有的桌子都已经坐满，则表示餐厅已满，已经达到了服务的数量上线，不能再有顾客进入餐厅了。\n\n（3）maxThreads：最大线程数\n\n可以类比为厨师的个数。每一个厨师，在同一时刻，只能给一张餐桌炒菜，就像极了JVM中的一条线程。\n\n整个就餐的流程，大致如下：\n\n（1）取号：\n\n如果maxConnections连接数没有满，就不需要取号，因为还有空余的餐桌，直接被大堂服务员领上餐桌，就餐即可。\n\n如果 maxConnections 连接数满了，但是取号人数没有达到 acceptCount，则取号成功。如果取号人数已达到acceptCount，则拿号失败，会得到Tomcat的Connection refused connect 的回复信息。\n\n（2）上桌：如果有餐桌空出来了，表示maxConnections连接数没有满，排队的人，可以进入大堂上桌就餐。\n\n（3）就餐：就餐需要厨师炒菜。厨师的数量，比顾客的数量，肯定会少一些。一个厨师一定需要给多张餐桌炒菜，如果就餐的人越多，厨师也会忙不过来。这时候就可以增加厨师，一增加到上限maxThreads的值，如果还是不够，只能是拖慢每一张餐桌的上菜速度，这种情况，就是大家常见的“上一道菜吃光了，下一道菜还没有上”尴尬场景。\n\n",normalizedContent:"# 系统架构设计\n\n\n# 0、前言\n\n一个好的软件架构，应该遵循高性能、高可用、易扩展 3 大原则，其中「高可用」在系统规模变得越来越大时，变得尤为重要。\n\n\n# 1、高性能\n\n\n# 1.1 服务拆分\n\n按功能纬度、读写维度（如yl-nwm-waybillouter-api）\n\n\n# 1.2 缓存\n\n浏览器缓存、cdn缓存、应用层缓存（redis、内存缓存等）\n\n\n# 1.3 消息队列解耦削峰\n\n运单收发到派签消息通过rabbitmq发送\n\n\n# 1.4 负载均衡\n\n常见的负载均衡系统包括3种：\n\ndns负载均衡：一般用来实现地理级别的均衡。\n\n硬件负载均衡：通过独立的硬件设备，比如f5，实现负载均衡功能（硬件价格一般较贵）。\n\n软件负载均衡：通过软件的方式，比如nginx，实现负载均衡功能。\n\n\n# 1.5 读写分离&分库分表\n\n# 1.5.1 读写分离会带来什么问题？\n\n主库和从库数据同步存在延迟，写完数据马上读取时可能读不到最新数据。\n\n解决方法：\n\n1.强制将读请求路由到主库处理\n\n比如 sharding-jdbc，可以通过 hintmanager 分片键值管理器强制使用主库。\n\n\n\n2.延迟读取\n\n这种方式不太合适 ...\n\n# 1.5.2 主从复制的原理了解吗？\n\n1.主库将数据变化写入binlog。\n\n2.从库创建一个i/o线程向主库请求更新的binlog。\n\n3.主库创建一个线程发送binlog，从库i/o线程负责接收。\n\n4.从库i/o线程接收的binlog写入到relay log中。\n\n5.从库的sql线程读取relay log同步数据到本地（也就是再执行一遍sql）。\n\n# 1.5.3 分库分表会带来什么问题？\n\n1.join操作：表分布到不同数据库，导致无法进行连表操作。\n\n2.事务问题：操作不同数据库的表，自带的事务无法支持。\n\n3.分布式id：自增主键等方式无法使用，需引入分布式id。\n\n# 1.5.4 分库分表后，数据怎么迁移？\n\n使用数据库同步工具 canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。\n\n\n# 2、高可用\n\n\n# 2.1 怎么衡量是否高可用？\n\n高可用通常通常用两个指标来衡量。\n\n平均故障时间间隔：表示两次故障的时间间隔，也就是系统正常运行平均时间。这个时间越长越稳定。\n\n故障恢复时间：系统发生故障后的恢复时间。这个时间越短，对用户影响越小。\n\n可用性跟这两个指标之间的关系为：\n\n可用性 = 平均故障时间间隔 / (平均故障时间间隔 + 故障恢复时间) * 100%\n\n这个公式得出的结果是一个「比例」，通常我们会用**「n 个 9」**来描述一个系统的可用性。\n\n\n\n\n# 2.2 硬件层面保证高可用\n\n# 2.2.1 什么是灾备设计？\n\n灾备设计 = 容灾 + 备份\n\n容灾：建立两个相同的系统。当其中一个系统出问题时，可以直接切换另一个系统使用。\n\n备份：将系统产生的重要数据进行备份。\n\n# 2.2.2 什么是异地多活？\n\n将服务部署到异地，并且多地服务能同时对外提供服务。\n\n异地多活主要应对突发情况，如火灾、地震、人为灾害等。\n\n# 2.2.3 灾备到异地多活的演变过程？\n\n同城灾备分为「冷备」和「热备」，「冷备」只备份数据，不提供服务。「热备」实时同步数据，做好随时切换的准备。\n\n\n\n同城双活比同城灾备的优势在于，两个机房都可以接入「读写」流量。提高可用性的同时也提高系统性能。（由于机房部署同一城市，可不考虑网络延迟问题。光纤传输的速度大概为 300km/ms）\n\n\n\n两地三中心是在同城双活基础上再部署一个异地机房做「灾备」，用来抵御「城市」级别的灾害。但启用灾备机房需要耗费一定时间。（两地是指两个城市，三中心是指三个机房）\n\n\n\n异地双活才是抵御「城市」级别灾害的更好方案。异地两个机房同时提供服务，有故障随时切换，可用性高。但是实现也很复杂。异地双活要两个机房都可以读写（不同城市的两个机房如果只有一个机房数据库做主库，会导致另一个只读的机房查数据延迟很高）。mysql本身提供了双主架构，支持双向复制数据，但是像redis、mq等都不支持双向同步数据，需要另外开发。\n\n\n\n此外，还需要在业务上将数据区分开，保证指定数据操作指定机房，避免各种脏数据的产生。这样，需要在接入层之上再部署一个**「路由层」（通常部署在云服务器上）**，自己可以配置不同路由规则，将用户分流到不同的机房内。\n\n\n\n异地多活是在异地双活的基础上扩展多个机房，这样不仅保证了高可用，还保证了高性能，可以应对更大规模的流量压力。是实现高可用的最终方案。\n\n\n\n这种星状的方案必须要设立一个**「中心机房」**，任意机房写入数据后要先同步到中心机房，再由中心机房同步到其他机房。中心机房的稳定性要求比较高，不过中心机房如果发生故障的话，可以把任意一个机房提升为中心机房，继续按照之前的架构提供服务。\n\n\n# 2.3 系统及代码层面保证高可用\n\n# 2.3.1 集群\n\n使用集群，减少单点故障。\n\n# 2.3.2 版本可回滚\n\n应用部署支持版本回滚。\n\n数据库脚本也需要有回滚脚本。\n\n# 2.3.3 超时重试\n\n重试次数一般为3次。\n\n# 2.3.4 降级\n\n同步改异步（如同步导出通过配置调整成异步导出）。\n\n直接读缓存（关键功能本来查库的调整成临时查缓存）。\n\n# 2.3.5 熔断\n\n熔断和降级是两个容易混淆的概念，这两者的含义并不一样。\n\n降级针对的是自身系统的故障，而熔断是要应对其他系统的故障。\n\n# 2.3.6 限流\n\n# 2.3.6.1 常见限流方案\n\n# 1.计数器法\n\n原理：在单位时间段内，对请求数进行计数，如果数量超过了单位时间的限制，则执行限流策略，当单位时间结束后，计数器清零，这个过程周而复始，就是计数器法。\n\n缺点：不能均衡限流，在一个单位时间的末尾和下一个单位时间的开始，很可能会有两个访问的峰值，导致系统崩溃。\n\n改进方式：可以通过减小单位时间来提高精度。\n\n# 2.漏桶算法\n\n原理：假设有一个水桶，水桶有一定的容量，所有请求不论速度都会注入到水桶中，然后水桶以一个恒定的速度向外将请求放出，当水桶满了的时候，新的请求被丢弃。\n\n优点：可以平滑请求，削减峰值。\n\n缺点：瓶颈会在漏出的速度，可能会拖慢整个系统，且不能有效地利用系统的资源。\n\n\n\n# 3.令牌桶算法（推荐）\n\n原理：有一个令牌桶，单位时间内令牌会以恒定的数量（即令牌的加入速度）加入到令牌桶中，所有请求都需要获取令牌才可正常访问。当令牌桶中没有令牌可取的时候，则拒绝请求。\n\n优点：相比漏桶算法，令牌桶算法允许一定的突发流量，但是又不会让突发流量超过我们给定的限制（单位时间窗口内的令牌数）。即限制了我们所说的 qps(每秒查询率)。\n\n\n\n# 2.3.6.2 guava限流工具类\n\n# 1.说明\n\ngoogle开源工具包guava提供了限流工具类ratelimiter，基于令牌桶算法实现。\n\n常用方法：\n\ncreate(double permitspersecond) 方法根据参数（令牌:单位时间（1s））比例为令牌生成速率。\ntryacquire() 方法尝试获取一个令牌，立即返回true/false，不阻塞，重载方法具备设置获取令牌个数、获取最大等待时间等参数。\nacquire() 方法与tryacquire类似，但是会阻塞，尝试获取一个令牌，没有时则阻塞直到获取成功。\n\n可能有人在想既然是令牌桶算法，应该有个类似定时器的东东来持续往桶放令牌才对啊，我刚开始也是这么想的，看了代码觉得自己还是太嫩了，如果开启一个定时器无可厚非，但如果系统需要n个不同速率的桶来针对不同的场景或用户，就会极大的消耗系统资源。\n\nratelimiter用了一种类似于延迟计算的方法，把桶里令牌数量的计算放在下一个请求中计算，即桶里的令牌数 storedpermits 不是实时更新的，而是等到下一个请求过来时才更新。\n\n# 2.代码示例\n\n\n\n需关注好服务监控指标，如qps，响应时间，tomcat线程信息等（acceptcount,maxconnections）\n\n\n# 3、机器评估\n\n\n# 3.1 pv｜qps｜tps\n\npv pv(page view)，即页面浏览量。\n\nqps queries per second 秒查询率qps是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。\n\n原理：每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间\n\n公式：( 总pv数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(qps)\n\n机器：峰值时间每秒qps / 单台机器的qps = 需要的机器\n\n问：每天300w pv 的在单台机器上，这台机器需要多少qps？\n\n答：( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (qps)\n\n问：如果一台机器的qps是58，需要几台机器来支持？\n\n答：139 / 58 = 3\n\ntps transactions per second（每秒传输的事物处理个数），即服务器每秒处理的事务数。tps包括一条消息入和一条消息出，加上一次用户数据库访问。\n\n一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。系统整体处理能力取决于处理能力最低模块的tps值。\n\n\n# 3.2 如何进行容量设计\n\n**1.评估总访问量：**询问业务、产品、运营\n\n2.评估平均qps：假设按天来计算，\n\n1天的总访问量（假设8000w） / 12小时（假设只有白天有流量）\n\n= 8000w / 约4万秒\n\n= 2000qps\n\n3.评估高峰的qps：需要根据具体业务特性，通过业务访问曲线来评估，\n\n如：\n\n\n\n峰值qps约为平均qps的2.5倍，即2000 * 2.5 = 5000qps\n\n4.评估系统、单机的极限qps：需要通过压测\n\n\n\n假设系统架构如上图，5000qps的1%流量打到mysql，即500qps，mysql还是可以轻松应对，另外99%打到redis也没有任何问题。则需要考虑的主要在web层，tomcat能不能扛的住。假设通过压测发现tomcat能扛1200qps，线上系统一般不会泡满到极限，大概打个8折，差不多1000qps。所以单机线上允许跑1000qps。\n\n5.线上机器评估：假设线上部署了2台机器，\n\n1）机器能扛得住吗：峰值5000qps，单机能扛1000qps，2台机器扛不住。\n\n2）扛不住要加多少机器：需要额外3台，另外预留多1台，给4台更稳。\n\n\n# 3.3 tomcat\n\n# 3.3.1 tomcat支持多少并发量\n\ntomcat的最大并发数是可以配置的，实际运用中，最大并发数与硬件性能和cpu数量都有很大关系的。更好的硬件，更多的处理器都会使tomcat支持更多的并发。\n\ntomcat默认的http实现是采用阻塞式的socket通信，每个请求都需要创建一个线程处理，当一个进程有500个线程在跑的话，那性能已经是很低很低了。tomcat 默认配置的最大请求数是150，也就是说同时支持150个并发。具体能承载多少并发，需要看硬件的配置，cpu越多性能越高，分配给jvm的内存越多性能也就越高，但也会加重gc的负担。\n\n当某个应用拥有 250 个以上并发的时候，应考虑应用服务器的集群。\n\n操作系统对于进程中的线程数有一定的限制：\n\nwindows 每个进程中的线程数不允许超过 2000\n\nlinux 每个进程中的线程数不允许超过 1000\n\n在java中每开启一个线程需要耗用1mb的jvm内存空间用于作为线程栈之用，此处也应考虑。\n\n# 3.3.2 tomcat参数\n\nmaxconnections、maxthreads、acceptcount关系\n\n用一个形象的比喻，通俗易懂的解释一下tomcat的最大线程数（maxthreads）、**最大等待数（acceptcount）和最大连接数（maxconnections）**三者之间的关系。\n\n我们可以把tomcat比做一个火锅店，流程是取号、入座、叫服务员，可以做一下三个形象的类比：\n\n（1）acceptcount 最大等待数\n\n可以类比为火锅店的排号处能够容纳排号的最大数量；排号的数量不是无限制的，火锅店的排号到了一定数据量之后，服务往往会说：已经客满。\n\n（2）maxconnections 最大连接数\n\n可以类比为火锅店的大堂的餐桌数量，也就是可以就餐的桌数。如果所有的桌子都已经坐满，则表示餐厅已满，已经达到了服务的数量上线，不能再有顾客进入餐厅了。\n\n（3）maxthreads：最大线程数\n\n可以类比为厨师的个数。每一个厨师，在同一时刻，只能给一张餐桌炒菜，就像极了jvm中的一条线程。\n\n整个就餐的流程，大致如下：\n\n（1）取号：\n\n如果maxconnections连接数没有满，就不需要取号，因为还有空余的餐桌，直接被大堂服务员领上餐桌，就餐即可。\n\n如果 maxconnections 连接数满了，但是取号人数没有达到 acceptcount，则取号成功。如果取号人数已达到acceptcount，则拿号失败，会得到tomcat的connection refused connect 的回复信息。\n\n（2）上桌：如果有餐桌空出来了，表示maxconnections连接数没有满，排队的人，可以进入大堂上桌就餐。\n\n（3）就餐：就餐需要厨师炒菜。厨师的数量，比顾客的数量，肯定会少一些。一个厨师一定需要给多张餐桌炒菜，如果就餐的人越多，厨师也会忙不过来。这时候就可以增加厨师，一增加到上限maxthreads的值，如果还是不够，只能是拖慢每一张餐桌的上菜速度，这种情况，就是大家常见的“上一道菜吃光了，下一道菜还没有上”尴尬场景。\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"机器配置",frontmatter:{title:"机器配置",date:"2022-04-28T18:08:53.000Z",permalink:"/pages/4a8a37/",categories:["知识整理"],tags:[null],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/06.%E6%9C%BA%E5%99%A8%E9%85%8D%E7%BD%AE.html",relativePath:"知识整理/06.机器配置.md",key:"v-512420e6",path:"/pages/4a8a37/",headersStr:null,content:"# 机器配置备忘\n\n\n\njava应用4c8g\n\nrabbitMQ 16c64g\n\nes 16c64g\n\n",normalizedContent:"# 机器配置备忘\n\n\n\njava应用4c8g\n\nrabbitmq 16c64g\n\nes 16c64g\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"定时任务",frontmatter:{title:"定时任务",date:"2022-04-28T18:09:13.000Z",permalink:"/pages/67b177/",categories:["知识整理"],tags:["定时任务"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/07.%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html",relativePath:"知识整理/07.定时任务.md",key:"v-4c85098c",path:"/pages/67b177/",headers:[{level:2,title:"1、xxl-job",slug:"_1、xxl-job",normalizedTitle:"1、xxl-job",charIndex:11},{level:3,title:"1.1 xxl-job的优缺点",slug:"_1-1-xxl-job的优缺点",normalizedTitle:"1.1 xxl-job的优缺点",charIndex:101},{level:3,title:"1.2 xxl-job的一些特性",slug:"_1-2-xxl-job的一些特性",normalizedTitle:"1.2 xxl-job的一些特性",charIndex:261},{level:3,title:"1.3 定时任务可用CompletableFutrue并发执行",slug:"_1-3-定时任务可用completablefutrue并发执行",normalizedTitle:"1.3 定时任务可用completablefutrue并发执行",charIndex:463}],headersStr:"1、xxl-job 1.1 xxl-job的优缺点 1.2 xxl-job的一些特性 1.3 定时任务可用CompletableFutrue并发执行",content:"# 定时任务\n\n\n# 1、xxl-job\n\nXxl-Job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。\n\n\n\n\n\n\n\n\n\n\n# 1.1 xxl-job的优缺点\n\n优点：\n\n1.支持集群部署。\n\n2.提供运维界面维护成本小。\n\n3.自带错误预警。\n\n4.相对elastic-job来说不需要额外的组件（zookeeper）。\n\n5.支持调度策略；\n\n6.支持分片。\n\n7.文档齐全。\n\n缺点：\n\n1.相对Quartz来说需要多部署调度中心。\n\n\n# 1.2 xxl-job的一些特性\n\n1、执行失败可以查看日志。\n\n2、支持邮件报警。\n\n3、路由策略支持轮询等策略，可以减轻执行服务器的压力。\n\n4、轮询时间等参数修改后立即生效。\n\n5、执行器有问题或新增，快速识别。\n\n6、调度中心高可用，调度中心可以集群部署（集群部署的机器时钟必须同步），如果调度中心没有做负载在执行器的配置中需要配多个地址，如果调度中心配置负载则执行器配置负载地址即可。\n\n\n# 1.3 定时任务可用CompletableFutrue并发执行\n\n",normalizedContent:"# 定时任务\n\n\n# 1、xxl-job\n\nxxl-job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。\n\n\n\n\n\n\n\n\n\n\n# 1.1 xxl-job的优缺点\n\n优点：\n\n1.支持集群部署。\n\n2.提供运维界面维护成本小。\n\n3.自带错误预警。\n\n4.相对elastic-job来说不需要额外的组件（zookeeper）。\n\n5.支持调度策略；\n\n6.支持分片。\n\n7.文档齐全。\n\n缺点：\n\n1.相对quartz来说需要多部署调度中心。\n\n\n# 1.2 xxl-job的一些特性\n\n1、执行失败可以查看日志。\n\n2、支持邮件报警。\n\n3、路由策略支持轮询等策略，可以减轻执行服务器的压力。\n\n4、轮询时间等参数修改后立即生效。\n\n5、执行器有问题或新增，快速识别。\n\n6、调度中心高可用，调度中心可以集群部署（集群部署的机器时钟必须同步），如果调度中心没有做负载在执行器的配置中需要配多个地址，如果调度中心配置负载则执行器配置负载地址即可。\n\n\n# 1.3 定时任务可用completablefutrue并发执行\n\n",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"分布式",frontmatter:{title:"分布式",date:"2022-04-28T18:10:01.000Z",permalink:"/pages/c0fe60/",categories:["知识整理"],tags:["分布式"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/08.%E5%88%86%E5%B8%83%E5%BC%8F.html",relativePath:"知识整理/08.分布式.md",key:"v-385c1de4",path:"/pages/c0fe60/",headers:[{level:3,title:"1、谈谈 RPC 的工作过程",slug:"_1、谈谈-rpc-的工作过程",normalizedTitle:"1、谈谈 rpc 的工作过程",charIndex:10},{level:3,title:"2、雪花算法",slug:"_2、雪花算法",normalizedTitle:"2、雪花算法",charIndex:513},{level:3,title:"3、什么是跨域？跨域问题怎么解决？",slug:"_3、什么是跨域-跨域问题怎么解决",normalizedTitle:"3、什么是跨域？跨域问题怎么解决？",charIndex:960},{level:2,title:"4、CAP理论，Eureka与Zookeeper区别？",slug:"_4、cap理论-eureka与zookeeper区别",normalizedTitle:"4、cap理论，eureka与zookeeper区别？",charIndex:1163},{level:2,title:"5、SOA和微服务架构的区别？",slug:"_5、soa和微服务架构的区别",normalizedTitle:"5、soa和微服务架构的区别？",charIndex:1728}],headersStr:"1、谈谈 RPC 的工作过程 2、雪花算法 3、什么是跨域？跨域问题怎么解决？ 4、CAP理论，Eureka与Zookeeper区别？ 5、SOA和微服务架构的区别？",content:"# 分布式\n\n\n# 1、谈谈 RPC 的工作过程\n\nRPC(Remote Procedure Call)即远程过程调用，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。\n\n现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成，分布式的应用可以借助RPC来完成机器之间的调用。\n\n在RPC框架中主要有三个角色：Provider、Consumer和Registry。如下图所示：\n\n\n\nRPC调用流程:\n\n1）服务消费方（client）调用以本地调用方式调用服务；\n\n2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；\n\n3）client stub找到服务地址，并将消息发送到服务端；\n\n4）server stub收到消息后进行解码；\n\n5）server stub根据解码结果调用本地的服务；\n\n6）本地服务执行并将结果返回给server stub；\n\n7）server stub将返回结果打包成消息并发送至消费方；\n\n8）client stub接收到消息，并进行解码；\n\n9）服务消费方得到最终结果。\n\n\n# 2、雪花算法\n\n\n\n41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒。\n\n10bit工作机器ID（workerId）：每台机器分配一个id，标示不同的机器，上限1024，标示一个集群某个业务最多部署的机器个数上限。\n\n12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说QPS可以到 409.6 w/s。\n\n存在问题\n\n时间回拨问题：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复。\n\n机器id分配及回收问题：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果改机器宕机了，对应的workerId分配后的回收问题。\n\n机器id上限：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。\n\n\n# 3、什么是跨域？跨域问题怎么解决？\n\n协议、域名、端口号有一个不一样就是跨域。\n\n跨域：跨域访问，简单来说就是A网站的javascript代码试图访问B网站，包括提交内容和获取内容。由于安全原因，跨域访问是被各大浏览器所默认禁止的。\n\n目前我了解的解决跨域的几种方式：\n\n1）手写过滤器\n\n2）手写拦截器\n\n3）jsonp\n\n4）注解方式\n\n5）配置nginx反向代理\n\n共五种解决方式。\n\n\n\n\n\n\n# 4、CAP理论，Eureka与Zookeeper区别？\n\n著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性Consistency)、A(可用性Availability)和P(分区容错性Partition tolerance)。\n由于分区容错性在是分布式系统中必须要保证的，因此我们只能在A和C之间进行权衡。\n在此Zookeeper保证的是CP, 而Eureka则是AP。\n1）当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。\n但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。\n问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。\n2）Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。\n而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。\n\n\n# 5、SOA和微服务架构的区别？\n\nSOA (全称:Service Oriented Architecture)\n\n一、架构划分不同\n\n1、SOA强调按水平架构划分为：前、后端、数据库、测试等；\n\n2、微服务强调按垂直架构划分，按业务能力划分，每个服务完成一种特定的功能，服务即产品。\n\n二、技术平台选择不同\n\n1、SOA应用倾向于使用统一的技术平台来解决所有问题；\n\n2、微服务可以针对不同业务特征选择不同技术平台，去中心统一化，发挥各种技术平台的特长。\n\n三、系统间边界处理机制不同\n\n1、SOA架构强调的是异构系统之间的通信和解耦合；（一种粗粒度、松耦合的服务架构）；\n\n2、微服务架构强调的是系统按业务边界做细粒度的拆分和部署。\n\n四、主要目标不同\n\n1、SOA架构，主要目标是确保应用能够交互操作；\n\n2、微服务架构，主要目标是实现新功能、并可以快速拓展开发团队。",normalizedContent:"# 分布式\n\n\n# 1、谈谈 rpc 的工作过程\n\nrpc(remote procedure call)即远程过程调用，允许一台计算机调用另一台计算机上的程序得到结果，而代码中不需要做额外的编程，就像在本地调用一样。\n\n现在互联网应用的量级越来越大，单台计算机的能力有限，需要借助可扩展的计算机集群来完成，分布式的应用可以借助rpc来完成机器之间的调用。\n\n在rpc框架中主要有三个角色：provider、consumer和registry。如下图所示：\n\n\n\nrpc调用流程:\n\n1）服务消费方（client）调用以本地调用方式调用服务；\n\n2）client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体；\n\n3）client stub找到服务地址，并将消息发送到服务端；\n\n4）server stub收到消息后进行解码；\n\n5）server stub根据解码结果调用本地的服务；\n\n6）本地服务执行并将结果返回给server stub；\n\n7）server stub将返回结果打包成消息并发送至消费方；\n\n8）client stub接收到消息，并进行解码；\n\n9）服务消费方得到最终结果。\n\n\n# 2、雪花算法\n\n\n\n41bit时间戳：这里采用的就是当前系统的具体时间，单位为毫秒。\n\n10bit工作机器id（workerid）：每台机器分配一个id，标示不同的机器，上限1024，标示一个集群某个业务最多部署的机器个数上限。\n\n12bit序列号（自增域）：表示在某一毫秒下，这个自增域最大可以分配的bit个数，在当前这种配置下，每一毫秒可以分配2^12个数据，也就是说qps可以到 409.6 w/s。\n\n存在问题\n\n时间回拨问题：由于机器的时间是动态的调整的，有可能会出现时间跑到之前几毫秒，如果这个时候获取到了这种时间，则会出现数据重复。\n\n机器id分配及回收问题：目前机器id需要每台机器不一样，这样的方式分配需要有方案进行处理，同时也要考虑，如果改机器宕机了，对应的workerid分配后的回收问题。\n\n机器id上限：机器id是固定的bit，那么也就是对应的机器个数是有上限的，在有些业务场景下，需要所有机器共享同一个业务空间，那么10bit表示的1024台机器是不够的。\n\n\n# 3、什么是跨域？跨域问题怎么解决？\n\n协议、域名、端口号有一个不一样就是跨域。\n\n跨域：跨域访问，简单来说就是a网站的javascript代码试图访问b网站，包括提交内容和获取内容。由于安全原因，跨域访问是被各大浏览器所默认禁止的。\n\n目前我了解的解决跨域的几种方式：\n\n1）手写过滤器\n\n2）手写拦截器\n\n3）jsonp\n\n4）注解方式\n\n5）配置nginx反向代理\n\n共五种解决方式。\n\n\n\n\n\n\n# 4、cap理论，eureka与zookeeper区别？\n\n著名的cap理论指出，一个分布式系统不可能同时满足c(一致性consistency)、a(可用性availability)和p(分区容错性partition tolerance)。\n由于分区容错性在是分布式系统中必须要保证的，因此我们只能在a和c之间进行权衡。\n在此zookeeper保证的是cp, 而eureka则是ap。\n1）当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。\n但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。\n问题在于，选举leader的时间太长，30 ~ 120s, 且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。\n2）eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。\n而eureka的客户端在向某个eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。\n\n\n# 5、soa和微服务架构的区别？\n\nsoa (全称:service oriented architecture)\n\n一、架构划分不同\n\n1、soa强调按水平架构划分为：前、后端、数据库、测试等；\n\n2、微服务强调按垂直架构划分，按业务能力划分，每个服务完成一种特定的功能，服务即产品。\n\n二、技术平台选择不同\n\n1、soa应用倾向于使用统一的技术平台来解决所有问题；\n\n2、微服务可以针对不同业务特征选择不同技术平台，去中心统一化，发挥各种技术平台的特长。\n\n三、系统间边界处理机制不同\n\n1、soa架构强调的是异构系统之间的通信和解耦合；（一种粗粒度、松耦合的服务架构）；\n\n2、微服务架构强调的是系统按业务边界做细粒度的拆分和部署。\n\n四、主要目标不同\n\n1、soa架构，主要目标是确保应用能够交互操作；\n\n2、微服务架构，主要目标是实现新功能、并可以快速拓展开发团队。",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"关系型数据库",frontmatter:{title:"关系型数据库",date:"2022-04-28T18:12:26.000Z",permalink:"/pages/d130fe/",categories:["知识整理"],tags:["数据库"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/09.%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93.html",relativePath:"知识整理/09.关系型数据库.md",key:"v-00de7c67",path:"/pages/d130fe/",headers:[{level:2,title:"1、理论",slug:"_1、理论",normalizedTitle:"1、理论",charIndex:13},{level:3,title:"1.1 数据库设计三大范式",slug:"_1-1-数据库设计三大范式",normalizedTitle:"1.1 数据库设计三大范式",charIndex:22},{level:4,title:"1.1.1 第一范式",slug:"_1-1-1-第一范式",normalizedTitle:"1.1.1 第一范式",charIndex:39},{level:4,title:"1.1.2 第二范式",slug:"_1-1-2-第二范式",normalizedTitle:"1.1.2 第二范式",charIndex:186},{level:4,title:"1.1.3 第三范式",slug:"_1-1-3-第三范式",normalizedTitle:"1.1.3 第三范式",charIndex:311},{level:2,title:"2、执行计划explain",slug:"_2、执行计划explain",normalizedTitle:"2、执行计划explain",charIndex:466},{level:4,title:"2.1 type列",slug:"_2-1-type列",normalizedTitle:"2.1 type列",charIndex:485},{level:4,title:"2.2 possible_keys列",slug:"_2-2-possible-keys列",normalizedTitle:"2.2 possible_keys列",charIndex:1194},{level:4,title:"2.3 key列",slug:"_2-3-key列",normalizedTitle:"2.3 key列",charIndex:1328},{level:4,title:"2.4 key_len列",slug:"_2-4-key-len列",normalizedTitle:"2.4 key_len列",charIndex:1367},{level:4,title:"2.5 rows列",slug:"_2-5-rows列",normalizedTitle:"2.5 rows列",charIndex:1452},{level:2,title:"3、索引",slug:"_3、索引",normalizedTitle:"3、索引",charIndex:1553},{level:3,title:"3.1 使用索引注意事项",slug:"_3-1-使用索引注意事项",normalizedTitle:"3.1 使用索引注意事项",charIndex:1562},{level:3,title:"3.2 调优",slug:"_3-2-调优",normalizedTitle:"3.2 调优",charIndex:1894},{level:3,title:"3.3 InnoDB和MyISam",slug:"_3-3-innodb和myisam",normalizedTitle:"3.3 innodb和myisam",charIndex:2631},{level:4,title:"3.3.1 InnoDB和MyISam的数据结构？",slug:"_3-3-1-innodb和myisam的数据结构",normalizedTitle:"3.3.1 innodb和myisam的数据结构？",charIndex:2652},{level:4,title:"3.3.2 mysql推荐用自增主键原因？",slug:"_3-3-2-mysql推荐用自增主键原因",normalizedTitle:"3.3.2 mysql推荐用自增主键原因？",charIndex:2992},{level:4,title:"3.3.3 什么是覆盖索引？",slug:"_3-3-3-什么是覆盖索引",normalizedTitle:"3.3.3 什么是覆盖索引？",charIndex:3124},{level:4,title:"3.3.4 怎么添加索引？",slug:"_3-3-4-怎么添加索引",normalizedTitle:"3.3.4 怎么添加索引？",charIndex:3532},{level:2,title:"4、事务",slug:"_4、事务",normalizedTitle:"4、事务",charIndex:3866},{level:3,title:"4.1 什么是事务？",slug:"_4-1-什么是事务",normalizedTitle:"4.1 什么是事务？",charIndex:3875},{level:3,title:"4.2 事务有哪些特性？",slug:"_4-2-事务有哪些特性",normalizedTitle:"4.2 事务有哪些特性？",charIndex:3931},{level:3,title:"4.3 innodb怎么实现事务",slug:"_4-3-innodb怎么实现事务",normalizedTitle:"4.3 innodb怎么实现事务",charIndex:4171},{level:3,title:"4.4 并发事务带来的问题",slug:"_4-4-并发事务带来的问题",normalizedTitle:"4.4 并发事务带来的问题",charIndex:4245},{level:4,title:"4.4.1 脏读（Dirty read）",slug:"_4-4-1-脏读-dirty-read",normalizedTitle:"4.4.1 脏读（dirty read）",charIndex:4262},{level:4,title:"4.4.2 不可重复读（Nonrepeatable read）",slug:"_4-4-2-不可重复读-nonrepeatable-read",normalizedTitle:"4.4.2 不可重复读（nonrepeatable read）",charIndex:4351},{level:4,title:"4.4.3 幻影读（Phantom reads）",slug:"_4-4-3-幻影读-phantom-reads",normalizedTitle:"4.4.3 幻影读（phantom reads）",charIndex:4454},{level:4,title:"4.4.4 不可重复度和幻读区别",slug:"_4-4-4-不可重复度和幻读区别",normalizedTitle:"4.4.4 不可重复度和幻读区别",charIndex:4574},{level:3,title:"4.5 事务隔离级别",slug:"_4-5-事务隔离级别",normalizedTitle:"4.5 事务隔离级别",charIndex:4623},{level:4,title:"4.5.1 READ-UNCOMMITTED(读取未提交)",slug:"_4-5-1-read-uncommitted-读取未提交",normalizedTitle:"4.5.1 read-uncommitted(读取未提交)",charIndex:4637},{level:4,title:"4.5.2 READ-COMMITTED(读取已提交)",slug:"_4-5-2-read-committed-读取已提交",normalizedTitle:"4.5.2 read-committed(读取已提交)",charIndex:4710},{level:4,title:"4.5.3 REPEATABLE-READ(可重复读)",slug:"_4-5-3-repeatable-read-可重复读",normalizedTitle:"4.5.3 repeatable-read(可重复读)",charIndex:4782},{level:4,title:"4.5.4 SERIALIZABLE(串行化)",slug:"_4-5-4-serializable-串行化",normalizedTitle:"4.5.4 serializable(串行化)",charIndex:4872},{level:4,title:"4.5.5 数据库默认隔离级别",slug:"_4-5-5-数据库默认隔离级别",normalizedTitle:"4.5.5 数据库默认隔离级别",charIndex:4977},{level:3,title:"4.6 Spring 事务中的隔离级别",slug:"_4-6-spring-事务中的隔离级别",normalizedTitle:"4.6 spring 事务中的隔离级别",charIndex:5082},{level:4,title:"4.6.1 ISOLATION_DEFAULT",slug:"_4-6-1-isolation-default",normalizedTitle:"4.6.1 isolation_default",charIndex:5381},{level:4,title:"4.6.2 ISOLATIONREADUNCOMMITTED",slug:"_4-6-2-isolation-read-uncommitted",normalizedTitle:"4.6.2 isolationreaduncommitted",charIndex:null},{level:4,title:"4.6.3 ISOLATIONREADCOMMITTED",slug:"_4-6-3-isolation-read-committed",normalizedTitle:"4.6.3 isolationreadcommitted",charIndex:null},{level:4,title:"4.6.4 ISOLATIONREPEATABLEREAD",slug:"_4-6-4-isolation-repeatable-read",normalizedTitle:"4.6.4 isolationrepeatableread",charIndex:null},{level:4,title:"4.6.5 ISOLATION_SERIALIZABLE",slug:"_4-6-5-isolation-serializable",normalizedTitle:"4.6.5 isolation_serializable",charIndex:5738},{level:3,title:"4.7 Spring事务的7种传播行为",slug:"_4-7-spring事务的7种传播行为",normalizedTitle:"4.7 spring事务的7种传播行为",charIndex:5872},{level:4,title:"4.7.1 保证同一个事务中",slug:"_4-7-1-保证同一个事务中",normalizedTitle:"4.7.1 保证同一个事务中",charIndex:5895},{level:5,title:"1 PROPAGATION_REQUIRED",slug:"_1-propagation-required",normalizedTitle:"1 propagation_required",charIndex:5913},{level:5,title:"2 PROPAGATION_SUPPORTS",slug:"_2-propagation-supports",normalizedTitle:"2 propagation_supports",charIndex:5973},{level:5,title:"3 PROPAGATION_MANDATORY",slug:"_3-propagation-mandatory",normalizedTitle:"3 propagation_mandatory",charIndex:6031},{level:4,title:"4.7.1 保证没有在同一个事务中",slug:"_4-7-1-保证没有在同一个事务中",normalizedTitle:"4.7.1 保证没有在同一个事务中",charIndex:6088},{level:5,title:"4.PROPAGATIONREQUIRESNEW",slug:"_4-propagation-requires-new",normalizedTitle:"4.propagationrequiresnew",charIndex:null},{level:5,title:"5.PROPAGATIONNOTSUPPORTED",slug:"_5-propagation-not-supported",normalizedTitle:"5.propagationnotsupported",charIndex:null},{level:5,title:"6.PROPAGATION_NEVER",slug:"_6-propagation-never",normalizedTitle:"6.propagation_never",charIndex:6224},{level:5,title:"7.PROPAGATION_NESTED",slug:"_7-propagation-nested",normalizedTitle:"7.propagation_nested",charIndex:6270},{level:4,title:"4.7.2 传播级别不生效原因？",slug:"_4-7-2-传播级别不生效原因",normalizedTitle:"4.7.2 传播级别不生效原因？",charIndex:6314},{level:2,title:"5、锁",slug:"_5、锁",normalizedTitle:"5、锁",charIndex:6399},{level:3,title:"5.1 事务一定会锁表吗?",slug:"_5-1-事务一定会锁表吗",normalizedTitle:"5.1 事务一定会锁表吗?",charIndex:6407},{level:3,title:"5.2 锁分类",slug:"_5-2-锁分类",normalizedTitle:"5.2 锁分类",charIndex:6571},{level:3,title:"5.3 锁优化建议",slug:"_5-3-锁优化建议",normalizedTitle:"5.3 锁优化建议",charIndex:7032},{level:3,title:"5.4 MVCC",slug:"_5-4-mvcc",normalizedTitle:"5.4 mvcc",charIndex:7181},{level:3,title:"5.5 undo日志版本链与read view机制详解",slug:"_5-5-undo日志版本链与read-view机制详解",normalizedTitle:"5.5 undo日志版本链与read view机制详解",charIndex:7652}],headersStr:"1、理论 1.1 数据库设计三大范式 1.1.1 第一范式 1.1.2 第二范式 1.1.3 第三范式 2、执行计划explain 2.1 type列 2.2 possible_keys列 2.3 key列 2.4 key_len列 2.5 rows列 3、索引 3.1 使用索引注意事项 3.2 调优 3.3 InnoDB和MyISam 3.3.1 InnoDB和MyISam的数据结构？ 3.3.2 mysql推荐用自增主键原因？ 3.3.3 什么是覆盖索引？ 3.3.4 怎么添加索引？ 4、事务 4.1 什么是事务？ 4.2 事务有哪些特性？ 4.3 innodb怎么实现事务 4.4 并发事务带来的问题 4.4.1 脏读（Dirty read） 4.4.2 不可重复读（Nonrepeatable read） 4.4.3 幻影读（Phantom reads） 4.4.4 不可重复度和幻读区别 4.5 事务隔离级别 4.5.1 READ-UNCOMMITTED(读取未提交) 4.5.2 READ-COMMITTED(读取已提交) 4.5.3 REPEATABLE-READ(可重复读) 4.5.4 SERIALIZABLE(串行化) 4.5.5 数据库默认隔离级别 4.6 Spring 事务中的隔离级别 4.6.1 ISOLATION_DEFAULT 4.6.2 ISOLATIONREADUNCOMMITTED 4.6.3 ISOLATIONREADCOMMITTED 4.6.4 ISOLATIONREPEATABLEREAD 4.6.5 ISOLATION_SERIALIZABLE 4.7 Spring事务的7种传播行为 4.7.1 保证同一个事务中 1 PROPAGATION_REQUIRED 2 PROPAGATION_SUPPORTS 3 PROPAGATION_MANDATORY 4.7.1 保证没有在同一个事务中 4.PROPAGATIONREQUIRESNEW 5.PROPAGATIONNOTSUPPORTED 6.PROPAGATION_NEVER 7.PROPAGATION_NESTED 4.7.2 传播级别不生效原因？ 5、锁 5.1 事务一定会锁表吗? 5.2 锁分类 5.3 锁优化建议 5.4 MVCC 5.5 undo日志版本链与read view机制详解",content:"# 关系型数据库\n\n\n# 1、理论\n\n\n# 1.1 数据库设计三大范式\n\n# 1.1.1 第一范式\n\n1、每一列属性都是不可再分的属性值，确保每一列的原子性 （如：地址字段包含了省市区，不符合原子性，应才开）\n\n2、两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。（如：字段中有室号、物品1、数量1、物品2、数量2，应合并成室号、物品、数量）\n\n# 1.1.2 第二范式\n\n每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。\n\n如：一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把他拆开来。\n\n# 1.1.3 第三范式\n\n数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a--\x3eb--\x3ec 属性之间含有这样的关系，是不符合第三范式的。\n\n如：学号--\x3e 所在院校 --\x3e (院校地址，院校电话) 应拆开为（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）\n\n\n# 2、执行计划explain\n\n\n\n# 2.1 type列\n\n表示关联类型或访问类型，即MySQL决定如何查找表中的行\n\n依次从最优到最差分别为 : system > const > eq_ref > ref > range > index > ALL\n\n一般来说，得保证查询达到range级别，最好达到ref\n\nsystem：表中只有一条数据，这个类型是特殊的const类型\n\nconst：针对主键或唯一索引的等值查询扫描，最多只返回一行数据，const查询速度非常快，因为它仅仅读取一次即可。\n\neq_ref：此类型通常出现在多表的join查询，表示对于前表的每个结果，都只匹配到后表的一行结果，并且查询的比较操作通常是=，查询效率高。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。什么情况下结果集只有一个呢！那便是使用了主键或者唯一性索引进行查找的情况\n\nref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\nrange：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\nindex：表示全索引扫描（full index scan），和ALL类型类似，只不过ALL类型是全表扫描，而index类型则仅仅扫描所有的索引，而不扫描数据。通常比ALL快一些。\n\nall：表示全表扫描，这个类型的查询是性能最差的查询之一，通常来说，我们的查询不应该出现ALL类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难，一般可以用索引来避免\n\n# 2.2 possible_keys列\n\npossible_keys表示mysql在查询时，能够使用到的索引，注意，即使有些索引在possible_keys中出现，但是不表示此索引会真正被Mysql使用到，Mysql在查询时具体使用了哪些索引，由key字段决定。\n\n# 2.3 key列\n\n此字段是mysql在当前查询时所真正使用到的索引。\n\n# 2.4 key_len列\n\n表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，或只有最左部分字段被使用到。根据数据类型所占字节数计算出来。\n\n# 2.5 rows列\n\nrows也是一个重要的字段，mysql查询优化器根据统计信息，估算SQL要查找到结果集需要扫描读取的数据行数。这个值非常直观显示SQL的效率好坏，原则上rows越少越好。\n\n\n# 3、索引\n\n\n# 3.1 使用索引注意事项\n\n1.在经常需要搜索的列上创建索引，加快搜索速度。\n\n2.在where子句中的列上面创建索引，加快条件判断速度。\n\n3.在经常需要排序的列上创建索引，加快排序查询时间。\n\n4.在经常用在连接的列上（主要是一些外键）创建索引，加快连接速度。\n\n5.中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引。\n\n6.避免where子句中对字段施加函数，这会造成无法命中索引。\n\n7.使用innoDB时用与业务无关的自增主键，即使用逻辑主键而不要用业务主键。\n\n8.打算加索引的列设置为not null，否则将导致引擎放弃使用索引而进行全表扫描。\n\n9.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。\n\n\n# 3.2 调优\n\n1.分库分表，读写分离\n2.拆sql\n3.建索引\n4.sql优化\n1）like，尽量不在关键词前加%\n2）尽量多表连接查询，避免子查询\n3）合理的增加冗余的字段\n4）减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代\n\nmysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。\n\n一直以来大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的：\n\n如果查询的两个表大小相当，那么用in和exists差别不大。\n\n如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。\n5）or 的查询尽量用 union或者union all 代替（虽然这两个方式都用到了索引，但 UNION 是用一个明确的值到索引中查找，目标非常明确，OR 需要对比两个值，目标相对要模糊一些，所以 OR 在恍惚中落后了）\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下 降，一些常见的优化措施如下:\n\n1. 限定数据的范围: 务必禁止不带任何限制数据范围条件的查询语句。比如:我们当用户在查询订单历史的时 候，我们可以控制在一个月的范围内。;\n\n2. 读/写分离: 经典的数据库拆分方案，主库负责写，从库负责读;\n\n3. 垂直分区: 根据数据库里面数据表的相关性进行拆分。 把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。\n\n\n\n4. 水平分区: 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。\n\n\n\n\n# 3.3 InnoDB和MyISam\n\n# 3.3.1 InnoDB和MyISam的数据结构？\n\nInnoDB和MyIsam是B+树索引\n\n要加快索引 的查找速度则需要降低树的高度，要降低树的高度可通过增加树节点中数据的个数（度）实现。因为节点的数据是从磁盘加载的，磁盘加载数据的速度相对内存来说是很慢的，所以节点中数据不是越多越好，因为太多的话可能要多次 IO才能加载完，这样效率就会变低，所以B+树节点存储的数据大小尽量保证与一次IO读取数据大小一致，由于一次IO读取的数据较大（16K?）,所以树的高度不高，即查找的次数很少就能找到目标数据。\n1）MyISam非聚集索引 B+树结构 数据与索引分开存储，指向数据的地址存储在节点中\n2）InnoDB聚集索引 B+树结构 数据与索引存储在一起，数据存储在叶子节点\n\n# 3.3.2 mysql推荐用自增主键原因？\n\n1）占用空间小，一次IO加载的数据多。\n2）数字比较比字符串比较消耗小。\n3）新增数据时自增主键都是顺序插入到B+树结构，而uuid之类的字符串主键计算后可能是插入到B+树中间的节点，这样会导致更多的计算消耗。\n\n# 3.3.3 什么是覆盖索引？\n\n如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。InnoDB引擎中，如果不是主键索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是通过主键再查找一次。这样比较慢。覆盖索引就是要查询出的列和索引是对应的，不做回表操作。\n\n例子：\n\nALTER TABLE `test_table` ADD INDEX `idx_col1_col2_col3`(`col1`，`col2`，`col3`)\n\n分析查询：\n\nEXPLAIN SELECT SQL_NO_CACHE col2, col3 FROM test_table WHERE col1 = xxx ORDER BY col2;\n\n结果：建立联合索引后，type 为 ref，使用了 idx_col1_col2_col3 索引，Extra 为 Using index，说明使用了覆盖索引。\n\n# 3.3.4 怎么添加索引？\n\n1.添加PRIMARY KEY(主键索引)\n\nALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )\n\n2.添加UNIQUE(唯一索引)\n\nALTER TABLE `table_name` ADD UNIQUE ( `column` )\n\n3.添加INDEX(普通索引)\n\nALTER TABLE `table_name` ADD INDEX index_name ( `column` )\n\n4.添加多列索引\n\nALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )\n\n\n# 4、事务\n\n\n# 4.1 什么是事务？\n\n事务逻辑上的一组操作，组成这组操作的各个逻辑单元,要么一起成功,要么一起失败。\n\n\n# 4.2 事务有哪些特性？\n\n事务的特性（ACID）\n\n原子性（atomicity）: 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用;\n\n一致性（consistency）: 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的;\n\n隔离性（isolation）: 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的;\n\n持久性（durability）: 事务一旦结束，数据就持久到数据库。\n\n\n# 4.3 innodb怎么实现事务\n\nACD三个特性是通过Redo log（重做日志）和Undo log实现的。 而隔离性是通过锁来实现的。\n\n\n# 4.4 并发事务带来的问题\n\n# 4.4.1 脏读（Dirty read）\n\n脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。\n\n# 4.4.2 不可重复读（Nonrepeatable read）\n\n不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。\n\n# 4.4.3 幻影读（Phantom reads）\n\n幻影读和不可重复读相似。当一个事务（T1）读取几行记录后，另一个并发事务（T2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（T1）就会发现一些原来没有的额外记录。\n\n# 4.4.4 不可重复度和幻读区别\n\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n\n\n# 4.5 事务隔离级别\n\n# 4.5.1 READ-UNCOMMITTED(读取未提交)\n\n最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n\n# 4.5.2 READ-COMMITTED(读取已提交)\n\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n\n# 4.5.3 REPEATABLE-READ(可重复读)\n\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n# 4.5.4 SERIALIZABLE(串行化)\n\n最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n# 4.5.5 数据库默认隔离级别\n\nMySQL InnoDB 存储引擎的默认支持的隔离级别是：REPEATABLE-READ（可重读）\n\nOracle 默认：READ-COMMITTED（读已提交）\n\n\n\n\n# 4.6 Spring 事务中的隔离级别\n\nTransactionDefinition 接口中定义了五个表示隔离级别的常量:\n\nTransactionDefinition.ISOLATION_DEFAULT\n\nTransactionDefinition.ISOLATION_READ_UNCOMMITTED\n\nTransactionDefinition.ISOLATION_READ_COMMITTED\n\nTransactionDefinition.ISOLATION_REPEATABLE_READ\n\nTransactionDefinition.ISOLATION_SERIALIZABLE\n\n# 4.6.1 ISOLATION_DEFAULT\n\n使用后端数据库默认的隔离级别。\n\nMysql 默认采用的 REPEATABLE_READ隔离级别。Oracle 默认采用的 READ_COMMITTED隔离级别。\n\n# 4.6.2 ISOLATION_READ_UNCOMMITTED\n\n最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n\n# 4.6.3 ISOLATION_READ_COMMITTED\n\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n\n# 4.6.4 ISOLATION_REPEATABLE_READ\n\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n# 4.6.5 ISOLATION_SERIALIZABLE\n\n最高的隔离级别，完全服从ACID的隔离级别。\n\n所有事务依次逐个执行，事务之间不产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。\n\n但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n\n# 4.7 Spring事务的7种传播行为\n\n# 4.7.1 保证同一个事务中\n\n# 1 PROPAGATION_REQUIRED\n\n如果存在一个事务则支持当前事务，如果不存在就新建一个(默认)\n\n\n\n# 2 PROPAGATION_SUPPORTS\n\n如果存在一个事务则支持当前事务，如果不存在，就不使用事务\n\n\n\n# 3 PROPAGATION_MANDATORY\n\n如果存在一个事务则支持当前事务，如果不存在，抛出异常\n\n\n\n# 4.7.1 保证没有在同一个事务中\n\n# 4.PROPAGATION_REQUIRES_NEW\n\n如果有事务存在，挂起当前事务，创建一个新的事务\n\n\n\n# 5.PROPAGATION_NOT_SUPPORTED\n\n以非事务方式运行，如果有事务存在，挂起当前事务\n\n\n\n# 6.PROPAGATION_NEVER\n\n以非事务方式运行，如果有事务存在，抛出异常\n\n# 7.PROPAGATION_NESTED\n\n如果当前事务存在，则嵌套事务执行\n\n\n\n# 4.7.2 传播级别不生效原因？\n\n\n\n必须用注入的实例（代理类实例，有代理事务逻辑处理），否则只是普通类实例会导致事务代码不生效。\n\n可以类自己注入自己实例。\n\n\n# 5、锁\n\n\n# 5.1 事务一定会锁表吗?\n\n1、事务隔离级别是可重复读时，如果没有索引，更新数据时会锁住整张表。\n\n2、事务隔离级别为读未提交时，写数据只会锁住相应的行。\n\n3、事务隔离级别为串行化时，读写数据都会锁住整张表。\n\nInnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。\n\n\n# 5.2 锁分类\n\n1.从性能上分为乐观锁(用版本对比来实现)和悲观锁\n\n2.从对数据操作的粒度分，分为表锁和行锁\n\n3.从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)\n\n读锁(共享锁，S锁(Shared)):针对同一份数据，多个读操作可以同时进行而不会互相影响\n\n写锁(排它锁，X锁(eXclusive)):当前写操作没有完成前，它会阻断其他写锁和读锁\n\n读锁和写锁都是行级锁，InnoDB的行锁是通过给索引上的索引项加锁来实现的，如果没有索引，InnoDB将通过隐藏的聚簇索引来对记录加锁，InnoDB行锁分为3中情形：\n\n1. Record Lock：对索引项加锁。\n\n2. Gap Lock（间隙锁）：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁。\n\n3. Next-key Lock（临键锁）：前两种的结合，对记录及其前面的间隙加锁。\n\nInnoDB这种行锁的实现特点意味着，如果不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，实际效果跟锁表一样。\n\n\n# 5.3 锁优化建议\n\n1.尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\n\n2.合理设计索引，尽量缩小锁的范围\n\n3.尽可能减少检索条件范围，避免间隙锁\n\n4.尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行\n\n5.尽可能低级别事务隔离\n\n\n# 5.4 MVCC\n\n所谓的MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。\n\nREAD COMMITTD、REPEATABLE READ这两个隔离级别的一个很大不同就是生成ReadView的时机不同，\n\nREAD COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，\n\n而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复这个ReadView就好了。\n\nMVCC，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。Mysql在读已提交和可重复读隔离级别下都实现了MVCC机制。\n\n\n# 5.5 undo日志版本链与read view机制详解\n\nundo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，Mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链。\n\n\n\n在可重复读隔离级别，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化。\n\n如果是读已提交隔离级别在每次执行查询sql时都会重新生成。\n\nread-view视图由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id(max_id)组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\n\n总结: MVCC机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。\n\n注意:begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作InnoDB表的语句，事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。",normalizedContent:"# 关系型数据库\n\n\n# 1、理论\n\n\n# 1.1 数据库设计三大范式\n\n# 1.1.1 第一范式\n\n1、每一列属性都是不可再分的属性值，确保每一列的原子性 （如：地址字段包含了省市区，不符合原子性，应才开）\n\n2、两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。（如：字段中有室号、物品1、数量1、物品2、数量2，应合并成室号、物品、数量）\n\n# 1.1.2 第二范式\n\n每一行的数据只能与其中一列相关，即一行数据只做一件事。只要数据列中出现数据重复，就要把表拆分开来。\n\n如：一个人同时订几个房间，就会出来一个订单号多条数据，这样子联系人都是重复的，就会造成数据冗余。我们应该把他拆开来。\n\n# 1.1.3 第三范式\n\n数据不能存在传递关系，即每个属性都跟主键有直接关系而不是间接关系。像：a--\x3eb--\x3ec 属性之间含有这样的关系，是不符合第三范式的。\n\n如：学号--\x3e 所在院校 --\x3e (院校地址，院校电话) 应拆开为（学号，姓名，年龄，性别，所在院校）--（所在院校，院校地址，院校电话）\n\n\n# 2、执行计划explain\n\n\n\n# 2.1 type列\n\n表示关联类型或访问类型，即mysql决定如何查找表中的行\n\n依次从最优到最差分别为 : system > const > eq_ref > ref > range > index > all\n\n一般来说，得保证查询达到range级别，最好达到ref\n\nsystem：表中只有一条数据，这个类型是特殊的const类型\n\nconst：针对主键或唯一索引的等值查询扫描，最多只返回一行数据，const查询速度非常快，因为它仅仅读取一次即可。\n\neq_ref：此类型通常出现在多表的join查询，表示对于前表的每个结果，都只匹配到后表的一行结果，并且查询的比较操作通常是=，查询效率高。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。什么情况下结果集只有一个呢！那便是使用了主键或者唯一性索引进行查找的情况\n\nref：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\nrange：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\nindex：表示全索引扫描（full index scan），和all类型类似，只不过all类型是全表扫描，而index类型则仅仅扫描所有的索引，而不扫描数据。通常比all快一些。\n\nall：表示全表扫描，这个类型的查询是性能最差的查询之一，通常来说，我们的查询不应该出现all类型的查询，因为这样的查询在数据量大的情况下，对数据库的性能是巨大的灾难，一般可以用索引来避免\n\n# 2.2 possible_keys列\n\npossible_keys表示mysql在查询时，能够使用到的索引，注意，即使有些索引在possible_keys中出现，但是不表示此索引会真正被mysql使用到，mysql在查询时具体使用了哪些索引，由key字段决定。\n\n# 2.3 key列\n\n此字段是mysql在当前查询时所真正使用到的索引。\n\n# 2.4 key_len列\n\n表示查询优化器使用了索引的字节数，这个字段可以评估组合索引是否完全被使用，或只有最左部分字段被使用到。根据数据类型所占字节数计算出来。\n\n# 2.5 rows列\n\nrows也是一个重要的字段，mysql查询优化器根据统计信息，估算sql要查找到结果集需要扫描读取的数据行数。这个值非常直观显示sql的效率好坏，原则上rows越少越好。\n\n\n# 3、索引\n\n\n# 3.1 使用索引注意事项\n\n1.在经常需要搜索的列上创建索引，加快搜索速度。\n\n2.在where子句中的列上面创建索引，加快条件判断速度。\n\n3.在经常需要排序的列上创建索引，加快排序查询时间。\n\n4.在经常用在连接的列上（主要是一些外键）创建索引，加快连接速度。\n\n5.中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引。\n\n6.避免where子句中对字段施加函数，这会造成无法命中索引。\n\n7.使用innodb时用与业务无关的自增主键，即使用逻辑主键而不要用业务主键。\n\n8.打算加索引的列设置为not null，否则将导致引擎放弃使用索引而进行全表扫描。\n\n9.删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。\n\n\n# 3.2 调优\n\n1.分库分表，读写分离\n2.拆sql\n3.建索引\n4.sql优化\n1）like，尽量不在关键词前加%\n2）尽量多表连接查询，避免子查询\n3）合理的增加冗余的字段\n4）减少使用in或者not in ,使用exists，not exists或者关联查询语句替代\n\nmysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。\n\n一直以来大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的：\n\n如果查询的两个表大小相当，那么用in和exists差别不大。\n\n如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。\n5）or 的查询尽量用 union或者union all 代替（虽然这两个方式都用到了索引，但 union 是用一个明确的值到索引中查找，目标非常明确，or 需要对比两个值，目标相对要模糊一些，所以 or 在恍惚中落后了）\n\n当mysql单表记录数过大时，数据库的crud性能会明显下 降，一些常见的优化措施如下:\n\n1. 限定数据的范围: 务必禁止不带任何限制数据范围条件的查询语句。比如:我们当用户在查询订单历史的时 候，我们可以控制在一个月的范围内。;\n\n2. 读/写分离: 经典的数据库拆分方案，主库负责写，从库负责读;\n\n3. 垂直分区: 根据数据库里面数据表的相关性进行拆分。 把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。\n\n\n\n4. 水平分区: 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。\n\n\n\n\n# 3.3 innodb和myisam\n\n# 3.3.1 innodb和myisam的数据结构？\n\ninnodb和myisam是b+树索引\n\n要加快索引 的查找速度则需要降低树的高度，要降低树的高度可通过增加树节点中数据的个数（度）实现。因为节点的数据是从磁盘加载的，磁盘加载数据的速度相对内存来说是很慢的，所以节点中数据不是越多越好，因为太多的话可能要多次 io才能加载完，这样效率就会变低，所以b+树节点存储的数据大小尽量保证与一次io读取数据大小一致，由于一次io读取的数据较大（16k?）,所以树的高度不高，即查找的次数很少就能找到目标数据。\n1）myisam非聚集索引 b+树结构 数据与索引分开存储，指向数据的地址存储在节点中\n2）innodb聚集索引 b+树结构 数据与索引存储在一起，数据存储在叶子节点\n\n# 3.3.2 mysql推荐用自增主键原因？\n\n1）占用空间小，一次io加载的数据多。\n2）数字比较比字符串比较消耗小。\n3）新增数据时自增主键都是顺序插入到b+树结构，而uuid之类的字符串主键计算后可能是插入到b+树中间的节点，这样会导致更多的计算消耗。\n\n# 3.3.3 什么是覆盖索引？\n\n如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。innodb引擎中，如果不是主键索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是通过主键再查找一次。这样比较慢。覆盖索引就是要查询出的列和索引是对应的，不做回表操作。\n\n例子：\n\nalter table `test_table` add index `idx_col1_col2_col3`(`col1`，`col2`，`col3`)\n\n分析查询：\n\nexplain select sql_no_cache col2, col3 from test_table where col1 = xxx order by col2;\n\n结果：建立联合索引后，type 为 ref，使用了 idx_col1_col2_col3 索引，extra 为 using index，说明使用了覆盖索引。\n\n# 3.3.4 怎么添加索引？\n\n1.添加primary key(主键索引)\n\nalter table `table_name` add primary key ( `column` )\n\n2.添加unique(唯一索引)\n\nalter table `table_name` add unique ( `column` )\n\n3.添加index(普通索引)\n\nalter table `table_name` add index index_name ( `column` )\n\n4.添加多列索引\n\nalter table `table_name` add index index_name ( `column1`, `column2`, `column3` )\n\n\n# 4、事务\n\n\n# 4.1 什么是事务？\n\n事务逻辑上的一组操作，组成这组操作的各个逻辑单元,要么一起成功,要么一起失败。\n\n\n# 4.2 事务有哪些特性？\n\n事务的特性（acid）\n\n原子性（atomicity）: 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用;\n\n一致性（consistency）: 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的;\n\n隔离性（isolation）: 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的;\n\n持久性（durability）: 事务一旦结束，数据就持久到数据库。\n\n\n# 4.3 innodb怎么实现事务\n\nacd三个特性是通过redo log（重做日志）和undo log实现的。 而隔离性是通过锁来实现的。\n\n\n# 4.4 并发事务带来的问题\n\n# 4.4.1 脏读（dirty read）\n\n脏读发生在一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。\n\n# 4.4.2 不可重复读（nonrepeatable read）\n\n不可重复读发生在一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。\n\n# 4.4.3 幻影读（phantom reads）\n\n幻影读和不可重复读相似。当一个事务（t1）读取几行记录后，另一个并发事务（t2）插入了一些记录时，幻影读就发生了。在后来的查询中，第一个事务（t1）就会发现一些原来没有的额外记录。\n\n# 4.4.4 不可重复度和幻读区别\n\n不可重复读的重点是修改，幻读的重点在于新增或者删除。\n\n\n# 4.5 事务隔离级别\n\n# 4.5.1 read-uncommitted(读取未提交)\n\n最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读\n\n# 4.5.2 read-committed(读取已提交)\n\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生\n\n# 4.5.3 repeatable-read(可重复读)\n\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n# 4.5.4 serializable(串行化)\n\n最高的隔离级别，完全服从acid的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n# 4.5.5 数据库默认隔离级别\n\nmysql innodb 存储引擎的默认支持的隔离级别是：repeatable-read（可重读）\n\noracle 默认：read-committed（读已提交）\n\n\n\n\n# 4.6 spring 事务中的隔离级别\n\ntransactiondefinition 接口中定义了五个表示隔离级别的常量:\n\ntransactiondefinition.isolation_default\n\ntransactiondefinition.isolation_read_uncommitted\n\ntransactiondefinition.isolation_read_committed\n\ntransactiondefinition.isolation_repeatable_read\n\ntransactiondefinition.isolation_serializable\n\n# 4.6.1 isolation_default\n\n使用后端数据库默认的隔离级别。\n\nmysql 默认采用的 repeatable_read隔离级别。oracle 默认采用的 read_committed隔离级别。\n\n# 4.6.2 isolation_read_uncommitted\n\n最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n\n# 4.6.3 isolation_read_committed\n\n允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n\n# 4.6.4 isolation_repeatable_read\n\n对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n# 4.6.5 isolation_serializable\n\n最高的隔离级别，完全服从acid的隔离级别。\n\n所有事务依次逐个执行，事务之间不产生干扰，也就是说该级别可以防止脏读、不可重复读以及幻读。\n\n但是这将严重影响程序的性能。通常情况下也不会用到该级别。\n\n\n# 4.7 spring事务的7种传播行为\n\n# 4.7.1 保证同一个事务中\n\n# 1 propagation_required\n\n如果存在一个事务则支持当前事务，如果不存在就新建一个(默认)\n\n\n\n# 2 propagation_supports\n\n如果存在一个事务则支持当前事务，如果不存在，就不使用事务\n\n\n\n# 3 propagation_mandatory\n\n如果存在一个事务则支持当前事务，如果不存在，抛出异常\n\n\n\n# 4.7.1 保证没有在同一个事务中\n\n# 4.propagation_requires_new\n\n如果有事务存在，挂起当前事务，创建一个新的事务\n\n\n\n# 5.propagation_not_supported\n\n以非事务方式运行，如果有事务存在，挂起当前事务\n\n\n\n# 6.propagation_never\n\n以非事务方式运行，如果有事务存在，抛出异常\n\n# 7.propagation_nested\n\n如果当前事务存在，则嵌套事务执行\n\n\n\n# 4.7.2 传播级别不生效原因？\n\n\n\n必须用注入的实例（代理类实例，有代理事务逻辑处理），否则只是普通类实例会导致事务代码不生效。\n\n可以类自己注入自己实例。\n\n\n# 5、锁\n\n\n# 5.1 事务一定会锁表吗?\n\n1、事务隔离级别是可重复读时，如果没有索引，更新数据时会锁住整张表。\n\n2、事务隔离级别为读未提交时，写数据只会锁住相应的行。\n\n3、事务隔离级别为串行化时，读写数据都会锁住整张表。\n\ninnodb的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。\n\n\n# 5.2 锁分类\n\n1.从性能上分为乐观锁(用版本对比来实现)和悲观锁\n\n2.从对数据操作的粒度分，分为表锁和行锁\n\n3.从对数据库操作的类型分，分为读锁和写锁(都属于悲观锁)\n\n读锁(共享锁，s锁(shared)):针对同一份数据，多个读操作可以同时进行而不会互相影响\n\n写锁(排它锁，x锁(exclusive)):当前写操作没有完成前，它会阻断其他写锁和读锁\n\n读锁和写锁都是行级锁，innodb的行锁是通过给索引上的索引项加锁来实现的，如果没有索引，innodb将通过隐藏的聚簇索引来对记录加锁，innodb行锁分为3中情形：\n\n1. record lock：对索引项加锁。\n\n2. gap lock（间隙锁）：对索引项之间的“间隙”、第一条记录前的“间隙”或最后一条记录后的“间隙”加锁。\n\n3. next-key lock（临键锁）：前两种的结合，对记录及其前面的间隙加锁。\n\ninnodb这种行锁的实现特点意味着，如果不通过索引条件检索数据，那么innodb将对表中的所有记录加锁，实际效果跟锁表一样。\n\n\n# 5.3 锁优化建议\n\n1.尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁\n\n2.合理设计索引，尽量缩小锁的范围\n\n3.尽可能减少检索条件范围，避免间隙锁\n\n4.尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql尽量放在事务最后执行\n\n5.尽可能低级别事务隔离\n\n\n# 5.4 mvcc\n\n所谓的mvcc（multi-version concurrency control ，多版本并发控制）指的就是在使用read committd、repeatable read这两种隔离级别的事务在执行普通的seelct操作时访问记录的版本链的过程，这样子可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。\n\nread committd、repeatable read这两个隔离级别的一个很大不同就是生成readview的时机不同，\n\nread committd在每一次进行普通select操作前都会生成一个readview，\n\n而repeatable read只在第一次进行普通select操作前生成一个readview，之后的查询操作都重复这个readview就好了。\n\nmvcc，对一行数据的读和写两个操作默认是不会通过加锁互斥来保证隔离性，避免了频繁加锁互斥，而在串行化隔离级别为了保证较高的隔离性是通过将所有操作加锁互斥来实现的。mysql在读已提交和可重复读隔离级别下都实现了mvcc机制。\n\n\n# 5.5 undo日志版本链与read view机制详解\n\nundo日志版本链是指一行数据被多个事务依次修改过后，在每个事务修改完后，mysql会保留修改前的数据undo回滚日志，并且用两个隐藏字段trx_id和roll_pointer把这些undo日志串联起来形成一个历史记录版本链。\n\n\n\n在可重复读隔离级别，当事务开启，执行任何查询sql时会生成当前事务的一致性视图read-view，该视图在事务结束之前都不会变化。\n\n如果是读已提交隔离级别在每次执行查询sql时都会重新生成。\n\nread-view视图由执行查询时所有未提交事务id数组(数组里最小的id为min_id)和已创建的最大事务id(max_id)组成，事务里的任何sql查询结果需要从对应版本链里的最新数据开始逐条跟read-view做比对从而得到最终的快照结果。\n\n总结: mvcc机制的实现就是通过read-view机制与undo版本链比对机制，使得不同的事务会根据数据版本链对比规则读取同一条数据在版本链上的不同版本数据。\n\n注意:begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个修改操作innodb表的语句，事务才真正启动，才会向mysql申请事务id，mysql内部是严格按照事务的启动顺序来分配事务id的。",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"网络",frontmatter:{title:"网络",date:"2022-04-28T18:13:20.000Z",permalink:"/pages/451590/",categories:["知识整理"],tags:["网络"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/10.%E7%BD%91%E7%BB%9C.html",relativePath:"知识整理/10.网络.md",key:"v-32b6909a",path:"/pages/451590/",headers:[{level:2,title:"1、OSI七层模型",slug:"_1、osi七层模型",normalizedTitle:"1、osi七层模型",charIndex:9},{level:2,title:"2、TCP/IP四层模型",slug:"_2、tcp-ip四层模型",normalizedTitle:"2、tcp/ip四层模型",charIndex:25},{level:2,title:"3、HTTPS加解密过程",slug:"_3、https加解密过程",normalizedTitle:"3、https加解密过程",charIndex:71},{level:3,title:"3.1 什么是HTTP？",slug:"_3-1-什么是http",normalizedTitle:"3.1 什么是http？",charIndex:88},{level:3,title:"3.2 什么是HTTPS？",slug:"_3-2-什么是https",normalizedTitle:"3.2 什么是https？",charIndex:298},{level:3,title:"3.3 什么是对称加密？",slug:"_3-3-什么是对称加密",normalizedTitle:"3.3 什么是对称加密？",charIndex:444},{level:3,title:"3.4 什么是非对称加密？",slug:"_3-4-什么是非对称加密",normalizedTitle:"3.4 什么是非对称加密？",charIndex:507},{level:3,title:"3.5 HTTPS加解密过程？",slug:"_3-5-https加解密过程",normalizedTitle:"3.5 https加解密过程？",charIndex:577},{level:2,title:"4、TCP三次握手",slug:"_4、tcp三次握手",normalizedTitle:"4、tcp三次握手",charIndex:1328},{level:2,title:"5、四次挥手",slug:"_5、四次挥手",normalizedTitle:"5、四次挥手",charIndex:1551},{level:2,title:"6、正向代理、反向代理",slug:"_6、正向代理、反向代理",normalizedTitle:"6、正向代理、反向代理",charIndex:1699}],headersStr:"1、OSI七层模型 2、TCP/IP四层模型 3、HTTPS加解密过程 3.1 什么是HTTP？ 3.2 什么是HTTPS？ 3.3 什么是对称加密？ 3.4 什么是非对称加密？ 3.5 HTTPS加解密过程？ 4、TCP三次握手 5、四次挥手 6、正向代理、反向代理",content:"# 网络\n\n\n# 1、OSI七层模型\n\n\n\n\n# 2、TCP/IP四层模型\n\n1.应用层 2.传输层 3.网络层 4.网络接口层\n\n\n\n\n# 3、HTTPS加解密过程\n\n\n# 3.1 什么是HTTP？\n\nHTTP（Hypertext Transfer Protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说HTTP是当代互联网通信的基础。\n\n但是，HTTP 有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露。\n\n\n# 3.2 什么是HTTPS？\n\nHTTPS其实就是将HTTP的数据包再通过SSL/TLS加密后传输，那么SSL/TLS又是什么呢？\n\nSSL（Secure Sockets Layer）安全套接层和TLS（Transport Layer Security）传输层安全协议其实是一套东西。\n\n\n# 3.3 什么是对称加密？\n\n对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。\n\n\n# 3.4 什么是非对称加密？\n\n非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。\n\n\n# 3.5 HTTPS加解密过程？\n\n1.服务端有非对称加密的公钥A1，私钥A2。\n\n2.客户端有非对称加密的公钥B1，私钥B2。\n\n3.客户端向服务端发起请求，服务端将公钥A1返回给客户端。\n\n4.浏览器收到公钥A1，将自己保存的公钥B1发送给服务端。\n\n5.之后浏览器所有向客户端发送的数据，使用公钥B1加密，客户端可以使用私钥B2解密。\n\n6.客户端所有向服务端发送的数据，使用公钥A1加密，服务端可以使用私钥A2解密。\n\n此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？\n\n最主要的原因是非对称加解密耗时要远大于对称加解密，对性能有很大损耗，大家的使用体验很差。\n\n所以，我们才最终选用了上文介绍到非对称加密+对称加密的方案：\n\n1.服务端有非对称加密的公钥A1，私钥A2。\n\n2.客户端发起请求，服务端将公钥A1返回给客户端。\n\n3.客户端随机生成一个对称加密的密钥K，用公钥A1加密后发送给服务端。\n\n4.服务端收到密文后用自己的私钥A2解密，得到对称密钥K，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题。\n\n5.之后双方通信都使用密钥K进行对称加解密。\n\n看起来是一个非常完美的方案，兼顾了安全性和性能，但是，真的就安全了么？\n\n依然考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。\n\n当服务端向客户端返回公钥A1的时候，中间人将其替换成自己的公钥B1传送给浏览器。\n\n而浏览器此时一无所知，傻乎乎地使用公钥B1加密了密钥K发送出去，又被中间人截获。\n\n出现这一问题的核心原因是客户端无法确认收到的公钥是不是真的是服务端发来的。为了解决这个问题，互联网引入了一个公信机构，这就是CA。\n\n\n# 4、TCP三次握手\n\n\n\n第一次握手:Client 什么都不能确认;Server 确认了:对方发送正常，自己接收正常。\n\n第二次握手:Client 确认了:自己发送、接收正常，对方发送、接收正常;Server 确认了:自己接收正常，对方发送正常。\n\n第三次握手:Client 确认了:自己发送、接收正常，对方发送、接收正常;Server 确认了:自己发送、接收正常，对方发送、接收正常。所以三次握手就能确认双发收发功能都正常，缺一不可。\n\n\n# 5、四次挥手\n\n\n\n举个例子:A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的 话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道 了”，这样通话才算结束。\n\n\n# 6、正向代理、反向代理\n\n1.正向代理其实是客户端代理，帮助客户端访问其无法访问到的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。\n2.正向代理一般是客户端架设，比如在自己的机器上安装一个代理软件。反向代理一般是服务器架设的，比如在自己机器集群中部署一个反向代理服务器。\n3.正向代理中，服务器不知道真正的客户端到底是谁。反向代理中客户端不知道真正的服务端是谁。\n4.正向代理主要用来解决访问限制问题。反向代理则是提供负载均衡、安全防护等作用。\n\nnginx\n\n反向代理：proxy_pass\n\n负载均衡：upstream",normalizedContent:"# 网络\n\n\n# 1、osi七层模型\n\n\n\n\n# 2、tcp/ip四层模型\n\n1.应用层 2.传输层 3.网络层 4.网络接口层\n\n\n\n\n# 3、https加解密过程\n\n\n# 3.1 什么是http？\n\nhttp（hypertext transfer protocol）超文本传输协议，是一种用于分布式、协作式和超媒体信息系统的应用层协议，可以说http是当代互联网通信的基础。\n\n但是，http 有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，而这些明文数据会经过wifi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露。\n\n\n# 3.2 什么是https？\n\nhttps其实就是将http的数据包再通过ssl/tls加密后传输，那么ssl/tls又是什么呢？\n\nssl（secure sockets layer）安全套接层和tls（transport layer security）传输层安全协议其实是一套东西。\n\n\n# 3.3 什么是对称加密？\n\n对称加密是指有一个密钥，用它可以对一段明文加密，加密之后也只能用这个密钥来解密得到明文。\n\n\n# 3.4 什么是非对称加密？\n\n非对称加密有两个密钥，一个是公钥，另一个是私钥。一般来说，公钥用来加密，这时密文只能用私钥才能解开。\n\n\n# 3.5 https加解密过程？\n\n1.服务端有非对称加密的公钥a1，私钥a2。\n\n2.客户端有非对称加密的公钥b1，私钥b2。\n\n3.客户端向服务端发起请求，服务端将公钥a1返回给客户端。\n\n4.浏览器收到公钥a1，将自己保存的公钥b1发送给服务端。\n\n5.之后浏览器所有向客户端发送的数据，使用公钥b1加密，客户端可以使用私钥b2解密。\n\n6.客户端所有向服务端发送的数据，使用公钥a1加密，服务端可以使用私钥a2解密。\n\n此时，两条传输方向的数据都经过非对称加密，都能保证安全性，那么为什么不采用这种方案呢？\n\n最主要的原因是非对称加解密耗时要远大于对称加解密，对性能有很大损耗，大家的使用体验很差。\n\n所以，我们才最终选用了上文介绍到非对称加密+对称加密的方案：\n\n1.服务端有非对称加密的公钥a1，私钥a2。\n\n2.客户端发起请求，服务端将公钥a1返回给客户端。\n\n3.客户端随机生成一个对称加密的密钥k，用公钥a1加密后发送给服务端。\n\n4.服务端收到密文后用自己的私钥a2解密，得到对称密钥k，此时完成了安全的对称密钥交换，解决了对称加密时密钥传输被人窃取的问题。\n\n5.之后双方通信都使用密钥k进行对称加解密。\n\n看起来是一个非常完美的方案，兼顾了安全性和性能，但是，真的就安全了么？\n\n依然考虑中间人攻击的情况，非对称加密的算法都是公开的，所有人都可以自己生成一对公钥私钥。\n\n当服务端向客户端返回公钥a1的时候，中间人将其替换成自己的公钥b1传送给浏览器。\n\n而浏览器此时一无所知，傻乎乎地使用公钥b1加密了密钥k发送出去，又被中间人截获。\n\n出现这一问题的核心原因是客户端无法确认收到的公钥是不是真的是服务端发来的。为了解决这个问题，互联网引入了一个公信机构，这就是ca。\n\n\n# 4、tcp三次握手\n\n\n\n第一次握手:client 什么都不能确认;server 确认了:对方发送正常，自己接收正常。\n\n第二次握手:client 确认了:自己发送、接收正常，对方发送、接收正常;server 确认了:自己接收正常，对方发送正常。\n\n第三次握手:client 确认了:自己发送、接收正常，对方发送、接收正常;server 确认了:自己发送、接收正常，对方发送、接收正常。所以三次握手就能确认双发收发功能都正常，缺一不可。\n\n\n# 5、四次挥手\n\n\n\n举个例子:a 和 b 打电话，通话即将结束后，a 说“我没啥要说的了”，b回答“我知道了”，但是 b 可能还会有要说的 话，a 不能要求 b 跟着自己的节奏结束通话，于是 b 可能又巴拉巴拉说了一通，最后 b 说“我说完了”，a 回答“知道 了”，这样通话才算结束。\n\n\n# 6、正向代理、反向代理\n\n1.正向代理其实是客户端代理，帮助客户端访问其无法访问到的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。\n2.正向代理一般是客户端架设，比如在自己的机器上安装一个代理软件。反向代理一般是服务器架设的，比如在自己机器集群中部署一个反向代理服务器。\n3.正向代理中，服务器不知道真正的客户端到底是谁。反向代理中客户端不知道真正的服务端是谁。\n4.正向代理主要用来解决访问限制问题。反向代理则是提供负载均衡、安全防护等作用。\n\nnginx\n\n反向代理：proxy_pass\n\n负载均衡：upstream",charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"消息中间件",frontmatter:{title:"消息中间件",date:"2022-04-28T18:13:54.000Z",permalink:"/pages/e1ba65/",categories:["知识整理"],tags:["消息中间件"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/11.%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6.html",relativePath:"知识整理/11.消息中间件.md",key:"v-e097ec3a",path:"/pages/e1ba65/",headers:[{level:2,title:"1、理论",slug:"_1、理论",normalizedTitle:"1、理论",charIndex:12},{level:3,title:"1.1 传统模式缺点",slug:"_1-1-传统模式缺点",normalizedTitle:"1.1 传统模式缺点",charIndex:21},{level:3,title:"1.2 中间件模式优点",slug:"_1-2-中间件模式优点",normalizedTitle:"1.2 中间件模式优点",charIndex:69},{level:4,title:"1.2.1 解耦",slug:"_1-2-1-解耦",normalizedTitle:"1.2.1 解耦",charIndex:84},{level:4,title:"1.2.2 异步",slug:"_1-2-2-异步",normalizedTitle:"1.2.2 异步",charIndex:192},{level:4,title:"1.2.3 削峰",slug:"_1-2-3-削峰",normalizedTitle:"1.2.3 削峰",charIndex:204},{level:3,title:"1.3 消息队列缺点",slug:"_1-3-消息队列缺点",normalizedTitle:"1.3 消息队列缺点",charIndex:271},{level:4,title:"1.3.1 系统可用性减低",slug:"_1-3-1-系统可用性减低",normalizedTitle:"1.3.1 系统可用性减低",charIndex:285},{level:4,title:"1.3.2 系统复杂度增加",slug:"_1-3-2-系统复杂度增加",normalizedTitle:"1.3.2 系统复杂度增加",charIndex:321},{level:2,title:"2、RabbitMQ",slug:"_2、rabbitmq",normalizedTitle:"2、rabbitmq",charIndex:411},{level:3,title:"2.1 消息数量限制",slug:"_2-1-消息数量限制",normalizedTitle:"2.1 消息数量限制",charIndex:426},{level:3,title:"2.2 RabbitMQ消息丢失",slug:"_2-2-rabbitmq消息丢失",normalizedTitle:"2.2 rabbitmq消息丢失",charIndex:502},{level:4,title:"2.2.1 生产者丢失消息",slug:"_2-2-1-生产者丢失消息",normalizedTitle:"2.2.1 生产者丢失消息",charIndex:556},{level:4,title:"2.2.2 消息列表丢失消息",slug:"_2-2-2-消息列表丢失消息",normalizedTitle:"2.2.2 消息列表丢失消息",charIndex:633},{level:4,title:"2.2.3 消费者丢失消息",slug:"_2-2-3-消费者丢失消息",normalizedTitle:"2.2.3 消费者丢失消息",charIndex:771},{level:3,title:"2.3 RabbitMQ的消息投递流程是怎样的？",slug:"_2-3-rabbitmq的消息投递流程是怎样的",normalizedTitle:"2.3 rabbitmq的消息投递流程是怎样的？",charIndex:895},{level:3,title:"2.4 生产端怎么保证消息可靠性投递？",slug:"_2-4-生产端怎么保证消息可靠性投递",normalizedTitle:"2.4 生产端怎么保证消息可靠性投递？",charIndex:990},{level:3,title:"2.5 消费者收到消息后有几种确认方式？",slug:"_2-5-消费者收到消息后有几种确认方式",normalizedTitle:"2.5 消费者收到消息后有几种确认方式？",charIndex:1315},{level:3,title:"2.6 RabbitMQ消息重复消费",slug:"_2-6-rabbitmq消息重复消费",normalizedTitle:"2.6 rabbitmq消息重复消费",charIndex:1555},{level:4,title:"2.6.1 为什么会重复消费？",slug:"_2-6-1-为什么会重复消费",normalizedTitle:"2.6.1 为什么会重复消费？",charIndex:1577},{level:4,title:"2.6.2 怎么解决消息重复消费问题？",slug:"_2-6-2-怎么解决消息重复消费问题",normalizedTitle:"2.6.2 怎么解决消息重复消费问题？",charIndex:1724},{level:3,title:"2.7 RabbitMQ消息堆积",slug:"_2-7-rabbitmq消息堆积",normalizedTitle:"2.7 rabbitmq消息堆积",charIndex:1762},{level:4,title:"2.7.1 为什么会出现消息堆积？",slug:"_2-7-1-为什么会出现消息堆积",normalizedTitle:"2.7.1 为什么会出现消息堆积？",charIndex:1782},{level:4,title:"2.7.2 怎么解决消息堆积问题？",slug:"_2-7-2-怎么解决消息堆积问题",normalizedTitle:"2.7.2 怎么解决消息堆积问题？",charIndex:1842},{level:3,title:"2.8 什么是AMQP协议？",slug:"_2-8-什么是amqp协议",normalizedTitle:"2.8 什么是amqp协议？",charIndex:2003},{level:3,title:"2.9 消息怎样才会进入死信队列？",slug:"_2-9-消息怎样才会进入死信队列",normalizedTitle:"2.9 消息怎样才会进入死信队列？",charIndex:2233},{level:3,title:"2.10 RabbitMQ延迟队列是怎么实现的？",slug:"_2-10-rabbitmq延迟队列是怎么实现的",normalizedTitle:"2.10 rabbitmq延迟队列是怎么实现的？",charIndex:2363},{level:3,title:"2.11 RabbitMQ有哪些工作模式？",slug:"_2-11-rabbitmq有哪些工作模式",normalizedTitle:"2.11 rabbitmq有哪些工作模式？",charIndex:2562},{level:3,title:"2.12 RabbitMQ怎么保证高可用？",slug:"_2-12-rabbitmq怎么保证高可用",normalizedTitle:"2.12 rabbitmq怎么保证高可用？",charIndex:2670},{level:3,title:"2.13 RabbitMQ怎么保证消息消费的顺序性？",slug:"_2-13-rabbitmq怎么保证消息消费的顺序性",normalizedTitle:"2.13 rabbitmq怎么保证消息消费的顺序性？",charIndex:3054},{level:2,title:"3、Kafka",slug:"_3、kafka",normalizedTitle:"3、kafka",charIndex:3220},{level:3,title:"3.1 通信模型",slug:"_3-1-通信模型",normalizedTitle:"3.1 通信模型",charIndex:3232},{level:3,title:"3.2 kafka概念",slug:"_3-2-kafka概念",normalizedTitle:"3.2 kafka概念",charIndex:3678},{level:4,title:"3.2.1 Topic & Partition",slug:"_3-2-1-topic-partition",normalizedTitle:"3.2.1 topic &amp; partition",charIndex:null},{level:4,title:"3.2.2 Consumer & ConsumerGroup",slug:"_3-2-2-consumer-consumergroup",normalizedTitle:"3.2.2 consumer &amp; consumergroup",charIndex:null},{level:4,title:"3.2.3 Producer",slug:"_3-2-3-producer",normalizedTitle:"3.2.3 producer",charIndex:4510},{level:3,title:"3.3 选举机制",slug:"_3-3-选举机制",normalizedTitle:"3.3 选举机制",charIndex:5232},{level:3,title:"3.4 HW与LEO",slug:"_3-4-hw与leo",normalizedTitle:"3.4 hw与leo",charIndex:5837},{level:3,title:"3.5 kafka核心总控制器Controller",slug:"_3-5-kafka核心总控制器controller",normalizedTitle:"3.5 kafka核心总控制器controller",charIndex:5978},{level:3,title:"3.6 kafka高性能原因",slug:"_3-6-kafka高性能原因",normalizedTitle:"3.6 kafka高性能原因",charIndex:6419},{level:3,title:"3.7 线上规划",slug:"_3-7-线上规划",normalizedTitle:"3.7 线上规划",charIndex:7016}],headersStr:"1、理论 1.1 传统模式缺点 1.2 中间件模式优点 1.2.1 解耦 1.2.2 异步 1.2.3 削峰 1.3 消息队列缺点 1.3.1 系统可用性减低 1.3.2 系统复杂度增加 2、RabbitMQ 2.1 消息数量限制 2.2 RabbitMQ消息丢失 2.2.1 生产者丢失消息 2.2.2 消息列表丢失消息 2.2.3 消费者丢失消息 2.3 RabbitMQ的消息投递流程是怎样的？ 2.4 生产端怎么保证消息可靠性投递？ 2.5 消费者收到消息后有几种确认方式？ 2.6 RabbitMQ消息重复消费 2.6.1 为什么会重复消费？ 2.6.2 怎么解决消息重复消费问题？ 2.7 RabbitMQ消息堆积 2.7.1 为什么会出现消息堆积？ 2.7.2 怎么解决消息堆积问题？ 2.8 什么是AMQP协议？ 2.9 消息怎样才会进入死信队列？ 2.10 RabbitMQ延迟队列是怎么实现的？ 2.11 RabbitMQ有哪些工作模式？ 2.12 RabbitMQ怎么保证高可用？ 2.13 RabbitMQ怎么保证消息消费的顺序性？ 3、Kafka 3.1 通信模型 3.2 kafka概念 3.2.1 Topic & Partition 3.2.2 Consumer & ConsumerGroup 3.2.3 Producer 3.3 选举机制 3.4 HW与LEO 3.5 kafka核心总控制器Controller 3.6 kafka高性能原因 3.7 线上规划",content:'# 消息中间件\n\n\n# 1、理论\n\n\n# 1.1 传统模式缺点\n\n并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。\n\n\n# 1.2 中间件模式优点\n\n# 1.2.1 解耦\n\n系统A在代码中直接调用系统B和系统C的代码，如果将来D系统接入，系统A还需要修改代码，过于麻烦！将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改**。**\n\n# 1.2.2 异步\n\n# 1.2.3 削峰\n\n系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。\n\n\n# 1.3 消息队列缺点\n\n# 1.3.1 系统可用性减低\n\n消息队列挂了，相关系统功能受影响。\n\n# 1.3.2 系统复杂度增加\n\n需要考虑很多方面问题，如重复消费问题、可靠传输（生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据）问题、mq高可用（集群（镜像模式））等等。\n\n\n# 2、RabbitMQ\n\n\n# 2.1 消息数量限制\n\nRabbitMQ上一个queue中存放的message是否有数量限制？\n\n可以认为是无限制的，因为限制取决于机器内存。\n\n\n# 2.2 RabbitMQ消息丢失\n\n丢失数据分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息。\n\n# 2.2.1 生产者丢失消息\n\n生产者丢失消息可以通过ACK方式处理，一旦消息投递到所有匹配的队列之后，rabbitMQ就会发送一个ACK给生产者。\n\n# 2.2.2 消息列表丢失消息\n\n消息列表丢失可以开启持久化磁盘的配置，在消息持久化到磁盘后再给生产者发送ACK信号。\n\n操作步骤：\n\n * 将queue的持久化标识durable设置为true，则代表是一个持久的队列\n * 发送消息的时候将deliveryMode=2\n\n# 2.2.3 消费者丢失消息\n\n消费者丢失消息一般是因为采用了自动确认消息模式，消费者在收到消息之后，处理消息之前会自动回复RabbitMQ已收到消息，如果这时处理消息失败，就会丢失消息。解决方案：\n\n * 处理消息成功后，手动回复确认消息\n\n\n# 2.3 RabbitMQ的消息投递流程是怎样的？\n\nProducer --\x3e RabbitMQ Broker --\x3e Exchange --\x3e Queue --\x3e Consumer\n\n\n# 2.4 生产端怎么保证消息可靠性投递？\n\n消息从producer到exchange会返回一个confirmCallback。\n\n消息从exchange到queue投递失败会返回一个returnCallback。\n\n利用这两个callback可以控制消息的可靠性投递。\n\n * ConfirmCallback\n\n设置publisher-confirm="true"开启确认模式。\n\n在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败。\n\n\n\n\n\n * ReturnCallback\n\n设置publisher-returns="true"开启退回模式。\n\n消息从exchange路由到queue失败后触发回调。\n\n\n\n\n\n\n# 2.5 消费者收到消息后有几种确认方式？\n\n有三种确认方式：\n\n * 自动确认：acknowledge="none" （自动ack）\n * 手动确认：acknowledge="manual" （手动ack）\n * 根据异常情况确认：acknowledge="auto",(这种方式使用麻烦，一般不用)\n\n自动确认：消费者丢失消息一般是因为采用了自动确认消息模式，消费者在收到消息之后，处理消息之前会自动回复RabbitMQ已收到消息，如果这时处理消息失败，就会丢失消息。\n\n\n# 2.6 RabbitMQ消息重复消费\n\n# 2.6.1 为什么会重复消费？\n\n正常情况，消费者在消费消息的时候，消费完毕会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。\n\n但是因为网络传输等故障，确认消息没有传送到消息队列，导致消息队列不知道已经消费过该消息，再次将消息分发给其他消费者。\n\n# 2.6.2 怎么解决消息重复消费问题？\n\n解决思路：保证消息幂等性\n\n\n# 2.7 RabbitMQ消息堆积\n\n# 2.7.1 为什么会出现消息堆积？\n\n1.业务高峰期，请求量暴涨。\n\n2.代码异常没有ack，或者全进入到私信。\n\n# 2.7.2 怎么解决消息堆积问题？\n\n1.通过适度调高并发参数，提高服务消费能力。一般调整预取值prefetch和并发线程数concurrentcy。\n\n2.增加消费节点，在数据库等扛得住的情况下，增加消费服务是一个优先选项。\n\n3.异常导致的消息堆积，先紧急回滚代码，或紧急修复异常，然后按前两步提高消费能力。\n\n\n# 2.8 什么是AMQP协议？\n\nAdvanced Message Queuing Protocol，高级消息队列协议。是一个进程间传递异步消息的网络协议。\n\n\n\n工作过程：\n\n发布者（Publisher）发布消息（Message），经由交换机（Exchange）。\n\n交换机根据路由规则将收到的消息分别发给与该交换机绑定的队列（Queue）。\n\n最后 AMQP 代理会将消息投递给订阅了此队列的消费者（Consumer），或者消费者按照需求自行获取。\n\n\n# 2.9 消息怎样才会进入死信队列？\n\n1）队列消息长度到达限制。\n\n2）消费者拒接消费消息，basicNack/basicReject，并且不把消息放入原目标队列，requeue=false。\n\n3）原队列存在消息过期设置，消息到达超时时间未被消费。\n\n\n# 2.10 RabbitMQ延迟队列是怎么实现的？\n\n使用TTL+死信队列组合实现延迟队列效果。\n\nTTL（time to live）消息存活时间：\n\n如果消息在存活时间内未被消费，则会被清除。\n\nRabbitMQ支持两种ttl设置：单独消息配置ttl；整个队列配置ttl（居多）\n\n需求：\n\n1.下单后，30分钟未支付，取消订单，回滚库存。\n\n2.新用户注册成功7天后，发送短信问候。\n\n\n\n\n# 2.11 RabbitMQ有哪些工作模式？\n\n简单模式\n\nwork queue\n\npublish/subscribe发布订阅模式\n\nrouting路由模式\n\ntopics 主题模式\n\nrpc远程调用模式\n\n\n\n\n# 2.12 RabbitMQ怎么保证高可用？\n\n镜像集群模式\n\n\n\n1.生产者向任一服务节点注册队列，该队列相关信息会同步到其他节点上。。\n\n2.任一消费者向任一节点请求消费，可以直接获取到消费的消息，因为每个节点上都有相同的实际数据。\n\n3.任一节点宕机，不影响消息在其他节点上进行消费。\n\n缺点\n\n1.性能开销非常大，因为要同步消息到对应的节点，这个会造成网络之间的数据量的频繁交互，对于网络带宽的消耗和压力都是比较重的。\n\n2.没有扩展可言，rabbitMQ是集群，不是分布式的，所以当某个Queue负载过重，我们并不能通过新增节点来缓解压力，因为所以节点上的数据都是相同的，这样就没办法进行扩展了。\n\n对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过HA的同步策略来实现\n\nHA的同步策略如下：\n\n\n\n\n# 2.13 RabbitMQ怎么保证消息消费的顺序性？\n\n1.RabbitMQ的queue本身就是队列，是可以保证消息的顺序投递的。\n\n2.但是顺序消费就是另一回事了，要保证顺序消费可以通过以下做法：\n\n1）投递消息的时候加上时间戳，消费端通过时间戳判断先后顺序。\n\n2）同一字段的更新，设定只有一个消费者，但是这样效率低。\n\n\n# 3、Kafka\n\n\n# 3.1 通信模型\n\n\n\n名称              解释\nBroker          消息中间件处理节点，一个Kafka节点就是一个broker，一个或者多个Broker可以组成一个Kafka集群\nTopic           Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic\nPartition       物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的\nConsumer        消息消费者，从Broker读取消息的客户端\nConsumerGroup   每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的Consumer\n                Group消费，但是一个Consumer Group中只能有一个Consumer能够消费该消息\nProducer        消息生产者，向Broker发送消息的客户端\n\n\n# 3.2 kafka概念\n\n# 3.2.1 Topic & Partition\n\n * 每个partition，都对应一个commit log文件。\n * 每个partition都有一个唯一编号：offset。\n * 每个consumer都是基于自己在commit log中的offset进行工作的。Offset由consumer自己维护。\n\n\n\n为什么topic数据要分区存储？\n\n1、分区之后可以将不同的分区放在不同的机器上，相当于对数据做了分布式存储\n\n2、提高并行度\n\n数据存储：server.properties log.dirs=/usr/local/data/kafka-logs\n\nKafka Broker 有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是 1GB。\n\n一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做 log rolling，正在被写入的那个日志段文件，叫做 active log segment。\n\n# 3.2.2 Consumer & ConsumerGroup\n\n * 一个partition同一个时刻在一个consumer group中只能有一个consumer在消费，从而保证消费顺序。\n * consumer group中的consumer的数量不能比一个Topic中的partition的数量多，否则多出来的consumer消费不到消息。\n\n\n\nKafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。\n\n如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer instance数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。\n\n# 3.2.3 Producer\n\n写入方式\n\nproducer 采用 push 模式将消息发布到 broker，每条消息都是被append到patition中，属于顺序写磁盘\n\n消息路由\n\nproducer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：\n\n1.指定了patition，则直接使用；\n\n2.未指定patition 但指定key，通过对key的value进行hash选出一个patition。\n\n3.patition和key都未指定，使用轮询选出一个patition。\n\n消息确认机制\n\nacks=0：表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。\n\nacks=1：至少要等待leader已经成功将数据写入本地log，但不需要等待所有follower是否成功写入。\n\nacks=-1或all：leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志\n\nacks=-1时的数据流程：\n\n\n\n1.producer先从zookeeper 的 "/brokers/.../state" 节点找到该partition的leader。\n\n2.producer将消息发送给该leader。\n\n3.leader将消息写入本地log。\n\n4.followers从leader pull消息，写入本地log后向leader发送ACK。\n\n5.leader收到所有ISR中的replica的ACK后，增加HW（high watermark，最后 commit 的 offset）并向producer发送ACK。\n\n\n# 3.3 选举机制\n\nController选举机制\n\nkafka集群启动的时候，会自动选举一台broker作为controller来管理整个集群，选举的过程是集群中每个broker都会尝试在zookeeper上创建一个 /controller 临时节点，zookeeper会保证有且仅有一个broker能创建成功，这个broker就会成为集群的总控器controller。\n\nPartition副本选举Leader机制\n\ncontroller感知到分区leader所在的broker挂了，会从ISR列表里挑第一个broker作为leader\n\n(参数unclean.leader.election.enable=false的前提下。\n\n参数unclean.leader.election.enable为true，则ISR列表里所有副本都挂了的时候可以在ISR列表外的副本中选leader，\n\n这种设置，可以提高可用性，但是选出的新leader有可能数据少很多。)\n\n副本进入ISR列表有两个条件:\n\n1.必须能与zookeeper保持会话以及跟leader副本网络连通\n\n2.副本能复制leader上的所有写操作，并且不能落后太多。(与leader副本同步滞后的副本，是由 replica.lag.time.max.ms配置决定的，超过这个时间都没有跟leader同步过的一次的副本会被移出ISR列表)\n\n\n# 3.4 HW与LEO\n\nLEO （Log End Offset）\n\nHW有两个主要的作用：\n\n1、用于实现副本备份机制（replication）；\n\n2、定义消息可见性，即HW之下的所有消息对consumer是可见的。如果没有HW机制，就需要其他手段来实现这两个功能。\n\n\n\n\n# 3.5 kafka核心总控制器Controller\n\n在Kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器(Kafka Controller)，它负责管理整个集群中所有分区和副本的状态。\n\n主题管理\n\n完成对Kafka主题的创建、删除以及分区增加的操作\n\n分区重分配\n\n对已有主题分区进行细粒度的分配功能\n\n集群成员管理\n\n自动检测新增Broker、Broker主动关闭、Broker宕机.\n\n/brokers/ids/下面会存放Broker实例的id临时节点，当我们看到/brokers/ids下面有几个节点，就表示有多少个存活的Broker实例。\n\n当Broker宕机时，临时节点就会被删除，此时控制器对应的监听器就会感知到Broker下线，进而完成对应的下线工作。\n\n数据服务\n\n向其它Broker提供数据服务，控制器上保存了最全的集群元数据信息,\n\n其它Broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据\n\n\n# 3.6 kafka高性能原因\n\n * 磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾。\n * **PageCache：**Kafka重度依赖底层操作系统提供的磁盘高速缓存PageCache（内核缓冲区）功能。\n   当上层有写操作时，操作系统只是将数据写入PageCache，同时标记Page属性为Dirty。内存池再异步地写到磁盘上。\n   当读操作发生时，先从PageCache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。\n   实际上PageCache是把尽可能多的空闲内存都当做了磁盘缓存来使用。\n   同时如果有其他进程申请内存，回收PageCache的代价又很小，所以现代的OS都支持PageCache。\n * **零拷贝：**linux操作系统 “零拷贝” 机制使用了sendfile方法， 允许操作系统将数据从Page Cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 NIC 缓冲区， 这样避免重新复制数据 。通过这种 “零拷贝” 的机制，Page Cache 结合 sendfile 方法，Kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。\n\n\n\n * 批量读写、批量压缩\n\n\n# 3.7 线上规划\n\n',normalizedContent:'# 消息中间件\n\n\n# 1、理论\n\n\n# 1.1 传统模式缺点\n\n并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常。\n\n\n# 1.2 中间件模式优点\n\n# 1.2.1 解耦\n\n系统a在代码中直接调用系统b和系统c的代码，如果将来d系统接入，系统a还需要修改代码，过于麻烦！将消息写入消息队列，需要消息的系统自己从消息队列中订阅，从而系统a不需要做任何修改**。**\n\n# 1.2.2 异步\n\n# 1.2.3 削峰\n\n系统a慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。\n\n\n# 1.3 消息队列缺点\n\n# 1.3.1 系统可用性减低\n\n消息队列挂了，相关系统功能受影响。\n\n# 1.3.2 系统复杂度增加\n\n需要考虑很多方面问题，如重复消费问题、可靠传输（生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据）问题、mq高可用（集群（镜像模式））等等。\n\n\n# 2、rabbitmq\n\n\n# 2.1 消息数量限制\n\nrabbitmq上一个queue中存放的message是否有数量限制？\n\n可以认为是无限制的，因为限制取决于机器内存。\n\n\n# 2.2 rabbitmq消息丢失\n\n丢失数据分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息。\n\n# 2.2.1 生产者丢失消息\n\n生产者丢失消息可以通过ack方式处理，一旦消息投递到所有匹配的队列之后，rabbitmq就会发送一个ack给生产者。\n\n# 2.2.2 消息列表丢失消息\n\n消息列表丢失可以开启持久化磁盘的配置，在消息持久化到磁盘后再给生产者发送ack信号。\n\n操作步骤：\n\n * 将queue的持久化标识durable设置为true，则代表是一个持久的队列\n * 发送消息的时候将deliverymode=2\n\n# 2.2.3 消费者丢失消息\n\n消费者丢失消息一般是因为采用了自动确认消息模式，消费者在收到消息之后，处理消息之前会自动回复rabbitmq已收到消息，如果这时处理消息失败，就会丢失消息。解决方案：\n\n * 处理消息成功后，手动回复确认消息\n\n\n# 2.3 rabbitmq的消息投递流程是怎样的？\n\nproducer --\x3e rabbitmq broker --\x3e exchange --\x3e queue --\x3e consumer\n\n\n# 2.4 生产端怎么保证消息可靠性投递？\n\n消息从producer到exchange会返回一个confirmcallback。\n\n消息从exchange到queue投递失败会返回一个returncallback。\n\n利用这两个callback可以控制消息的可靠性投递。\n\n * confirmcallback\n\n设置publisher-confirm="true"开启确认模式。\n\n在方法中判断ack，如果为true，则发送成功，如果为false，则发送失败。\n\n\n\n\n\n * returncallback\n\n设置publisher-returns="true"开启退回模式。\n\n消息从exchange路由到queue失败后触发回调。\n\n\n\n\n\n\n# 2.5 消费者收到消息后有几种确认方式？\n\n有三种确认方式：\n\n * 自动确认：acknowledge="none" （自动ack）\n * 手动确认：acknowledge="manual" （手动ack）\n * 根据异常情况确认：acknowledge="auto",(这种方式使用麻烦，一般不用)\n\n自动确认：消费者丢失消息一般是因为采用了自动确认消息模式，消费者在收到消息之后，处理消息之前会自动回复rabbitmq已收到消息，如果这时处理消息失败，就会丢失消息。\n\n\n# 2.6 rabbitmq消息重复消费\n\n# 2.6.1 为什么会重复消费？\n\n正常情况，消费者在消费消息的时候，消费完毕会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除。\n\n但是因为网络传输等故障，确认消息没有传送到消息队列，导致消息队列不知道已经消费过该消息，再次将消息分发给其他消费者。\n\n# 2.6.2 怎么解决消息重复消费问题？\n\n解决思路：保证消息幂等性\n\n\n# 2.7 rabbitmq消息堆积\n\n# 2.7.1 为什么会出现消息堆积？\n\n1.业务高峰期，请求量暴涨。\n\n2.代码异常没有ack，或者全进入到私信。\n\n# 2.7.2 怎么解决消息堆积问题？\n\n1.通过适度调高并发参数，提高服务消费能力。一般调整预取值prefetch和并发线程数concurrentcy。\n\n2.增加消费节点，在数据库等扛得住的情况下，增加消费服务是一个优先选项。\n\n3.异常导致的消息堆积，先紧急回滚代码，或紧急修复异常，然后按前两步提高消费能力。\n\n\n# 2.8 什么是amqp协议？\n\nadvanced message queuing protocol，高级消息队列协议。是一个进程间传递异步消息的网络协议。\n\n\n\n工作过程：\n\n发布者（publisher）发布消息（message），经由交换机（exchange）。\n\n交换机根据路由规则将收到的消息分别发给与该交换机绑定的队列（queue）。\n\n最后 amqp 代理会将消息投递给订阅了此队列的消费者（consumer），或者消费者按照需求自行获取。\n\n\n# 2.9 消息怎样才会进入死信队列？\n\n1）队列消息长度到达限制。\n\n2）消费者拒接消费消息，basicnack/basicreject，并且不把消息放入原目标队列，requeue=false。\n\n3）原队列存在消息过期设置，消息到达超时时间未被消费。\n\n\n# 2.10 rabbitmq延迟队列是怎么实现的？\n\n使用ttl+死信队列组合实现延迟队列效果。\n\nttl（time to live）消息存活时间：\n\n如果消息在存活时间内未被消费，则会被清除。\n\nrabbitmq支持两种ttl设置：单独消息配置ttl；整个队列配置ttl（居多）\n\n需求：\n\n1.下单后，30分钟未支付，取消订单，回滚库存。\n\n2.新用户注册成功7天后，发送短信问候。\n\n\n\n\n# 2.11 rabbitmq有哪些工作模式？\n\n简单模式\n\nwork queue\n\npublish/subscribe发布订阅模式\n\nrouting路由模式\n\ntopics 主题模式\n\nrpc远程调用模式\n\n\n\n\n# 2.12 rabbitmq怎么保证高可用？\n\n镜像集群模式\n\n\n\n1.生产者向任一服务节点注册队列，该队列相关信息会同步到其他节点上。。\n\n2.任一消费者向任一节点请求消费，可以直接获取到消费的消息，因为每个节点上都有相同的实际数据。\n\n3.任一节点宕机，不影响消息在其他节点上进行消费。\n\n缺点\n\n1.性能开销非常大，因为要同步消息到对应的节点，这个会造成网络之间的数据量的频繁交互，对于网络带宽的消耗和压力都是比较重的。\n\n2.没有扩展可言，rabbitmq是集群，不是分布式的，所以当某个queue负载过重，我们并不能通过新增节点来缓解压力，因为所以节点上的数据都是相同的，这样就没办法进行扩展了。\n\n对于镜像集群而言，当某个queue负载过重，可能会导致集群雪崩，那么如何来减少集群雪崩呢？我们可以通过ha的同步策略来实现\n\nha的同步策略如下：\n\n\n\n\n# 2.13 rabbitmq怎么保证消息消费的顺序性？\n\n1.rabbitmq的queue本身就是队列，是可以保证消息的顺序投递的。\n\n2.但是顺序消费就是另一回事了，要保证顺序消费可以通过以下做法：\n\n1）投递消息的时候加上时间戳，消费端通过时间戳判断先后顺序。\n\n2）同一字段的更新，设定只有一个消费者，但是这样效率低。\n\n\n# 3、kafka\n\n\n# 3.1 通信模型\n\n\n\n名称              解释\nbroker          消息中间件处理节点，一个kafka节点就是一个broker，一个或者多个broker可以组成一个kafka集群\ntopic           kafka根据topic对消息进行归类，发布到kafka集群的每条消息都需要指定一个topic\npartition       物理上的概念，一个topic可以分为多个partition，每个partition内部消息是有序的\nconsumer        消息消费者，从broker读取消息的客户端\nconsumergroup   每个consumer属于一个特定的consumer group，一条消息可以被多个不同的consumer\n                group消费，但是一个consumer group中只能有一个consumer能够消费该消息\nproducer        消息生产者，向broker发送消息的客户端\n\n\n# 3.2 kafka概念\n\n# 3.2.1 topic & partition\n\n * 每个partition，都对应一个commit log文件。\n * 每个partition都有一个唯一编号：offset。\n * 每个consumer都是基于自己在commit log中的offset进行工作的。offset由consumer自己维护。\n\n\n\n为什么topic数据要分区存储？\n\n1、分区之后可以将不同的分区放在不同的机器上，相当于对数据做了分布式存储\n\n2、提高并行度\n\n数据存储：server.properties log.dirs=/usr/local/data/kafka-logs\n\nkafka broker 有一个参数，log.segment.bytes，限定了每个日志段文件的大小，最大就是 1gb。\n\n一个日志段文件满了，就自动开一个新的日志段文件来写入，避免单个文件过大，影响文件的读写性能，这个过程叫做 log rolling，正在被写入的那个日志段文件，叫做 active log segment。\n\n# 3.2.2 consumer & consumergroup\n\n * 一个partition同一个时刻在一个consumer group中只能有一个consumer在消费，从而保证消费顺序。\n * consumer group中的consumer的数量不能比一个topic中的partition的数量多，否则多出来的consumer消费不到消息。\n\n\n\nkafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。\n\n如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer instance数量也设置为1，但是这样会影响性能，所以kafka的顺序消费很少用。\n\n# 3.2.3 producer\n\n写入方式\n\nproducer 采用 push 模式将消息发布到 broker，每条消息都是被append到patition中，属于顺序写磁盘\n\n消息路由\n\nproducer发送消息到broker时，会根据分区算法选择将其存储到哪一个partition。其路由机制为：\n\n1.指定了patition，则直接使用；\n\n2.未指定patition 但指定key，通过对key的value进行hash选出一个patition。\n\n3.patition和key都未指定，使用轮询选出一个patition。\n\n消息确认机制\n\nacks=0：表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。\n\nacks=1：至少要等待leader已经成功将数据写入本地log，但不需要等待所有follower是否成功写入。\n\nacks=-1或all：leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志\n\nacks=-1时的数据流程：\n\n\n\n1.producer先从zookeeper 的 "/brokers/.../state" 节点找到该partition的leader。\n\n2.producer将消息发送给该leader。\n\n3.leader将消息写入本地log。\n\n4.followers从leader pull消息，写入本地log后向leader发送ack。\n\n5.leader收到所有isr中的replica的ack后，增加hw（high watermark，最后 commit 的 offset）并向producer发送ack。\n\n\n# 3.3 选举机制\n\ncontroller选举机制\n\nkafka集群启动的时候，会自动选举一台broker作为controller来管理整个集群，选举的过程是集群中每个broker都会尝试在zookeeper上创建一个 /controller 临时节点，zookeeper会保证有且仅有一个broker能创建成功，这个broker就会成为集群的总控器controller。\n\npartition副本选举leader机制\n\ncontroller感知到分区leader所在的broker挂了，会从isr列表里挑第一个broker作为leader\n\n(参数unclean.leader.election.enable=false的前提下。\n\n参数unclean.leader.election.enable为true，则isr列表里所有副本都挂了的时候可以在isr列表外的副本中选leader，\n\n这种设置，可以提高可用性，但是选出的新leader有可能数据少很多。)\n\n副本进入isr列表有两个条件:\n\n1.必须能与zookeeper保持会话以及跟leader副本网络连通\n\n2.副本能复制leader上的所有写操作，并且不能落后太多。(与leader副本同步滞后的副本，是由 replica.lag.time.max.ms配置决定的，超过这个时间都没有跟leader同步过的一次的副本会被移出isr列表)\n\n\n# 3.4 hw与leo\n\nleo （log end offset）\n\nhw有两个主要的作用：\n\n1、用于实现副本备份机制（replication）；\n\n2、定义消息可见性，即hw之下的所有消息对consumer是可见的。如果没有hw机制，就需要其他手段来实现这两个功能。\n\n\n\n\n# 3.5 kafka核心总控制器controller\n\n在kafka集群中会有一个或者多个broker，其中有一个broker会被选举为控制器(kafka controller)，它负责管理整个集群中所有分区和副本的状态。\n\n主题管理\n\n完成对kafka主题的创建、删除以及分区增加的操作\n\n分区重分配\n\n对已有主题分区进行细粒度的分配功能\n\n集群成员管理\n\n自动检测新增broker、broker主动关闭、broker宕机.\n\n/brokers/ids/下面会存放broker实例的id临时节点，当我们看到/brokers/ids下面有几个节点，就表示有多少个存活的broker实例。\n\n当broker宕机时，临时节点就会被删除，此时控制器对应的监听器就会感知到broker下线，进而完成对应的下线工作。\n\n数据服务\n\n向其它broker提供数据服务，控制器上保存了最全的集群元数据信息,\n\n其它broker会定期接收控制器发来的元数据更新请求，从而更新其内存中的缓存数据\n\n\n# 3.6 kafka高性能原因\n\n * 磁盘顺序读写：kafka消息不能修改以及不会从文件中间删除保证了磁盘顺序读，kafka的消息写入文件都是追加在文件末尾。\n * **pagecache：**kafka重度依赖底层操作系统提供的磁盘高速缓存pagecache（内核缓冲区）功能。\n   当上层有写操作时，操作系统只是将数据写入pagecache，同时标记page属性为dirty。内存池再异步地写到磁盘上。\n   当读操作发生时，先从pagecache中查找，如果发生缺页才进行磁盘调度，最终返回需要的数据。\n   实际上pagecache是把尽可能多的空闲内存都当做了磁盘缓存来使用。\n   同时如果有其他进程申请内存，回收pagecache的代价又很小，所以现代的os都支持pagecache。\n * **零拷贝：**linux操作系统 “零拷贝” 机制使用了sendfile方法， 允许操作系统将数据从page cache 直接发送到网络，只需要最后一步的copy操作将数据复制到 nic 缓冲区， 这样避免重新复制数据 。通过这种 “零拷贝” 的机制，page cache 结合 sendfile 方法，kafka消费端的性能也大幅提升。这也是为什么有时候消费端在不断消费数据时，我们并没有看到磁盘io比较高，此刻正是操作系统缓存在提供数据。\n\n\n\n * 批量读写、批量压缩\n\n\n# 3.7 线上规划\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"Elasticsearch",frontmatter:{title:"Elasticsearch",date:"2022-04-28T18:14:29.000Z",permalink:"/pages/649d86/",categories:["知识整理"],tags:["ES"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/12.Elasticsearch.html",relativePath:"知识整理/12.Elasticsearch.md",key:"v-dcf1b992",path:"/pages/649d86/",headers:[{level:2,title:"1、canal",slug:"_1、canal",normalizedTitle:"1、canal",charIndex:20},{level:3,title:"1.1 什么是canal？",slug:"_1-1-什么是canal",normalizedTitle:"1.1 什么是canal？",charIndex:32},{level:3,title:"1.2 canal的工作原理？",slug:"_1-2-canal的工作原理",normalizedTitle:"1.2 canal的工作原理？",charIndex:181},{level:3,title:"1.3 canal高可用？",slug:"_1-3-canal高可用",normalizedTitle:"1.3 canal高可用？",charIndex:541},{level:3,title:"1.4 canal投递消息到kafka",slug:"_1-4-canal投递消息到kafka",normalizedTitle:"1.4 canal投递消息到kafka",charIndex:785},{level:2,title:"2、mysql的binlog",slug:"_2、mysql的binlog",normalizedTitle:"2、mysql的binlog",charIndex:1957},{level:3,title:"2.1 什么是binlog？",slug:"_2-1-什么是binlog",normalizedTitle:"2.1 什么是binlog？",charIndex:1976},{level:3,title:"2.2 怎么开启binlog？",slug:"_2-2-怎么开启binlog",normalizedTitle:"2.2 怎么开启binlog？",charIndex:2315},{level:3,title:"2.3 binlog有几种格式？",slug:"_2-3-binlog有几种格式",normalizedTitle:"2.3 binlog有几种格式？",charIndex:2498},{level:3,title:"2.4 binlog格式怎么选择？",slug:"_2-4-binlog格式怎么选择",normalizedTitle:"2.4 binlog格式怎么选择？",charIndex:2559},{level:2,title:"3、Oracle GoldenGate（ogg）",slug:"_3、oracle-goldengate-ogg",normalizedTitle:"3、oracle goldengate（ogg）",charIndex:2624},{level:3,title:"3.1 什么是ogg？",slug:"_3-1-什么是ogg",normalizedTitle:"3.1 什么是ogg？",charIndex:2653},{level:2,title:"4、日志系统实现思路",slug:"_4、日志系统实现思路",normalizedTitle:"4、日志系统实现思路",charIndex:2815},{level:2,title:"5、Elasticsearch",slug:"_5、elasticsearch",normalizedTitle:"5、elasticsearch",charIndex:3023},{level:3,title:"5.1 elasticsearch的倒排索引是什么？",slug:"_5-1-elasticsearch的倒排索引是什么",normalizedTitle:"5.1 elasticsearch的倒排索引是什么？",charIndex:3045},{level:3,title:"5.2 elasticsearch索引数据多了怎么办？",slug:"_5-2-elasticsearch索引数据多了怎么办",normalizedTitle:"5.2 elasticsearch索引数据多了怎么办？",charIndex:3159},{level:3,title:"5.3 说说公司ES的集群架构，索引数据大小，分片有多少？",slug:"_5-3-说说公司es的集群架构-索引数据大小-分片有多少",normalizedTitle:"5.3 说说公司es的集群架构，索引数据大小，分片有多少？",charIndex:3268}],headersStr:"1、canal 1.1 什么是canal？ 1.2 canal的工作原理？ 1.3 canal高可用？ 1.4 canal投递消息到kafka 2、mysql的binlog 2.1 什么是binlog？ 2.2 怎么开启binlog？ 2.3 binlog有几种格式？ 2.4 binlog格式怎么选择？ 3、Oracle GoldenGate（ogg） 3.1 什么是ogg？ 4、日志系统实现思路 5、Elasticsearch 5.1 elasticsearch的倒排索引是什么？ 5.2 elasticsearch索引数据多了怎么办？ 5.3 说说公司ES的集群架构，索引数据大小，分片有多少？",content:'# Elasticsearch\n\n\n# 1、canal\n\n\n# 1.1 什么是canal？\n\ncanal是用java开发的基于数据库增量日志解析，提供增量数据订阅&消费的中间件。\n\n目前，canal主要支持MySQL的binlog解析，解析完成才利用canal client用来处理获得的相关数据。数据库同步需要阿里的otter中间件，基于canal。\n\n\n# 1.2 canal的工作原理？\n\n\n\n首先了解一下mysql主备复制原理：\n\n（1）master主库将改变记录，发送到二进制文件（binary log）中\n\n（2）slave从库向mysql Master发送dump协议，将master主库的binary log events拷贝到它的中继日志（relay log）\n\n（3）slave从库读取并重做中继日志中的事件，将改变的数据同步到自己的数据库\n\n\n\ncanal的工作原理\n\n把自己伪装成slave，从master复制数据。读取binlog是需要master授权的，因为binlog是加密的，授权分用户名密码才能读。\n\nmaster授权后不知道读他的binlog的是从机还是canal，他的所有传输协议都符合从机的标准，所以master一直以为是从机读的。\n\n\n# 1.3 canal高可用？\n\n有两个canal服务器都监控一个或多个mysql服务器的binlog，这两个canal服务同时只能有一个提供服务。\n\n当提供服务的这个宕机时，zookeeper能知道，zookeeper就通知另一个canal服务器让他提供服务。\n\n当原来宕机的那个再启动起来时，是抢占模式的，谁抢到就谁上，没抢到就standy模式。\n\ncanal本身就是一个工具不存数据，宕机了就宕机，只有还有另外一个能提供服务就行，所以没有什么同步问题（不像数据库有同步问题）。\n\n\n# 1.4 canal投递消息到kafka\n\n1.canal投递消息到kafka，可指定mysql库表，支持按库表指定字段hash投递的kafka的partition。\n\n2.canal投递到kafka的消息体，例如：\n\nConsumerRecord(topic = binlog, partition = 0, offset = 29, CreateTime = 1647331490778, serialized key size = -1, serialized value size = 52, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = {"event":"datatest.user.update","value":[999,"ccc"]})\n\nConsumerRecord(topic = binlog, partition = 1, offset = 21, CreateTime = 1647331490777, serialized key size = -1, serialized value size = 62, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = "{\\"event\\":\\"datatest.user.update\\",\\"value\\":[999,\\"ccc\\"]}")\n\nConsumerRecord(topic = binlog, partition = 0, offset = 30, CreateTime = 1647268549467, serialized key size = -1, serialized value size = 276, headers = RecordHeaders(headers = [], isReadOnly = false), key = null, value = {"data":[{"id":"999","name":"ccc"}],"database":"datatest","es":1647331490000,"id":8,"isDdl":false,"mysqlType":{"id":"int(11)","name":"varchar(50)"},"old":[{"name":"bbb"}],"pkNames":["id"],"sql":"","sqlType":{"id":4,"name":12},"table":"user","ts":1647268549466,"type":"UPDATE"})\n\n\n# 2、mysql的binlog\n\n\n# 2.1 什么是binlog？\n\nmysql的二进制日志，记录了所有的DDL和DML（除了数据查询语句），以事件的形式进行记录，包含语句执行消耗的时间，mysql的二进制日志是事务安全型的。\n\n开启二进制日志大概会有1%的性能损坏。\n\n二进制日志有2个主要的使用场景：\n\n① mysql的主备复制\n\n② 数据恢复，通过使用mysqlbinlog工具来恢复数据\n\n（用这个做恢复是备选方案，主方案还是定期快照，定期执行脚本导数据，其实就是把当前所有数据导成insert，这个量少）\n\n二进制日志包括2类文件：\n\n①二进制日志索引文件（后缀为.index）用于记录所有的二进制文件\n\n②二进制日志文件（后缀为.00000*）记录数据库所有的DDL和DML（除了数据查询语句）\n\n\n# 2.2 怎么开启binlog？\n\n1.修改my.cnf配置\n\n\n\n2.重启mysql\n\n\n\n3.查看开启状态\n\n输入 show variables like \'log_bin\'; 查看binlog开启状态。如下图所示。\n\n\n\n输入 show variables like \'binlog_format\'; 查看Binary Log记录方式。如下图所示。\n\n\n\n\n# 2.3 binlog有几种格式？\n\nbinlog的格式有三种：STATEMENT,MIXED,ROW对比如下\n\n\n\n\n# 2.4 binlog格式怎么选择？\n\n如果只考虑主从复制的话可以用mixed。\n\n抽取数据用于统计分析之类的话用row。\n\n\n# 3、Oracle GoldenGate（ogg）\n\n\n# 3.1 什么是ogg？\n\nGoldenGate软件是一种基于日志的结构化数据复制软件，它通过解析源数据库在线日志或归档日志获得数据的增量变化，再将这些变化应用到目标 数据库，从而实现源数据库与目标数据库同步。\n\nGoldenGate可以实现一对一、广播(一对多)、聚合(多对一)、双向、点对点、级联等多种拓扑结构。\n\n\n# 4、日志系统实现思路\n\n1.业务入口生成唯一traceId -> 发送kafka落日志文件（包含此次操作的用户信息）\n\n-> 数据变更落数据库（包含traceId）\n\n2.binglog -> kafka -> 有traceId变更的数据解析落日志文件（包含本次变更的所有字段）\n\n3.flume收集日志 -> kafka -> flink接收日志并清洗 -> 写入es（相同traceId关联成一条数据）\n\n\n# 5、Elasticsearch\n\n\n\n\n# 5.1 elasticsearch的倒排索引是什么？\n\n例如：查询指定关键词的文章。\n\n传统的检索是：遍历文章找到有对应的关键词。\n\n倒排索引：通过分词策略，形成词和文章的映射关系表，这种词典+映射表即为倒排索引。\n\n\n\n\n# 5.2 elasticsearch索引数据多了怎么办？\n\n1.使用滚动索引。基于模板+时间+rollover api滚动创建索引。\n\n2.只保留指定时间范围内数据。\n\n3.动态增加节点。ES自身支持动态扩展。\n\n\n# 5.3 说说公司ES的集群架构，索引数据大小，分片有多少？\n\n集群架构\n\nES的集群架构有23个节点，节点配置是16核64G的。\n\n索引数据大小\n\n该集群架构包括了订单服务和运单服务的索引，其中我们负责的运单服务包括寄件运单和派件运单索引。\n\n索引根据录入时间每日递增（滚动索引）。当时每日新增数据两个索引大概四五千万，数据大小几十G。\n\n分片数量\n\n10个分片。5个主分片和5个副本分片。',normalizedContent:'# elasticsearch\n\n\n# 1、canal\n\n\n# 1.1 什么是canal？\n\ncanal是用java开发的基于数据库增量日志解析，提供增量数据订阅&消费的中间件。\n\n目前，canal主要支持mysql的binlog解析，解析完成才利用canal client用来处理获得的相关数据。数据库同步需要阿里的otter中间件，基于canal。\n\n\n# 1.2 canal的工作原理？\n\n\n\n首先了解一下mysql主备复制原理：\n\n（1）master主库将改变记录，发送到二进制文件（binary log）中\n\n（2）slave从库向mysql master发送dump协议，将master主库的binary log events拷贝到它的中继日志（relay log）\n\n（3）slave从库读取并重做中继日志中的事件，将改变的数据同步到自己的数据库\n\n\n\ncanal的工作原理\n\n把自己伪装成slave，从master复制数据。读取binlog是需要master授权的，因为binlog是加密的，授权分用户名密码才能读。\n\nmaster授权后不知道读他的binlog的是从机还是canal，他的所有传输协议都符合从机的标准，所以master一直以为是从机读的。\n\n\n# 1.3 canal高可用？\n\n有两个canal服务器都监控一个或多个mysql服务器的binlog，这两个canal服务同时只能有一个提供服务。\n\n当提供服务的这个宕机时，zookeeper能知道，zookeeper就通知另一个canal服务器让他提供服务。\n\n当原来宕机的那个再启动起来时，是抢占模式的，谁抢到就谁上，没抢到就standy模式。\n\ncanal本身就是一个工具不存数据，宕机了就宕机，只有还有另外一个能提供服务就行，所以没有什么同步问题（不像数据库有同步问题）。\n\n\n# 1.4 canal投递消息到kafka\n\n1.canal投递消息到kafka，可指定mysql库表，支持按库表指定字段hash投递的kafka的partition。\n\n2.canal投递到kafka的消息体，例如：\n\nconsumerrecord(topic = binlog, partition = 0, offset = 29, createtime = 1647331490778, serialized key size = -1, serialized value size = 52, headers = recordheaders(headers = [], isreadonly = false), key = null, value = {"event":"datatest.user.update","value":[999,"ccc"]})\n\nconsumerrecord(topic = binlog, partition = 1, offset = 21, createtime = 1647331490777, serialized key size = -1, serialized value size = 62, headers = recordheaders(headers = [], isreadonly = false), key = null, value = "{\\"event\\":\\"datatest.user.update\\",\\"value\\":[999,\\"ccc\\"]}")\n\nconsumerrecord(topic = binlog, partition = 0, offset = 30, createtime = 1647268549467, serialized key size = -1, serialized value size = 276, headers = recordheaders(headers = [], isreadonly = false), key = null, value = {"data":[{"id":"999","name":"ccc"}],"database":"datatest","es":1647331490000,"id":8,"isddl":false,"mysqltype":{"id":"int(11)","name":"varchar(50)"},"old":[{"name":"bbb"}],"pknames":["id"],"sql":"","sqltype":{"id":4,"name":12},"table":"user","ts":1647268549466,"type":"update"})\n\n\n# 2、mysql的binlog\n\n\n# 2.1 什么是binlog？\n\nmysql的二进制日志，记录了所有的ddl和dml（除了数据查询语句），以事件的形式进行记录，包含语句执行消耗的时间，mysql的二进制日志是事务安全型的。\n\n开启二进制日志大概会有1%的性能损坏。\n\n二进制日志有2个主要的使用场景：\n\n① mysql的主备复制\n\n② 数据恢复，通过使用mysqlbinlog工具来恢复数据\n\n（用这个做恢复是备选方案，主方案还是定期快照，定期执行脚本导数据，其实就是把当前所有数据导成insert，这个量少）\n\n二进制日志包括2类文件：\n\n①二进制日志索引文件（后缀为.index）用于记录所有的二进制文件\n\n②二进制日志文件（后缀为.00000*）记录数据库所有的ddl和dml（除了数据查询语句）\n\n\n# 2.2 怎么开启binlog？\n\n1.修改my.cnf配置\n\n\n\n2.重启mysql\n\n\n\n3.查看开启状态\n\n输入 show variables like \'log_bin\'; 查看binlog开启状态。如下图所示。\n\n\n\n输入 show variables like \'binlog_format\'; 查看binary log记录方式。如下图所示。\n\n\n\n\n# 2.3 binlog有几种格式？\n\nbinlog的格式有三种：statement,mixed,row对比如下\n\n\n\n\n# 2.4 binlog格式怎么选择？\n\n如果只考虑主从复制的话可以用mixed。\n\n抽取数据用于统计分析之类的话用row。\n\n\n# 3、oracle goldengate（ogg）\n\n\n# 3.1 什么是ogg？\n\ngoldengate软件是一种基于日志的结构化数据复制软件，它通过解析源数据库在线日志或归档日志获得数据的增量变化，再将这些变化应用到目标 数据库，从而实现源数据库与目标数据库同步。\n\ngoldengate可以实现一对一、广播(一对多)、聚合(多对一)、双向、点对点、级联等多种拓扑结构。\n\n\n# 4、日志系统实现思路\n\n1.业务入口生成唯一traceid -> 发送kafka落日志文件（包含此次操作的用户信息）\n\n-> 数据变更落数据库（包含traceid）\n\n2.binglog -> kafka -> 有traceid变更的数据解析落日志文件（包含本次变更的所有字段）\n\n3.flume收集日志 -> kafka -> flink接收日志并清洗 -> 写入es（相同traceid关联成一条数据）\n\n\n# 5、elasticsearch\n\n\n\n\n# 5.1 elasticsearch的倒排索引是什么？\n\n例如：查询指定关键词的文章。\n\n传统的检索是：遍历文章找到有对应的关键词。\n\n倒排索引：通过分词策略，形成词和文章的映射关系表，这种词典+映射表即为倒排索引。\n\n\n\n\n# 5.2 elasticsearch索引数据多了怎么办？\n\n1.使用滚动索引。基于模板+时间+rollover api滚动创建索引。\n\n2.只保留指定时间范围内数据。\n\n3.动态增加节点。es自身支持动态扩展。\n\n\n# 5.3 说说公司es的集群架构，索引数据大小，分片有多少？\n\n集群架构\n\nes的集群架构有23个节点，节点配置是16核64g的。\n\n索引数据大小\n\n该集群架构包括了订单服务和运单服务的索引，其中我们负责的运单服务包括寄件运单和派件运单索引。\n\n索引根据录入时间每日递增（滚动索引）。当时每日新增数据两个索引大概四五千万，数据大小几十g。\n\n分片数量\n\n10个分片。5个主分片和5个副本分片。',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"redis",frontmatter:{title:"redis",date:"2022-04-28T18:14:52.000Z",permalink:"/pages/26e33d/",categories:["知识整理"],tags:["Redis"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/13.redis.html",relativePath:"知识整理/13.redis.md",key:"v-64a87d57",path:"/pages/26e33d/",headers:[{level:2,title:"1、什么是位图？",slug:"_1、什么是位图",normalizedTitle:"1、什么是位图？",charIndex:12},{level:2,title:"2、什么是布隆过滤器？",slug:"_2、什么是布隆过滤器",normalizedTitle:"2、什么是布隆过滤器？",charIndex:286},{level:2,title:"3、redis怎么进行过期删除？",slug:"_3、redis怎么进行过期删除",normalizedTitle:"3、redis怎么进行过期删除？",charIndex:589},{level:3,title:"3.1 定期删除",slug:"_3-1-定期删除",normalizedTitle:"3.1 定期删除",charIndex:741},{level:3,title:"3.2 惰性删除",slug:"_3-2-惰性删除",normalizedTitle:"3.2 惰性删除",charIndex:897},{level:3,title:"3.3 主动清理策略",slug:"_3-3-主动清理策略",normalizedTitle:"3.3 主动清理策略",charIndex:1159},{level:4,title:"a) 针对设置了过期时间的key做处理：",slug:"a-针对设置了过期时间的key做处理",normalizedTitle:"a) 针对设置了过期时间的key做处理：",charIndex:1294},{level:5,title:"3.3.1 volatile-ttl",slug:"_3-3-1-volatile-ttl",normalizedTitle:"3.3.1 volatile-ttl",charIndex:1318},{level:5,title:"3.3.2 volatile-random",slug:"_3-3-2-volatile-random",normalizedTitle:"3.3.2 volatile-random",charIndex:1387},{level:5,title:"3.3.3 volatile-lru",slug:"_3-3-3-volatile-lru",normalizedTitle:"3.3.3 volatile-lru",charIndex:1444},{level:5,title:"3.3.4 volatile-lfu",slug:"_3-3-4-volatile-lfu",normalizedTitle:"3.3.4 volatile-lfu",charIndex:1494},{level:4,title:"b) 针对所有的key做处理：",slug:"b-针对所有的key做处理",normalizedTitle:"b) 针对所有的key做处理：",charIndex:1544},{level:5,title:"3.3.5 allkeys-random",slug:"_3-3-5-allkeys-random",normalizedTitle:"3.3.5 allkeys-random",charIndex:1563},{level:5,title:"3.3.6 allkeys-lru",slug:"_3-3-6-allkeys-lru",normalizedTitle:"3.3.6 allkeys-lru",charIndex:1606},{level:5,title:"3.3.7 allkeys-lfu",slug:"_3-3-7-allkeys-lfu",normalizedTitle:"3.3.7 allkeys-lfu",charIndex:1651},{level:4,title:"c) 不处理：",slug:"c-不处理",normalizedTitle:"c) 不处理：",charIndex:1696},{level:5,title:"3.3.8 noeviction",slug:"_3-3-8-noeviction",normalizedTitle:"3.3.8 noeviction",charIndex:1707},{level:3,title:"3.4 LFU、LRU数据淘汰策略",slug:"_3-4-lfu、lru数据淘汰策略",normalizedTitle:"3.4 lfu、lru数据淘汰策略",charIndex:1822},{level:4,title:"3.4.1 LRU",slug:"_3-4-1-lru",normalizedTitle:"3.4.1 lru",charIndex:1843},{level:4,title:"3.4.2 LFU",slug:"_3-4-2-lfu",normalizedTitle:"3.4.2 lfu",charIndex:1921},{level:4,title:"3.4.3 配置建议",slug:"_3-4-3-配置建议",normalizedTitle:"3.4.3 配置建议",charIndex:2001},{level:2,title:"4、Redis最大内存配置",slug:"_4、redis最大内存配置",normalizedTitle:"4、redis最大内存配置",charIndex:2088},{level:2,title:"5、Redis怎么做持久化的？",slug:"_5、redis怎么做持久化的",normalizedTitle:"5、redis怎么做持久化的？",charIndex:2283},{level:3,title:"5.1 RDB持久化(快照持久化)",slug:"_5-1-rdb持久化-快照持久化",normalizedTitle:"5.1 rdb持久化(快照持久化)",charIndex:2404},{level:4,title:"5.1.1 RDB持久化是怎么触发的？",slug:"_5-1-1-rdb持久化是怎么触发的",normalizedTitle:"5.1.1 rdb持久化是怎么触发的？",charIndex:2497},{level:5,title:"5.1.1.1 save触发方式",slug:"_5-1-1-1-save触发方式",normalizedTitle:"5.1.1.1 save触发方式",charIndex:2550},{level:5,title:"5.1.1.2 bgsave触发方式",slug:"_5-1-1-2-bgsave触发方式",normalizedTitle:"5.1.1.2 bgsave触发方式",charIndex:2619},{level:5,title:"5.1.1.3 自动触发方式",slug:"_5-1-1-3-自动触发方式",normalizedTitle:"5.1.1.3 自动触发方式",charIndex:2790},{level:4,title:"5.1.2 RDB有什么优势和劣势？",slug:"_5-1-2-rdb有什么优势和劣势",normalizedTitle:"5.1.2 rdb有什么优势和劣势？",charIndex:3058},{level:5,title:"5.1.2.1 RDB优势",slug:"_5-1-2-1-rdb优势",normalizedTitle:"5.1.2.1 rdb优势",charIndex:3080},{level:5,title:"5.1.2.1 RDB劣势",slug:"_5-1-2-1-rdb劣势",normalizedTitle:"5.1.2.1 rdb劣势",charIndex:3184},{level:3,title:"5.2 AOF持久化(append-only file)",slug:"_5-2-aof持久化-append-only-file",normalizedTitle:"5.2 aof持久化(append-only file)",charIndex:3229},{level:4,title:"5.2.1 AOF的持久化是怎么触发的？",slug:"_5-2-1-aof的持久化是怎么触发的",normalizedTitle:"5.2.1 aof的持久化是怎么触发的？",charIndex:3425},{level:5,title:"5.2.1.1 appendfsync always",slug:"_5-2-1-1-appendfsync-always",normalizedTitle:"5.2.1.1 appendfsync always",charIndex:3487},{level:5,title:"5.2.1.2 appendfsync everysec",slug:"_5-2-1-2-appendfsync-everysec",normalizedTitle:"5.2.1.2 appendfsync everysec",charIndex:3555},{level:5,title:"5.2.1.3 appendfsync no",slug:"_5-2-1-3-appendfsync-no",normalizedTitle:"5.2.1.3 appendfsync no",charIndex:3621},{level:4,title:"5.2.2 AOF持久化3种触发方式的对比？",slug:"_5-2-2-aof持久化3种触发方式的对比",normalizedTitle:"5.2.2 aof持久化3种触发方式的对比？",charIndex:3663},{level:4,title:"5.2.3 AOF方式什么时候会出现文件重写？",slug:"_5-2-3-aof方式什么时候会出现文件重写",normalizedTitle:"5.2.3 aof方式什么时候会出现文件重写？",charIndex:3691},{level:4,title:"5.2.4 AOF有什么优势和劣势？",slug:"_5-2-4-aof有什么优势和劣势",normalizedTitle:"5.2.4 aof有什么优势和劣势？",charIndex:3849},{level:5,title:"5.2.4.1 AOF优势",slug:"_5-2-4-1-aof优势",normalizedTitle:"5.2.4.1 aof优势",charIndex:3871},{level:5,title:"5.2.4.2 AOF劣势",slug:"_5-2-4-2-aof劣势",normalizedTitle:"5.2.4.2 aof劣势",charIndex:4090},{level:3,title:"5.3 混合持久化",slug:"_5-3-混合持久化",normalizedTitle:"5.3 混合持久化",charIndex:4139},{level:3,title:"5.4 数据怎么恢复？",slug:"_5-4-数据怎么恢复",normalizedTitle:"5.4 数据怎么恢复？",charIndex:4507},{level:2,title:"6、缓存雪崩｜缓存击穿｜缓存穿透",slug:"_6、缓存雪崩-缓存击穿-缓存穿透",normalizedTitle:"6、缓存雪崩｜缓存击穿｜缓存穿透",charIndex:4529},{level:3,title:"6.1 缓存雪崩",slug:"_6-1-缓存雪崩",normalizedTitle:"6.1 缓存雪崩",charIndex:4550},{level:4,title:"6.1.1 什么是缓存雪崩？",slug:"_6-1-1-什么是缓存雪崩",normalizedTitle:"6.1.1 什么是缓存雪崩？",charIndex:4562},{level:4,title:"6.1.2 缓存雪崩有什么解决方案？",slug:"_6-1-2-缓存雪崩有什么解决方案",normalizedTitle:"6.1.2 缓存雪崩有什么解决方案？",charIndex:4625},{level:3,title:"6.2 缓存击穿",slug:"_6-2-缓存击穿",normalizedTitle:"6.2 缓存击穿",charIndex:4780},{level:4,title:"6.2.1 什么是缓存击穿？",slug:"_6-2-1-什么是缓存击穿",normalizedTitle:"6.2.1 什么是缓存击穿？",charIndex:4792},{level:4,title:"6.2.2 缓存击穿有什么解决方案？",slug:"_6-2-2-缓存击穿有什么解决方案",normalizedTitle:"6.2.2 缓存击穿有什么解决方案？",charIndex:4908},{level:3,title:"6.3 缓存穿透",slug:"_6-3-缓存穿透",normalizedTitle:"6.3 缓存穿透",charIndex:5015},{level:4,title:"6.3.1 什么是缓存穿透？",slug:"_6-3-1-什么是缓存穿透",normalizedTitle:"6.3.1 什么是缓存穿透？",charIndex:5027},{level:4,title:"6.3.2 缓存穿透有什么解决方案？",slug:"_6-3-2-缓存穿透有什么解决方案",normalizedTitle:"6.3.2 缓存穿透有什么解决方案？",charIndex:5113},{level:2,title:"7、Redis集群",slug:"_7、redis集群",normalizedTitle:"7、redis集群",charIndex:5257},{level:3,title:"7.1 主从复制",slug:"_7-1-主从复制",normalizedTitle:"7.1 主从复制",charIndex:5271},{level:4,title:"7.1.1 全量复制",slug:"_7-1-1-全量复制",normalizedTitle:"7.1.1 全量复制",charIndex:5283},{level:4,title:"7.1.2 部分复制、断点续传",slug:"_7-1-2-部分复制、断点续传",normalizedTitle:"7.1.2 部分复制、断点续传",charIndex:5718},{level:4,title:"7.1.3 主从复制风暴",slug:"_7-1-3-主从复制风暴",normalizedTitle:"7.1.3 主从复制风暴",charIndex:5953},{level:3,title:"7.2 哨兵模式",slug:"_7-2-哨兵模式",normalizedTitle:"7.2 哨兵模式",charIndex:6049},{level:3,title:"7.3 高可用集群模式",slug:"_7-3-高可用集群模式",normalizedTitle:"7.3 高可用集群模式",charIndex:6359},{level:3,title:"7.4 Redis集群节点间的通信机制",slug:"_7-4-redis集群节点间的通信机制",normalizedTitle:"7.4 redis集群节点间的通信机制",charIndex:6611},{level:3,title:"7.5 Redis集群选举",slug:"_7-5-redis集群选举",normalizedTitle:"7.5 redis集群选举",charIndex:6941},{level:4,title:"7.5.1 选举流程",slug:"_7-5-1-选举流程",normalizedTitle:"7.5.1 选举流程",charIndex:6958},{level:4,title:"7.5.2 集群脑裂问题",slug:"_7-5-2-集群脑裂问题",normalizedTitle:"7.5.2 集群脑裂问题",charIndex:7675},{level:4,title:"7.5.3 Redis集群为什么至少要三个master节点，并且推荐奇数？",slug:"_7-5-3-redis集群为什么至少要三个master节点-并且推荐奇数",normalizedTitle:"7.5.3 redis集群为什么至少要三个master节点，并且推荐奇数？",charIndex:7770},{level:3,title:"7.2 Redis集群下可以执行批量操作命令吗？",slug:"_7-2-redis集群下可以执行批量操作命令吗",normalizedTitle:"7.2 redis集群下可以执行批量操作命令吗？",charIndex:8003},{level:3,title:"7.3 Redis集群支持多数据库吗？",slug:"_7-3-redis集群支持多数据库吗",normalizedTitle:"7.3 redis集群支持多数据库吗？",charIndex:8199},{level:3,title:"7.4 Redis集群不足的地方？",slug:"_7-4-redis集群不足的地方",normalizedTitle:"7.4 redis集群不足的地方？",charIndex:8269},{level:3,title:"7.5 Redis集群方案什么情况下会导致集群不可用？",slug:"_7-5-redis集群方案什么情况下会导致集群不可用",normalizedTitle:"7.5 redis集群方案什么情况下会导致集群不可用？",charIndex:8363},{level:2,title:"8、Redis基础",slug:"_8、redis基础",normalizedTitle:"8、redis基础",charIndex:8497},{level:3,title:"8.1 Redis是单线程的吗？",slug:"_8-1-redis是单线程的吗",normalizedTitle:"8.1 redis是单线程的吗？",charIndex:8511},{level:3,title:"8.2 Redis单线程为什么还能这么快？",slug:"_8-2-redis单线程为什么还能这么快",normalizedTitle:"8.2 redis单线程为什么还能这么快？",charIndex:8666},{level:3,title:"8.3 Redis单线程如何处理那么多的并发客户端连接？",slug:"_8-3-redis单线程如何处理那么多的并发客户端连接",normalizedTitle:"8.3 redis单线程如何处理那么多的并发客户端连接？",charIndex:8822},{level:3,title:"8.4 Redis支持哪些数据类型？",slug:"_8-4-redis支持哪些数据类型",normalizedTitle:"8.4 redis支持哪些数据类型？",charIndex:9324},{level:3,title:"8.5 Redis的单点吞吐量？",slug:"_8-5-redis的单点吞吐量",normalizedTitle:"8.5 redis的单点吞吐量？",charIndex:9943},{level:3,title:"8.6 其他高级命令",slug:"_8-6-其他高级命令",normalizedTitle:"8.6 其他高级命令",charIndex:9987},{level:2,title:"9、Redisson",slug:"_9、redisson",normalizedTitle:"9、redisson",charIndex:10063},{level:3,title:"9.1 使用例子",slug:"_9-1-使用例子",normalizedTitle:"9.1 使用例子",charIndex:10078},{level:3,title:"9.2 分布式锁演变过程",slug:"_9-2-分布式锁演变过程",normalizedTitle:"9.2 分布式锁演变过程",charIndex:10163},{level:4,title:"9.2.1 SETNX",slug:"_9-2-1-setnx",normalizedTitle:"9.2.1 setnx",charIndex:10179},{level:4,title:"9.2.2 超时设置",slug:"_9-2-2-超时设置",normalizedTitle:"9.2.2 超时设置",charIndex:10242},{level:4,title:"9.2.3 只能释放自己的锁",slug:"_9-2-3-只能释放自己的锁",normalizedTitle:"9.2.3 只能释放自己的锁",charIndex:10556},{level:4,title:"9.2.4 正确设置锁超时",slug:"_9-2-4-正确设置锁超时",normalizedTitle:"9.2.4 正确设置锁超时",charIndex:11142},{level:4,title:"9.2.5 实现可重入锁",slug:"_9-2-5-实现可重入锁",normalizedTitle:"9.2.5 实现可重入锁",charIndex:11296},{level:3,title:"9.3 Redis分布式锁存在什么缺点？",slug:"_9-3-redis分布式锁存在什么缺点",normalizedTitle:"9.3 redis分布式锁存在什么缺点？",charIndex:11662}],headersStr:"1、什么是位图？ 2、什么是布隆过滤器？ 3、redis怎么进行过期删除？ 3.1 定期删除 3.2 惰性删除 3.3 主动清理策略 a) 针对设置了过期时间的key做处理： 3.3.1 volatile-ttl 3.3.2 volatile-random 3.3.3 volatile-lru 3.3.4 volatile-lfu b) 针对所有的key做处理： 3.3.5 allkeys-random 3.3.6 allkeys-lru 3.3.7 allkeys-lfu c) 不处理： 3.3.8 noeviction 3.4 LFU、LRU数据淘汰策略 3.4.1 LRU 3.4.2 LFU 3.4.3 配置建议 4、Redis最大内存配置 5、Redis怎么做持久化的？ 5.1 RDB持久化(快照持久化) 5.1.1 RDB持久化是怎么触发的？ 5.1.1.1 save触发方式 5.1.1.2 bgsave触发方式 5.1.1.3 自动触发方式 5.1.2 RDB有什么优势和劣势？ 5.1.2.1 RDB优势 5.1.2.1 RDB劣势 5.2 AOF持久化(append-only file) 5.2.1 AOF的持久化是怎么触发的？ 5.2.1.1 appendfsync always 5.2.1.2 appendfsync everysec 5.2.1.3 appendfsync no 5.2.2 AOF持久化3种触发方式的对比？ 5.2.3 AOF方式什么时候会出现文件重写？ 5.2.4 AOF有什么优势和劣势？ 5.2.4.1 AOF优势 5.2.4.2 AOF劣势 5.3 混合持久化 5.4 数据怎么恢复？ 6、缓存雪崩｜缓存击穿｜缓存穿透 6.1 缓存雪崩 6.1.1 什么是缓存雪崩？ 6.1.2 缓存雪崩有什么解决方案？ 6.2 缓存击穿 6.2.1 什么是缓存击穿？ 6.2.2 缓存击穿有什么解决方案？ 6.3 缓存穿透 6.3.1 什么是缓存穿透？ 6.3.2 缓存穿透有什么解决方案？ 7、Redis集群 7.1 主从复制 7.1.1 全量复制 7.1.2 部分复制、断点续传 7.1.3 主从复制风暴 7.2 哨兵模式 7.3 高可用集群模式 7.4 Redis集群节点间的通信机制 7.5 Redis集群选举 7.5.1 选举流程 7.5.2 集群脑裂问题 7.5.3 Redis集群为什么至少要三个master节点，并且推荐奇数？ 7.2 Redis集群下可以执行批量操作命令吗？ 7.3 Redis集群支持多数据库吗？ 7.4 Redis集群不足的地方？ 7.5 Redis集群方案什么情况下会导致集群不可用？ 8、Redis基础 8.1 Redis是单线程的吗？ 8.2 Redis单线程为什么还能这么快？ 8.3 Redis单线程如何处理那么多的并发客户端连接？ 8.4 Redis支持哪些数据类型？ 8.5 Redis的单点吞吐量？ 8.6 其他高级命令 9、Redisson 9.1 使用例子 9.2 分布式锁演变过程 9.2.1 SETNX 9.2.2 超时设置 9.2.3 只能释放自己的锁 9.2.4 正确设置锁超时 9.2.5 实现可重入锁 9.3 Redis分布式锁存在什么缺点？",content:'# Redis\n\n\n# 1、什么是位图？\n\n一个由1亿个数组成的集合M，范围从1~10亿。新来一个数n，如何快速且地判断是否存在M中？\n\n申请一个大小为10亿，数据类型为布尔的“特殊”散列表，将这一亿个数作为散列表下标，将值设成True。\n\n\n\n不过很多语言的布尔大小是1字节，并不能节省很大空间，实际上只需要使用1个二进制位，来表示true和false两个值就行了。\n\n这就要用到位运算了，借助编程语言提供的数据类型，比如int，char等，通过位运算，用其中的某个位表示某个数字。 这就是位图。\n\n\n\n消耗大小：约120M。\n\n操作平台拦截件使用了位图实现！\n\n\n# 2、什么是布隆过滤器？\n\n位图有个问题，想想看，如果数的范围是1到100亿呢，那位图消耗的大小就是1.2G了！！，相对于散列表，不降反升。 这个时候，布隆过滤器登场了，它其实是对位图一种改进。\n\n * 针对数据范围是1到100亿的集合，还是申请10亿的二进制大小的位图（消耗内存120M）\n * 使用多个哈希函数，得到k个不同的哈希值，记为 x1,x2,x3...xk。将k个数字作为位图中的下标，将对应的值设为1\n\n\n\n * 适当选择k个哈希函数，k个哈希值都相同的概率就非常低了，但又会带来新的问题，那就是误判\n\n\n\n * 布隆过滤器的误判有个特点：\n\n没有就是没有，有就有极低的可能会没有。\n\n\n# 3、redis怎么进行过期删除？\n\n我们set key的时候，都可以给一个expire time，就是过期时间，通过过期时间我们可以指定这个key可以存活的时间。\n\n如果假设你设置了一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的?\n\n定期删除+惰性删除。\n\n\n# 3.1 定期删除\n\nredis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢?你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载!\n\n\n# 3.2 惰性删除\n\n定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈!\n\n但是仅仅通过设置过期时间还是有问题的。我们想一下:如果定期删除漏掉了很多过期 key，然后你也没及时去查， 也就没走惰性删除，此时会怎么样?如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢? -- redis内存淘汰机制。\n\n\n# 3.3 主动清理策略\n\n根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，\n\n推荐使用volatile-lru。\n\n主动清理策略在Redis4.0之前一共实现了6种内存淘汰策略，在4.0之后，又增加了2种策略，总共8种策略：\n\n# a) 针对设置了过期时间的key做处理：\n\n# 3.3.1 volatile-ttl\n\n在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。\n\n# 3.3.2 volatile-random\n\n就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。\n\n# 3.3.3 volatile-lru\n\n会使用 LRU 算法筛选设置了过期时间的键值对删除。\n\n# 3.3.4 volatile-lfu\n\n会使用 LFU 算法筛选设置了过期时间的键值对删除。\n\n# b) 针对所有的key做处理：\n\n# 3.3.5 allkeys-random\n\n从所有键值对中随机选择并删除数据。\n\n# 3.3.6 allkeys-lru\n\n使用 LRU 算法在所有数据中进行筛选删除。\n\n# 3.3.7 allkeys-lfu\n\n使用 LFU 算法在所有数据中进行筛选删除。\n\n# c) 不处理：\n\n# 3.3.8 noeviction\n\n不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) OOM command not allowed when used memory"，此时Redis只响应读操作。\n\n\n# 3.4 LFU、LRU数据淘汰策略\n\n# 3.4.1 LRU\n\nLRU 算法(Least Recently Used，最近最少使用)\n\n淘汰很久没被访问过的数据，以最近一次访问时间作为参考。\n\n# 3.4.2 LFU\n\nLFU 算法(Least Frequently Used，最不经常使用)\n\n淘汰最近一段时间被访问次数最少的数据，以次数作为参考。\n\n# 3.4.3 配置建议\n\n当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。\n\n\n# 4、Redis最大内存配置\n\n一般推荐Redis设置最大内存maxmemory为最大物理内存的四分之三。\n\n\n\n如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交 换 (swap)，会让 Redis 的性能急剧下降。\n\n当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。\n\n\n# 5、Redis怎么做持久化的？\n\nRedis支持持久化，而且支持两种不同的持久化操作。\n\nRedis的一种持久化方式叫快照(snapshotting，RDB)。\n\n另一种方式是只追加文件(append-only file,AOF)。\n\n\n# 5.1 RDB持久化(快照持久化)\n\nRDB持久化是将内存中的数据以快照的方式写进二进制文件中，默认的文件名为：dump.rdb。\n\n快照持久化是Redis默认采用的持久化方式。\n\n# 5.1.1 RDB持久化是怎么触发的？\n\nRDB支持3种触发方式：save，bgsave，自动化。\n\n# 5.1.1.1 save触发方式\n\n该命令会阻塞redis服务器，命令执行期间redis不能执行其他命令，直到RDB过程结束。\n\n\n\n# 5.1.1.2 bgsave触发方式\n\n该命令不会阻塞redis服务器，命令执行期间redis还可以响应客户端需求。\n\n具体过程是redis进程执行fork操作创建一个子进程，RDB持久化过程由该子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短**。Redis内部所有RDB操作基本上都是用bgsave命令。**\n\n\n\n# 5.1.1.3 自动触发方式\n\n自动触发是由我们配置文件来完成的。在redis.conf配置文件中默认有此下配置:\n\nsave 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\nsave 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。\n\n# 5.1.2 RDB有什么优势和劣势？\n\n# 5.1.2.1 RDB优势\n\n1）RDB文件紧凑，全量备份，非常适合数据备份和灾难恢复。\n\n2）RDB过程可通过子线程进行，不影响redis主线程。\n\n3）恢复大数据集时，恢复速度比AOF恢复速度快。\n\n# 5.1.2.1 RDB劣势\n\n快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n\n# 5.2 AOF持久化(append-only file)\n\nAOF的工作机制很简单，就是redis把每一个收到的写命令都追加保存到AOF文件中。\n\n与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。\n\n默认情况下Redis没有开启。\n\nAOF(append only file)方式的持久化，可以通过appendonly参数开启: appendonly yes\n\n# 5.2.1 AOF的持久化是怎么触发的？\n\n在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是:\n\n# 5.2.1.1 appendfsync always\n\n每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度。\n\n# 5.2.1.2 appendfsync everysec\n\n异步操作，每秒钟同步一次数据到硬盘，如果1秒内宕机，有数据丢失。\n\n# 5.2.1.3 appendfsync no\n\n让操作系统决定何时进行同步。\n\n# 5.2.2 AOF持久化3种触发方式的对比？\n\n\n\n# 5.2.3 AOF方式什么时候会出现文件重写？\n\n由于AOF方式会记录所有的写命令，对于同一份数据来说，AOF日志文件要比RDB快照文件更大。随着持久化文件越来越大，redis会fork出子线程来将文件进行重写。\n\n\n\n重写AOF文件不会读取旧文件，而是将内存中的数据内容用命令的方式重写一个新的AOF文件。\n\n# 5.2.4 AOF有什么优势和劣势？\n\n# 5.2.4.1 AOF优势\n\n1）AOF可以更好地保护数据不丢失，一般设置每隔1秒同步一次数据，所以最多丢失1秒的数据。\n\n2）AOF日志文件每次写入数据都是追加，写入性能很高。\n\n3）AOF可以后台操作，不影响客户端读写。\n\n4）AOF非常适合针对误删等情况进行数据恢复。比如有人不小心执行了flushall命令清空了数据，可以通过删除AOF文件中最后一条flushall命令，再将AOF文件放回去，执行恢复操作，恢复所有数据。\n\n# 5.2.4.2 AOF劣势\n\n1）针对同一份数据，AOF日志文件通常比RDB快照文件大。\n\n\n# 5.3 混合持久化\n\nRDB和AOF的特点：\n\n\n\nRedis 4.0 带来了一个新的持久化选项——混合持久化。\n\n重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。\n\n通过如下配置可以开启混合持久化(必须先开启aof):\n\n#aof‐use‐rdb‐preambleyes\n\n\n\nAOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，重写完新的AOF文件覆盖原有的AOF文件，完成新旧两个AOF文件的替换。\n\n\n# 5.4 数据怎么恢复？\n\n例：\n\n\n\n\n# 6、缓存雪崩｜缓存击穿｜缓存穿透\n\n\n# 6.1 缓存雪崩\n\n# 6.1.1 什么是缓存雪崩？\n\n缓存同一时间大面积失效，后面请求全部落到数据库，造成数据库短时间内承受大量请求而崩掉。\n\n# 6.1.2 缓存雪崩有什么解决方案？\n\n事前：\n\n1）尽量保证整个redis集群高可用，发现机器宕机尽快补上。\n\n2）缓存失效时间可以在原来的基础上加多一个随机值，避免同一时间集体失效。\n\n事中：\n\n开启限流或者降级，避免Mysql崩掉。\n\n事后：\n\n利用redis持久化机制保存的数据尽快恢复缓存。\n\n\n# 6.2 缓存击穿\n\n# 6.2.1 什么是缓存击穿？\n\nKey对应的数据存在，但是在redis未缓存或者已经过期，此时大量请求过来，由于redis中不存在，需要去数据库查询之后再回写redis缓存，造成大量请求直接打在数据库上，很容易把数据库压垮。\n\n# 6.2.2 缓存击穿有什么解决方案？\n\n1）定时任务主动刷新缓存。\n\n2）通过加锁的方式解决，用普通jvm的锁就可以。\n\n查缓存时能命中则直接返回，不能命中则需要获取锁才能进行下一步访问数据库等操作。\n\n\n\n\n# 6.3 缓存穿透\n\n# 6.3.1 什么是缓存穿透？\n\nKey对应的数据不存在，一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。\n\n# 6.3.2 缓存穿透有什么解决方案？\n\n1）最简单粗暴的办法，如果一个查询返回的数据为空（不管数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n\n2）采用布隆过滤器，将有值的key存放到布隆过滤器中，则没有值的key必然会被过滤掉。\n\n\n# 7、Redis集群\n\n\n# 7.1 主从复制\n\n# 7.1.1 全量复制\n\n\n\n1.如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个PSYNC命令给master请求复制数据。\n\n2.master收到PSYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。\n\n3.持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。\n\n4.当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。\n\n5.然后，master再将之前缓存在内存中的命令发送给slave。\n\n6.当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。\n\n# 7.1.2 部分复制、断点续传\n\n\n\n1.master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据。\n\n2.master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。\n\n3.如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。\n\n# 7.1.3 主从复制风暴\n\n如果有很多从节点，为了缓解主从复制风暴(多个从节点同时复制主节点导致主节点压力过大)，可以做如 下架构，让部分从节点与从节点(与主节点同步)同步数据。\n\n\n\n\n# 7.2 哨兵模式\n\n\n\n1.sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。\n\n2.哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端。\n\n缺点：\n\n1.哨兵的配置较复杂。\n\n2.主从切换的瞬间存在访问瞬断的情况。\n\n3.哨兵模式只有一个主节点对外提供服务，没法支持很高并发。且单个主节点内存不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。\n\n\n# 7.3 高可用集群模式\n\n\n\n集群模式没有中心节点，可水平扩展，可以线性扩展到上万个节点(官方推荐不超过1000个节点)。\n\nRedis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。\n\n槽位定位算法\n\nCluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。\n\nHASH_SLOT = CRC16(key) mod 16384\n\n\n# 7.4 Redis集群节点间的通信机制\n\n集中式:\n\n优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到;不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助zookeeper集中式存储元数据。\n\nRedis集群节点间采用gossip协议进行通信。\n\n\n\ngossip协议包括多种消息，包括ping，pong，meet，fail等等。\n\n优点：\n\n元数据更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定延时，降低了压力。\n\n缺点：\n\n元数据更新有延时可能导致集群的一些操作会有一些滞后。\n\n\n\n\n\n\n# 7.5 Redis集群选举\n\n# 7.5.1 选举流程\n\n当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master 可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下:\n\n1.slave发现自己的master变为FAIL。\n\n2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息。\n\n3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个 epoch只发送一次ack。\n\n4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK。\n\n5.slave收到超过半数master的ack后变成新Master。\n\n(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)\n\n6.slave广播Pong消息通知其他集群节点。\n\n从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待 FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票。\n\n延迟计算公式:\n\nDELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms\n\nSLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举(理论上)。\n\n# 7.5.2 集群脑裂问题\n\nRedis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。\n\n# 7.5.3 Redis集群为什么至少要三个master节点，并且推荐奇数？\n\n选举新master需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，挂了一个，就达不到过半数选举的条件。\n\n奇数个master节点可以在满足选举条件的基础上节省一个节点。比如三个master跟四个master，大家挂了一个都可以选举新master，挂了两个都不可以选举新master。所以奇数的master节点更多的是从节省机器资源角度出发说的。\n\n\n# 7.2 Redis集群下可以执行批量操作命令吗？\n\nRedis集群是没法执行批量操作命令的，如mget，pipeline等。这是因为redis将集群划分为16383个哈希槽，不同的key会划分到不同的槽中。\n\n但是，Jedis客户端提供了计算key的slot方法，以及slot和节点之间的映射关系，通过这两个数据，就可以计算出每个key所在的节点，然后使用pipeline获取数据。\n\n\n# 7.3 Redis集群支持多数据库吗？\n\nRedis集群是不支持多数据库的，只有一个数据库空间，默认 SELECT 0，即db0。\n\n\n# 7.4 Redis集群不足的地方？\n\n1.集群模式下做批量操作比较麻烦，需要自己计算处理。\n\n2.假如有一个key，对应的value是hash类型的，不支持映射到集群的不同节点。\n\n\n# 7.5 Redis集群方案什么情况下会导致集群不可用？\n\n当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主节点下线且没有相应的从节点进行故障恢复时，集群仍然可用，如果为yes则集群不可用。\n\n\n# 8、Redis基础\n\n\n# 8.1 Redis是单线程的吗？\n\nRedis 的单线程主要是指 Redis 的网络 IO（即一个线程处理所有网络请求） 和键值对读写是由一个线程来完成的，这也是 Redis 对外 提供键值存储服务的主要流程。但 Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。\n\n\n# 8.2 Redis单线程为什么还能这么快？\n\n因为Redis所有数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。\n\n正因为Redis是单线程的，所有要小心使用Redis指令，对于那些耗时的指令（比如keys），一定要谨慎使用，一不小心就可能会导致Redis卡顿。\n\n\n# 8.3 Redis单线程如何处理那么多的并发客户端连接？\n\n核心是利用epoll来使用IO多路复用。\n\nRedis基于Reactor模式开发了自己的网络事件处理器，称之为文件事件处理器。文件事件处理器由Socket、IO多路复用程序、文件事件分派器、事件处理器四部分组成。\n\n\n\nIO多路复用程序会把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。\n\nReactor模式\n\n\n\nReactor模式：基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。\n从结构上，这有点类似生产者消费者模式，即有一个或多个生产者将事件放入一个Queue中，而一个或多个消费者主动的从这个Queue中Poll事件来处理；\n而Reactor模式则并没有Queue来做缓冲，每当一个Event输入到Service Handler之后，\n该Service Handler会主动的根据不同的Event类型将其分发给对应的Request Handler来处理。\n\n\n# 8.4 Redis支持哪些数据类型？\n\nRedis主要支持5种数据类型，分别是：\n\nstring（字符串），hash（哈希），list（列表），set（集合），zset（有序集合）\n\nstring:\n\nstring类型是redis最基本的数据类型，一个键最大能存储512M\n\n示例：增加：set name "testname" 查看：get name\n\nhash:\n\nhash是一个string类型的field和value的映射表。hash特别适合存储对象。\n\n示例：增加：hset myhash myfield1 "hello" myfield2 "world" 查看：hget myhash myfield2\n\nlist:\n\nlist是简单的字符串列表。可以从队头或者队尾插入元素。\n\n示例：增加：lpush mytestlist value1 value2 查看：lrange mytestlist 0 10\n\nset:\n\nset是string类型的无序集合，集合成员是唯一的。\n\n示例：增加：sadd mytestset value1 查看：smembers mytestset\n\nzset:\n\nzset是一个有序的set集合，每个元素会关联一个double型的分数，分数可以重复。\n\n示例：增加：zadd mytestzset 1 value1 查看：zrange mytestzset 0 10 withscores\n\n\n# 8.5 Redis的单点吞吐量？\n\n单点TPS达8万/秒，QPS达10万/秒。\n\n\n# 8.6 其他高级命令\n\nkeys:全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用。\n\n\n# 9、Redisson\n\n\n# 9.1 使用例子\n\nredission支持4种连接redis方式，分别为单机、主从、Sentinel、Cluster 集群。项目中使用的是集群模式。\n\n\n\n\n\n\n\n\n# 9.2 分布式锁演变过程\n\n# 9.2.1 SETNX\n\n\n\n存在问题：\n\n1）客户端所在节点奔溃，无法正确释放锁。\n\n2）业务逻辑异常，无法释放锁。\n\n# 9.2.2 超时设置\n\n设置超时时间，到点锁自动释放。\n\nSETNX lock:168 1 // 获取锁(integer) 1>\n\nEXPIRE lock:168 60 // 60s 自动删除(integer) 1\n\n存在问题：\n\n1）「加锁」、「设置超时」是两个命令，不是原子操作。可能出现只执行了第一条命令，第二条没执行成功的情况。\n\n解决方案：\n\nRedis 2.6.x之后，官方拓展了SET命令的参数，支持设置超时时间，并且满足原子性。\n\nset key_name random_value nx px 30000\n\nnx 表示只有key_name不存在才能设值成功。\n\npx 30000 表示30秒后自动过期。\n\n# 9.2.3 只能释放自己的锁\n\n存在问题：\n\n自己的锁可能被别人释放。\n\n比如：\n\n1.线程1获取锁成功并设置30秒后超时。\n\n2.线程1由于某些原因执行很慢（网络问题、fullGC问题等...），超过30秒还没执行完，此时Redis因为锁过期自动释放了锁。\n\n3.线程2获取锁执行自己业务。\n\n4.线程1执行完自己业务释放锁，结果此时释放成线程2的锁。\n\n解决方案：\n\n加锁的时候设置一个「唯一标识」作为value，释放锁的时候用自己的唯一标识和value作比较，匹配上才能释放锁。\n\n加锁：\n\nset key_name random_value nx px 30000\n\n释放锁：\n\nif (redis.get("key_name").equals(random_value)) {\n\n//比对成功则删除\n\nredis.del("key_name");\n\n}\n\n**问题：**释放锁时这种写法存在一个问题，get和del是两个操作，存在原子性问题。\n\n可以通过Lua脚本实现原子性：\n\n// 获取锁的 value 与 ARGV[1] 是否匹配，匹配则执行\n\ndelif redis.call("get",KEYS[1]) == ARGV[1]\n\nthen return redis.call("del",KEYS[1])\n\nelse return 0\n\nend\n\n# 9.2.4 正确设置锁超时\n\n超时时间的设置一般为：通过多轮压测，取平均时间的3 ~ 5倍。\n\n但即使这样仍然可能出现问题，可以通过以下方式完善超时时间设置：\n\n给获取锁的线程添加一个守护线程，该守护线程定期检测锁的失效时间，如果锁快要失效，但是业务还没执行完，就对这个锁进行续期，重新设置超时时间。\n\n# 9.2.5 实现可重入锁\n\n\n\n通过redis hash结构实现可重入锁。\n\n加锁：\n\n1.加锁时先使用redis exists判断key_name这个锁是否存在。\n\n2.如果锁不存在，使用hincrby创建一个key_name的hash表，random_value对应的value_count初始化为0再加1。\n\n3.如果key_name存在，用hexists判断random_value这个键存不存在，如果random_value存在，value_count使用hincrby加1，否则加锁失败。\n\n解锁：\n\n1.不存在key_name或不存在random_value，解锁失败。\n\n2.存在指定random_value，则使用hincrby减1，当value_count小于等于0，使用del删除这把锁。释放锁成功。\n\n\n# 9.3 Redis分布式锁存在什么缺点？\n\n由于redis集群同步数据的方式是异步，假设master节点获取到锁之后未完成数据同步就挂了，这个时候在新的master节点依然可以获取锁，所以多个客户端会同时获取到锁。',normalizedContent:'# redis\n\n\n# 1、什么是位图？\n\n一个由1亿个数组成的集合m，范围从1~10亿。新来一个数n，如何快速且地判断是否存在m中？\n\n申请一个大小为10亿，数据类型为布尔的“特殊”散列表，将这一亿个数作为散列表下标，将值设成true。\n\n\n\n不过很多语言的布尔大小是1字节，并不能节省很大空间，实际上只需要使用1个二进制位，来表示true和false两个值就行了。\n\n这就要用到位运算了，借助编程语言提供的数据类型，比如int，char等，通过位运算，用其中的某个位表示某个数字。 这就是位图。\n\n\n\n消耗大小：约120m。\n\n操作平台拦截件使用了位图实现！\n\n\n# 2、什么是布隆过滤器？\n\n位图有个问题，想想看，如果数的范围是1到100亿呢，那位图消耗的大小就是1.2g了！！，相对于散列表，不降反升。 这个时候，布隆过滤器登场了，它其实是对位图一种改进。\n\n * 针对数据范围是1到100亿的集合，还是申请10亿的二进制大小的位图（消耗内存120m）\n * 使用多个哈希函数，得到k个不同的哈希值，记为 x1,x2,x3...xk。将k个数字作为位图中的下标，将对应的值设为1\n\n\n\n * 适当选择k个哈希函数，k个哈希值都相同的概率就非常低了，但又会带来新的问题，那就是误判\n\n\n\n * 布隆过滤器的误判有个特点：\n\n没有就是没有，有就有极低的可能会没有。\n\n\n# 3、redis怎么进行过期删除？\n\n我们set key的时候，都可以给一个expire time，就是过期时间，通过过期时间我们可以指定这个key可以存活的时间。\n\n如果假设你设置了一批key只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的?\n\n定期删除+惰性删除。\n\n\n# 3.1 定期删除\n\nredis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢?你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所 有的设置过期时间的 key 的话，就会给 cpu 带来很大的负载!\n\n\n# 3.2 惰性删除\n\n定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈!\n\n但是仅仅通过设置过期时间还是有问题的。我们想一下:如果定期删除漏掉了很多过期 key，然后你也没及时去查， 也就没走惰性删除，此时会怎么样?如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢? -- redis内存淘汰机制。\n\n\n# 3.3 主动清理策略\n\n根据自身业务类型，配置好maxmemory-policy(默认是noeviction)，\n\n推荐使用volatile-lru。\n\n主动清理策略在redis4.0之前一共实现了6种内存淘汰策略，在4.0之后，又增加了2种策略，总共8种策略：\n\n# a) 针对设置了过期时间的key做处理：\n\n# 3.3.1 volatile-ttl\n\n在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。\n\n# 3.3.2 volatile-random\n\n就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。\n\n# 3.3.3 volatile-lru\n\n会使用 lru 算法筛选设置了过期时间的键值对删除。\n\n# 3.3.4 volatile-lfu\n\n会使用 lfu 算法筛选设置了过期时间的键值对删除。\n\n# b) 针对所有的key做处理：\n\n# 3.3.5 allkeys-random\n\n从所有键值对中随机选择并删除数据。\n\n# 3.3.6 allkeys-lru\n\n使用 lru 算法在所有数据中进行筛选删除。\n\n# 3.3.7 allkeys-lfu\n\n使用 lfu 算法在所有数据中进行筛选删除。\n\n# c) 不处理：\n\n# 3.3.8 noeviction\n\n不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息"(error) oom command not allowed when used memory"，此时redis只响应读操作。\n\n\n# 3.4 lfu、lru数据淘汰策略\n\n# 3.4.1 lru\n\nlru 算法(least recently used，最近最少使用)\n\n淘汰很久没被访问过的数据，以最近一次访问时间作为参考。\n\n# 3.4.2 lfu\n\nlfu 算法(least frequently used，最不经常使用)\n\n淘汰最近一段时间被访问次数最少的数据，以次数作为参考。\n\n# 3.4.3 配置建议\n\n当存在热点数据时，lru的效率很好，但偶发性的、周期性的批量操作会导致lru命中率急剧下降，缓存污染情况比较严重。这时使用lfu可能更好点。\n\n\n# 4、redis最大内存配置\n\n一般推荐redis设置最大内存maxmemory为最大物理内存的四分之三。\n\n\n\n如果不设置最大内存，当 redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交 换 (swap)，会让 redis 的性能急剧下降。\n\n当redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。\n\n\n# 5、redis怎么做持久化的？\n\nredis支持持久化，而且支持两种不同的持久化操作。\n\nredis的一种持久化方式叫快照(snapshotting，rdb)。\n\n另一种方式是只追加文件(append-only file,aof)。\n\n\n# 5.1 rdb持久化(快照持久化)\n\nrdb持久化是将内存中的数据以快照的方式写进二进制文件中，默认的文件名为：dump.rdb。\n\n快照持久化是redis默认采用的持久化方式。\n\n# 5.1.1 rdb持久化是怎么触发的？\n\nrdb支持3种触发方式：save，bgsave，自动化。\n\n# 5.1.1.1 save触发方式\n\n该命令会阻塞redis服务器，命令执行期间redis不能执行其他命令，直到rdb过程结束。\n\n\n\n# 5.1.1.2 bgsave触发方式\n\n该命令不会阻塞redis服务器，命令执行期间redis还可以响应客户端需求。\n\n具体过程是redis进程执行fork操作创建一个子进程，rdb持久化过程由该子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短**。redis内部所有rdb操作基本上都是用bgsave命令。**\n\n\n\n# 5.1.1.3 自动触发方式\n\n自动触发是由我们配置文件来完成的。在redis.conf配置文件中默认有此下配置:\n\nsave 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，redis就会自动触发bgsave命令创建快照。\n\nsave 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，redis就会自动触发bgsave命令创建快照。\n\nsave 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，redis就会自动触发bgsave命令创建快照。\n\n# 5.1.2 rdb有什么优势和劣势？\n\n# 5.1.2.1 rdb优势\n\n1）rdb文件紧凑，全量备份，非常适合数据备份和灾难恢复。\n\n2）rdb过程可通过子线程进行，不影响redis主线程。\n\n3）恢复大数据集时，恢复速度比aof恢复速度快。\n\n# 5.1.2.1 rdb劣势\n\n快照持久化期间修改的数据不会被保存，可能丢失数据。\n\n\n# 5.2 aof持久化(append-only file)\n\naof的工作机制很简单，就是redis把每一个收到的写命令都追加保存到aof文件中。\n\n与快照持久化相比，aof持久化 的实时性更好，因此已成为主流的持久化方案。\n\n默认情况下redis没有开启。\n\naof(append only file)方式的持久化，可以通过appendonly参数开启: appendonly yes\n\n# 5.2.1 aof的持久化是怎么触发的？\n\n在redis的配置文件中存在三种不同的 aof 持久化方式，它们分别是:\n\n# 5.2.1.1 appendfsync always\n\n每次有数据修改发生时都会写入aof文件,这样会严重降低redis的速度。\n\n# 5.2.1.2 appendfsync everysec\n\n异步操作，每秒钟同步一次数据到硬盘，如果1秒内宕机，有数据丢失。\n\n# 5.2.1.3 appendfsync no\n\n让操作系统决定何时进行同步。\n\n# 5.2.2 aof持久化3种触发方式的对比？\n\n\n\n# 5.2.3 aof方式什么时候会出现文件重写？\n\n由于aof方式会记录所有的写命令，对于同一份数据来说，aof日志文件要比rdb快照文件更大。随着持久化文件越来越大，redis会fork出子线程来将文件进行重写。\n\n\n\n重写aof文件不会读取旧文件，而是将内存中的数据内容用命令的方式重写一个新的aof文件。\n\n# 5.2.4 aof有什么优势和劣势？\n\n# 5.2.4.1 aof优势\n\n1）aof可以更好地保护数据不丢失，一般设置每隔1秒同步一次数据，所以最多丢失1秒的数据。\n\n2）aof日志文件每次写入数据都是追加，写入性能很高。\n\n3）aof可以后台操作，不影响客户端读写。\n\n4）aof非常适合针对误删等情况进行数据恢复。比如有人不小心执行了flushall命令清空了数据，可以通过删除aof文件中最后一条flushall命令，再将aof文件放回去，执行恢复操作，恢复所有数据。\n\n# 5.2.4.2 aof劣势\n\n1）针对同一份数据，aof日志文件通常比rdb快照文件大。\n\n\n# 5.3 混合持久化\n\nrdb和aof的特点：\n\n\n\nredis 4.0 带来了一个新的持久化选项——混合持久化。\n\n重启 redis 时，我们很少使用 rdb来恢复内存状态，因为会丢失大量数据。我们通常使用 aof 日志重放，但是重放 aof 日志性能相对 rdb来说要慢很多，这样在 redis 实例很大的情况下，启动需要花费很长的时间。\n\n通过如下配置可以开启混合持久化(必须先开启aof):\n\n#aof‐use‐rdb‐preambleyes\n\n\n\naof在重写时，不再是单纯将内存数据转换为resp命令写入aof文件，而是将重写这一刻之前的内存做rdb快照处理，并且将rdb快照内容和增量的aof修改内存数据的命令存在一起，都写入新的aof文件，重写完新的aof文件覆盖原有的aof文件，完成新旧两个aof文件的替换。\n\n\n# 5.4 数据怎么恢复？\n\n例：\n\n\n\n\n# 6、缓存雪崩｜缓存击穿｜缓存穿透\n\n\n# 6.1 缓存雪崩\n\n# 6.1.1 什么是缓存雪崩？\n\n缓存同一时间大面积失效，后面请求全部落到数据库，造成数据库短时间内承受大量请求而崩掉。\n\n# 6.1.2 缓存雪崩有什么解决方案？\n\n事前：\n\n1）尽量保证整个redis集群高可用，发现机器宕机尽快补上。\n\n2）缓存失效时间可以在原来的基础上加多一个随机值，避免同一时间集体失效。\n\n事中：\n\n开启限流或者降级，避免mysql崩掉。\n\n事后：\n\n利用redis持久化机制保存的数据尽快恢复缓存。\n\n\n# 6.2 缓存击穿\n\n# 6.2.1 什么是缓存击穿？\n\nkey对应的数据存在，但是在redis未缓存或者已经过期，此时大量请求过来，由于redis中不存在，需要去数据库查询之后再回写redis缓存，造成大量请求直接打在数据库上，很容易把数据库压垮。\n\n# 6.2.2 缓存击穿有什么解决方案？\n\n1）定时任务主动刷新缓存。\n\n2）通过加锁的方式解决，用普通jvm的锁就可以。\n\n查缓存时能命中则直接返回，不能命中则需要获取锁才能进行下一步访问数据库等操作。\n\n\n\n\n# 6.3 缓存穿透\n\n# 6.3.1 什么是缓存穿透？\n\nkey对应的数据不存在，一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。\n\n# 6.3.2 缓存穿透有什么解决方案？\n\n1）最简单粗暴的办法，如果一个查询返回的数据为空（不管数据不存在，还是系统故障），仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。\n\n2）采用布隆过滤器，将有值的key存放到布隆过滤器中，则没有值的key必然会被过滤掉。\n\n\n# 7、redis集群\n\n\n# 7.1 主从复制\n\n# 7.1.1 全量复制\n\n\n\n1.如果你为master配置了一个slave，不管这个slave是否是第一次连接上master，它都会发送一个psync命令给master请求复制数据。\n\n2.master收到psync命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件。\n\n3.持久化期间，master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。\n\n4.当持久化进行完毕以后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加载到内存中。\n\n5.然后，master再将之前缓存在内存中的命令发送给slave。\n\n6.当master与slave之间的连接由于某些原因而断开时，slave能够自动重连master，如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送给多个并发连接的slave。\n\n# 7.1.2 部分复制、断点续传\n\n\n\n1.master会在其内存中创建一个复制数据用的缓存队列，缓存最近一段时间的数据。\n\n2.master和它所有的slave都维护了复制的数据下标offset和master的进程id，因此，当网络连接断开后，slave会请求master继续进行未完成的复制，从所记录的数据下标开始。\n\n3.如果master进程id变化了，或者从节点数据下标offset太旧，已经不在master的缓存队列里了，那么将会进行一次全量数据的复制。\n\n# 7.1.3 主从复制风暴\n\n如果有很多从节点，为了缓解主从复制风暴(多个从节点同时复制主节点导致主节点压力过大)，可以做如 下架构，让部分从节点与从节点(与主节点同步)同步数据。\n\n\n\n\n# 7.2 哨兵模式\n\n\n\n1.sentinel哨兵是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。\n\n2.哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis主节点通知给client端。\n\n缺点：\n\n1.哨兵的配置较复杂。\n\n2.主从切换的瞬间存在访问瞬断的情况。\n\n3.哨兵模式只有一个主节点对外提供服务，没法支持很高并发。且单个主节点内存不宜设置得过大，否则会导致持久化文件过大，影响数据恢复或主从同步的效率。\n\n\n# 7.3 高可用集群模式\n\n\n\n集群模式没有中心节点，可水平扩展，可以线性扩展到上万个节点(官方推荐不超过1000个节点)。\n\nredis cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。\n\n槽位定位算法\n\ncluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位。\n\nhash_slot = crc16(key) mod 16384\n\n\n# 7.4 redis集群节点间的通信机制\n\n集中式:\n\n优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到;不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助zookeeper集中式存储元数据。\n\nredis集群节点间采用gossip协议进行通信。\n\n\n\ngossip协议包括多种消息，包括ping，pong，meet，fail等等。\n\n优点：\n\n元数据更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定延时，降低了压力。\n\n缺点：\n\n元数据更新有延时可能导致集群的一些操作会有一些滞后。\n\n\n\n\n\n\n# 7.5 redis集群选举\n\n# 7.5.1 选举流程\n\n当slave发现自己的master变为fail状态时，便尝试进行failover，以期成为新的master。由于挂掉的master 可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下:\n\n1.slave发现自己的master变为fail。\n\n2.将自己记录的集群currentepoch加1，并广播failover_auth_request信息。\n\n3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送failover_auth_ack，对每一个 epoch只发送一次ack。\n\n4.尝试failover的slave收集master返回的failover_auth_ack。\n\n5.slave收到超过半数master的ack后变成新master。\n\n(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)\n\n6.slave广播pong消息通知其他集群节点。\n\n从节点并不是在主节点一进入 fail 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待 fail状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到fail状态，可能会拒绝投票。\n\n延迟计算公式:\n\ndelay = 500ms + random(0 ~ 500ms) + slave_rank * 1000ms\n\nslave_rank表示此slave已经从master复制数据的总量的rank。rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举(理论上)。\n\n# 7.5.2 集群脑裂问题\n\nredis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。\n\n# 7.5.3 redis集群为什么至少要三个master节点，并且推荐奇数？\n\n选举新master需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，挂了一个，就达不到过半数选举的条件。\n\n奇数个master节点可以在满足选举条件的基础上节省一个节点。比如三个master跟四个master，大家挂了一个都可以选举新master，挂了两个都不可以选举新master。所以奇数的master节点更多的是从节省机器资源角度出发说的。\n\n\n# 7.2 redis集群下可以执行批量操作命令吗？\n\nredis集群是没法执行批量操作命令的，如mget，pipeline等。这是因为redis将集群划分为16383个哈希槽，不同的key会划分到不同的槽中。\n\n但是，jedis客户端提供了计算key的slot方法，以及slot和节点之间的映射关系，通过这两个数据，就可以计算出每个key所在的节点，然后使用pipeline获取数据。\n\n\n# 7.3 redis集群支持多数据库吗？\n\nredis集群是不支持多数据库的，只有一个数据库空间，默认 select 0，即db0。\n\n\n# 7.4 redis集群不足的地方？\n\n1.集群模式下做批量操作比较麻烦，需要自己计算处理。\n\n2.假如有一个key，对应的value是hash类型的，不支持映射到集群的不同节点。\n\n\n# 7.5 redis集群方案什么情况下会导致集群不可用？\n\n当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主节点下线且没有相应的从节点进行故障恢复时，集群仍然可用，如果为yes则集群不可用。\n\n\n# 8、redis基础\n\n\n# 8.1 redis是单线程的吗？\n\nredis 的单线程主要是指 redis 的网络 io（即一个线程处理所有网络请求） 和键值对读写是由一个线程来完成的，这也是 redis 对外 提供键值存储服务的主要流程。但 redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。\n\n\n# 8.2 redis单线程为什么还能这么快？\n\n因为redis所有数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。\n\n正因为redis是单线程的，所有要小心使用redis指令，对于那些耗时的指令（比如keys），一定要谨慎使用，一不小心就可能会导致redis卡顿。\n\n\n# 8.3 redis单线程如何处理那么多的并发客户端连接？\n\n核心是利用epoll来使用io多路复用。\n\nredis基于reactor模式开发了自己的网络事件处理器，称之为文件事件处理器。文件事件处理器由socket、io多路复用程序、文件事件分派器、事件处理器四部分组成。\n\n\n\nio多路复用程序会把所有产生事件的socket压入一个队列中，然后有序地每次仅一个socket的方式传送给文件事件分派器，文件事件分派器接收到socket之后会根据socket产生的事件类型调用对应的事件处理器进行处理。\n\nreactor模式\n\n\n\nreactor模式：基于事件驱动的设计，当有事件触发时，才会调用处理器进行数据处理。\n从结构上，这有点类似生产者消费者模式，即有一个或多个生产者将事件放入一个queue中，而一个或多个消费者主动的从这个queue中poll事件来处理；\n而reactor模式则并没有queue来做缓冲，每当一个event输入到service handler之后，\n该service handler会主动的根据不同的event类型将其分发给对应的request handler来处理。\n\n\n# 8.4 redis支持哪些数据类型？\n\nredis主要支持5种数据类型，分别是：\n\nstring（字符串），hash（哈希），list（列表），set（集合），zset（有序集合）\n\nstring:\n\nstring类型是redis最基本的数据类型，一个键最大能存储512m\n\n示例：增加：set name "testname" 查看：get name\n\nhash:\n\nhash是一个string类型的field和value的映射表。hash特别适合存储对象。\n\n示例：增加：hset myhash myfield1 "hello" myfield2 "world" 查看：hget myhash myfield2\n\nlist:\n\nlist是简单的字符串列表。可以从队头或者队尾插入元素。\n\n示例：增加：lpush mytestlist value1 value2 查看：lrange mytestlist 0 10\n\nset:\n\nset是string类型的无序集合，集合成员是唯一的。\n\n示例：增加：sadd mytestset value1 查看：smembers mytestset\n\nzset:\n\nzset是一个有序的set集合，每个元素会关联一个double型的分数，分数可以重复。\n\n示例：增加：zadd mytestzset 1 value1 查看：zrange mytestzset 0 10 withscores\n\n\n# 8.5 redis的单点吞吐量？\n\n单点tps达8万/秒，qps达10万/秒。\n\n\n# 8.6 其他高级命令\n\nkeys:全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用。\n\n\n# 9、redisson\n\n\n# 9.1 使用例子\n\nredission支持4种连接redis方式，分别为单机、主从、sentinel、cluster 集群。项目中使用的是集群模式。\n\n\n\n\n\n\n\n\n# 9.2 分布式锁演变过程\n\n# 9.2.1 setnx\n\n\n\n存在问题：\n\n1）客户端所在节点奔溃，无法正确释放锁。\n\n2）业务逻辑异常，无法释放锁。\n\n# 9.2.2 超时设置\n\n设置超时时间，到点锁自动释放。\n\nsetnx lock:168 1 // 获取锁(integer) 1>\n\nexpire lock:168 60 // 60s 自动删除(integer) 1\n\n存在问题：\n\n1）「加锁」、「设置超时」是两个命令，不是原子操作。可能出现只执行了第一条命令，第二条没执行成功的情况。\n\n解决方案：\n\nredis 2.6.x之后，官方拓展了set命令的参数，支持设置超时时间，并且满足原子性。\n\nset key_name random_value nx px 30000\n\nnx 表示只有key_name不存在才能设值成功。\n\npx 30000 表示30秒后自动过期。\n\n# 9.2.3 只能释放自己的锁\n\n存在问题：\n\n自己的锁可能被别人释放。\n\n比如：\n\n1.线程1获取锁成功并设置30秒后超时。\n\n2.线程1由于某些原因执行很慢（网络问题、fullgc问题等...），超过30秒还没执行完，此时redis因为锁过期自动释放了锁。\n\n3.线程2获取锁执行自己业务。\n\n4.线程1执行完自己业务释放锁，结果此时释放成线程2的锁。\n\n解决方案：\n\n加锁的时候设置一个「唯一标识」作为value，释放锁的时候用自己的唯一标识和value作比较，匹配上才能释放锁。\n\n加锁：\n\nset key_name random_value nx px 30000\n\n释放锁：\n\nif (redis.get("key_name").equals(random_value)) {\n\n//比对成功则删除\n\nredis.del("key_name");\n\n}\n\n**问题：**释放锁时这种写法存在一个问题，get和del是两个操作，存在原子性问题。\n\n可以通过lua脚本实现原子性：\n\n// 获取锁的 value 与 argv[1] 是否匹配，匹配则执行\n\ndelif redis.call("get",keys[1]) == argv[1]\n\nthen return redis.call("del",keys[1])\n\nelse return 0\n\nend\n\n# 9.2.4 正确设置锁超时\n\n超时时间的设置一般为：通过多轮压测，取平均时间的3 ~ 5倍。\n\n但即使这样仍然可能出现问题，可以通过以下方式完善超时时间设置：\n\n给获取锁的线程添加一个守护线程，该守护线程定期检测锁的失效时间，如果锁快要失效，但是业务还没执行完，就对这个锁进行续期，重新设置超时时间。\n\n# 9.2.5 实现可重入锁\n\n\n\n通过redis hash结构实现可重入锁。\n\n加锁：\n\n1.加锁时先使用redis exists判断key_name这个锁是否存在。\n\n2.如果锁不存在，使用hincrby创建一个key_name的hash表，random_value对应的value_count初始化为0再加1。\n\n3.如果key_name存在，用hexists判断random_value这个键存不存在，如果random_value存在，value_count使用hincrby加1，否则加锁失败。\n\n解锁：\n\n1.不存在key_name或不存在random_value，解锁失败。\n\n2.存在指定random_value，则使用hincrby减1，当value_count小于等于0，使用del删除这把锁。释放锁成功。\n\n\n# 9.3 redis分布式锁存在什么缺点？\n\n由于redis集群同步数据的方式是异步，假设master节点获取到锁之后未完成数据同步就挂了，这个时候在新的master节点依然可以获取锁，所以多个客户端会同时获取到锁。',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3},{title:"spring",frontmatter:{title:"spring",date:"2022-04-28T18:15:14.000Z",permalink:"/pages/172a2f/",categories:["知识整理"],tags:["spring"],author:{name:"liuwenkai01"}},regularPath:"/%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/14.spring.html",relativePath:"知识整理/14.spring.md",key:"v-33098487",path:"/pages/172a2f/",headers:[{level:2,title:"1、SpringMVC",slug:"_1、springmvc",normalizedTitle:"1、springmvc",charIndex:13},{level:3,title:"1.1 什么是SpringMVC？简单说下你的理解？",slug:"_1-1-什么是springmvc-简单说下你的理解",normalizedTitle:"1.1 什么是springmvc？简单说下你的理解？",charIndex:29},{level:3,title:"1.2 讲下SpringMVC的执行流程？",slug:"_1-2-讲下springmvc的执行流程",normalizedTitle:"1.2 讲下springmvc的执行流程？",charIndex:168},{level:3,title:"1.3 SpringMVC怎么样设定重定向和转发的？",slug:"_1-3-springmvc怎么样设定重定向和转发的",normalizedTitle:"1.3 springmvc怎么样设定重定向和转发的？",charIndex:624},{level:3,title:"1.4 SpringMVC常用的注解有哪些？",slug:"_1-4-springmvc常用的注解有哪些",normalizedTitle:"1.4 springmvc常用的注解有哪些？",charIndex:774},{level:3,title:"1.5 SpingMvc中控制器的注解一般用哪个？",slug:"_1-5-spingmvc中控制器的注解一般用哪个",normalizedTitle:"1.5 spingmvc中控制器的注解一般用哪个？",charIndex:991},{level:3,title:"1.6 如何解决POST请求中文乱码问题，GET的又如何处理呢？",slug:"_1-6-如何解决post请求中文乱码问题-get的又如何处理呢",normalizedTitle:"1.6 如何解决post请求中文乱码问题，get的又如何处理呢？",charIndex:1134},{level:3,title:"1.7 SpringMvc控制器是不是单例？如果是，有什么问题？",slug:"_1-7-springmvc控制器是不是单例-如果是-有什么问题",normalizedTitle:"1.7 springmvc控制器是不是单例？如果是，有什么问题？",charIndex:1370},{level:3,title:"1.8 如果在拦截请求中，我想拦截get方式提交的方法，怎么配置？",slug:"_1-8-如果在拦截请求中-我想拦截get方式提交的方法-怎么配置",normalizedTitle:"1.8 如果在拦截请求中，我想拦截get方式提交的方法，怎么配置？",charIndex:1519},{level:3,title:"1.9 怎样在方法里面得到Request，或者Session？",slug:"_1-9-怎样在方法里面得到request-或者session",normalizedTitle:"1.9 怎样在方法里面得到request，或者session？",charIndex:1608},{level:2,title:"2、Spring",slug:"_2、spring",normalizedTitle:"2、spring",charIndex:1690},{level:3,title:"2.0 Spring常见问题",slug:"_2-0-spring常见问题",normalizedTitle:"2.0 spring常见问题",charIndex:1703},{level:4,title:"2.0.1 BeanFactory与FactoryBean的区别？",slug:"_2-0-1-beanfactory与factorybean的区别",normalizedTitle:"2.0.1 beanfactory与factorybean的区别？",charIndex:1721},{level:4,title:"2.0.2 BeanFactory与ApplicationContext的区别？",slug:"_2-0-2-beanfactory与applicationcontext的区别",normalizedTitle:"2.0.2 beanfactory与applicationcontext的区别？",charIndex:2054},{level:4,title:"2.0.3 Spring整合Mybatis后为什么会导致一级缓存失效？",slug:"_2-0-3-spring整合mybatis后为什么会导致一级缓存失效",normalizedTitle:"2.0.3 spring整合mybatis后为什么会导致一级缓存失效？",charIndex:2229},{level:3,title:"2.1 Bean的生成过程",slug:"_2-1-bean的生成过程",normalizedTitle:"2.1 bean的生成过程",charIndex:2516},{level:4,title:"2.1.1 生成BeanDefinition",slug:"_2-1-1-生成beandefinition",normalizedTitle:"2.1.1 生成beandefinition",charIndex:2533},{level:4,title:"2.1.2 合并BeanDefinition",slug:"_2-1-2-合并beandefinition",normalizedTitle:"2.1.2 合并beandefinition",charIndex:2888},{level:4,title:"2.1.3 加载类",slug:"_2-1-3-加载类",normalizedTitle:"2.1.3 加载类",charIndex:2963},{level:4,title:"2.1.4 实例化前（扩展点）",slug:"_2-1-4-实例化前-扩展点",normalizedTitle:"2.1.4 实例化前（扩展点）",charIndex:3004},{level:4,title:"2.1.5 实例化",slug:"_2-1-5-实例化",normalizedTitle:"2.1.5 实例化",charIndex:3254},{level:4,title:"2.1.6 BeanDefinition的后置处理（扩展点）",slug:"_2-1-6-beandefinition的后置处理-扩展点",normalizedTitle:"2.1.6 beandefinition的后置处理（扩展点）",charIndex:3425},{level:4,title:"2.1.7 实例化后（扩展点）",slug:"_2-1-7-实例化后-扩展点",normalizedTitle:"2.1.7 实例化后（扩展点）",charIndex:3608},{level:4,title:"2.1.8 处理属性",slug:"_2-1-8-处理属性",normalizedTitle:"2.1.8 处理属性",charIndex:3739},{level:4,title:"2.1.9 执行Aware（扩展点）",slug:"_2-1-9-执行aware-扩展点",normalizedTitle:"2.1.9 执行aware（扩展点）",charIndex:3886},{level:4,title:"2.1.10 初始化前（扩展点）",slug:"_2-1-10-初始化前-扩展点",normalizedTitle:"2.1.10 初始化前（扩展点）",charIndex:4055},{level:4,title:"2.1.11 初始化",slug:"_2-1-11-初始化",normalizedTitle:"2.1.11 初始化",charIndex:4563},{level:4,title:"2.1.12 初始化后（扩展点）",slug:"_2-1-12-初始化后-扩展点",normalizedTitle:"2.1.12 初始化后（扩展点）",charIndex:4679},{level:3,title:"2.2 Bean的销毁过程",slug:"_2-2-bean的销毁过程",normalizedTitle:"2.2 bean的销毁过程",charIndex:4858},{level:3,title:"2.3 什么是循环依赖？",slug:"_2-3-什么是循环依赖",normalizedTitle:"2.3 什么是循环依赖？",charIndex:5349},{level:3,title:"2.4 详细讲下三级缓存？",slug:"_2-4-详细讲下三级缓存",normalizedTitle:"2.4 详细讲下三级缓存？",charIndex:5449},{level:3,title:"2.5 为什么需要第三级缓存？",slug:"_2-5-为什么需要第三级缓存",normalizedTitle:"2.5 为什么需要第三级缓存？",charIndex:6042},{level:2,title:"3、Mybatis",slug:"_3、mybatis",normalizedTitle:"3、mybatis",charIndex:6294},{level:3,title:"3.0 Mybatis常见问题",slug:"_3-0-mybatis常见问题",normalizedTitle:"3.0 mybatis常见问题",charIndex:6308},{level:4,title:"3.0.1 Mybatis是如何进行分页的？分页插件的原理是什么？",slug:"_3-0-1-mybatis是如何进行分页的-分页插件的原理是什么",normalizedTitle:"3.0.1 mybatis是如何进行分页的？分页插件的原理是什么？",charIndex:6327},{level:4,title:"3.0.2 Mybatis有哪些动态sql标签？执行原理？",slug:"_3-0-2-mybatis有哪些动态sql标签-执行原理",normalizedTitle:"3.0.2 mybatis有哪些动态sql标签？执行原理？",charIndex:6481},{level:4,title:"3.0.3 Mybatis Xml映射文件中有哪些常见标签？",slug:"_3-0-3-mybatis-xml映射文件中有哪些常见标签",normalizedTitle:"3.0.3 mybatis xml映射文件中有哪些常见标签？",charIndex:6588},{level:4,title:"3.0.4 聊一下Mybatis的一级、二级缓存？",slug:"_3-0-4-聊一下mybatis的一级、二级缓存",normalizedTitle:"3.0.4 聊一下mybatis的一级、二级缓存？",charIndex:6736},{level:4,title:"3.0.5 Mybatis一对一、一对多的关联查询？",slug:"_3-0-5-mybatis一对一、一对多的关联查询",normalizedTitle:"3.0.5 mybatis一对一、一对多的关联查询？",charIndex:6889},{level:3,title:"3.1 Mybatis插件",slug:"_3-1-mybatis插件",normalizedTitle:"3.1 mybatis插件",charIndex:6924},{level:4,title:"3.1.1 Mybatis插件的运行原理？",slug:"_3-1-1-mybatis插件的运行原理",normalizedTitle:"3.1.1 mybatis插件的运行原理？",charIndex:6941},{level:4,title:"3.1.2 如何编写一个Mybatis插件？",slug:"_3-1-2-如何编写一个mybatis插件",normalizedTitle:"3.1.2 如何编写一个mybatis插件？",charIndex:7094}],headersStr:"1、SpringMVC 1.1 什么是SpringMVC？简单说下你的理解？ 1.2 讲下SpringMVC的执行流程？ 1.3 SpringMVC怎么样设定重定向和转发的？ 1.4 SpringMVC常用的注解有哪些？ 1.5 SpingMvc中控制器的注解一般用哪个？ 1.6 如何解决POST请求中文乱码问题，GET的又如何处理呢？ 1.7 SpringMvc控制器是不是单例？如果是，有什么问题？ 1.8 如果在拦截请求中，我想拦截get方式提交的方法，怎么配置？ 1.9 怎样在方法里面得到Request，或者Session？ 2、Spring 2.0 Spring常见问题 2.0.1 BeanFactory与FactoryBean的区别？ 2.0.2 BeanFactory与ApplicationContext的区别？ 2.0.3 Spring整合Mybatis后为什么会导致一级缓存失效？ 2.1 Bean的生成过程 2.1.1 生成BeanDefinition 2.1.2 合并BeanDefinition 2.1.3 加载类 2.1.4 实例化前（扩展点） 2.1.5 实例化 2.1.6 BeanDefinition的后置处理（扩展点） 2.1.7 实例化后（扩展点） 2.1.8 处理属性 2.1.9 执行Aware（扩展点） 2.1.10 初始化前（扩展点） 2.1.11 初始化 2.1.12 初始化后（扩展点） 2.2 Bean的销毁过程 2.3 什么是循环依赖？ 2.4 详细讲下三级缓存？ 2.5 为什么需要第三级缓存？ 3、Mybatis 3.0 Mybatis常见问题 3.0.1 Mybatis是如何进行分页的？分页插件的原理是什么？ 3.0.2 Mybatis有哪些动态sql标签？执行原理？ 3.0.3 Mybatis Xml映射文件中有哪些常见标签？ 3.0.4 聊一下Mybatis的一级、二级缓存？ 3.0.5 Mybatis一对一、一对多的关联查询？ 3.1 Mybatis插件 3.1.1 Mybatis插件的运行原理？ 3.1.2 如何编写一个Mybatis插件？",content:'# Spring\n\n\n# 1、SpringMVC\n\n\n# 1.1 什么是SpringMVC？简单说下你的理解？\n\nSpringMVC是一个轻量级的web框架。\n\nSpringMVC把web应用分成几个清晰的模块，分别是model、view、controller。\n\nSpringMVC可以使用各种视图技术，不仅仅局限于jsp。\n\n\n# 1.2 讲下SpringMVC的执行流程？\n\n\n\n1.客户端发送请求到前端控制器DispatcheServlet。\n\n2.DispatcheServlet通过处理器映射器HandlerMapping获取处理器Handler。（处理器映射器返回处理器执行链，包含处理器Handler和拦截器HandlerInterceptor）。\n\n3.DispatcheServlet通过处理器适配器HandlerAdapter执行Handler。（Handler也就是controller）\n\n4.Handler执行完后返回ModelAndView给到DispatcheServlet。\n\n5.DispatcheServlet将ModelAndView传给ViewResolver（视图解析器）做解析。\n\n6.ViewResolver（视图解析器）解析完返回View视图对象给到DispatcherServlet。\n\n7.DispatcherServlet把Model数据填充到View试图对象中。\n\n8.响应用户。\n\n\n# 1.3 SpringMVC怎么样设定重定向和转发的？\n\n（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"\n\n（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"\n\n\n# 1.4 SpringMVC常用的注解有哪些？\n\n**@RequestMapping：**用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n**@RequestBody：**注解实现接收http请求的json数据，将json转换为java对象。\n\n**@ResponseBody：**注解实现将conreoller方法返回对象转化为json对象响应给客户。\n\n\n# 1.5 SpingMvc中控制器的注解一般用哪个？\n\n一般用@Controller注解，也可以使用@RestController。\n\n@RestController注解相当于@ResponseBody ＋ @Controller，表示是表现层，除此之外，一般不用别的注解代替。\n\n\n# 1.6 如何解决POST请求中文乱码问题，GET的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中配置一个CharacterEncodingFilter过滤器，设置成utf-8。\n\n\n\n（2）get请求中文参数出现乱码解决方法有两个：\n\n① 修改tomcat配置文件添加编码与工程编码一致，如下：\n\n\n\n② 另外一种方法对参数进行重新编码：\n\n\n\nISO8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n\n# 1.7 SpringMvc控制器是不是单例？如果是，有什么问题？\n\n1.是单例模式。\n\n2.在多线程访问的时候有线程安全问题。\n\n3.解决方案是在控制器里面不能写可变状态量，如果需要这些可变状态，可以使用ThreadLocal机制解决，为每个线程单独生成一份变量副本，独立操作，互不影响。\n\n\n# 1.8 如果在拦截请求中，我想拦截get方式提交的方法，怎么配置？\n\n可以在@RequestMapping注解里面加上method=RequestMethod.GET。\n\n\n# 1.9 怎样在方法里面得到Request，或者Session？\n\n直接在方法的形参中声明request，SpringMvc就自动把request对象传入。\n\n\n# 2、Spring\n\n\n# 2.0 Spring常见问题\n\n# 2.0.1 BeanFactory与FactoryBean的区别？\n\n1.BeanFactory:IOC容器的核心接口，负责生产和管理Spring中的Bean。\n\nApplicationContext就是BeanFactory的一种，继承了BeanFactory的功能，又扩展了很多其他功能。\n\n\n\n2.FactoryBean：也是一个接口，通过实现FactoryBean接口，可以创建一个我们自己定义的Bean，这个Bean只会经过Spring的Bean生命周期步骤中的初始化后，其他生命周期步骤不会经过。Spring整合Mybatis的时候，就是通过FactoryBean的方式，将Mybatis中的sql对应的接口转化成Spring的Bean对象。\n\n\n\n# 2.0.2 BeanFactory与ApplicationContext的区别？\n\nApplicationContext由BeanFactory派生而来，拥有比BeanFactory更多的功能，比如：\n\n1.支持国际化功能。\n\n2.支持事件机制（发布订阅）。\n\n3.支持底层资源访问，可以用来加载多个Resource。\n\n4.支持web应用。\n\n# 2.0.3 Spring整合Mybatis后为什么会导致一级缓存失效？\n\nMybatis的一级缓存是利用SqlSession实现的，同样的sql，如果在同一个SqlSession执行，就会利用一级缓存，提高查询效率。\n\nSpring整合Mybatis后，执行方法时，如果方法没有加@Transactional注解，那么方法里面执行sql时，每个sql要执行时都会先生成一个新的SqlSession去执行该sql，所以一级缓存会失效。如果加上@Transactional注解，即开启事务，则同个方法内多个sql使用的是同一个SqlSession，从而一级缓存能生效。\n\n\n# 2.1 Bean的生成过程\n\n# 2.1.1 生成BeanDefinition\n\nSpring启动的时候会进行扫描，扫描指定包路径下的所有.class文件，并得到BeanDefinition的Set集合。（Spring源码中将class文件包装成Resource对象，遍历每个Resource对象。解析.class文件利用的是ASM技术，并没有加载这个类到JVM。）\n\n什么是BeanDefinition？\n\nBean定义，存在很多属性来描述一个Bean的特点。比如：\n\nclass：表示bean类型。\n\nscope：表示bean的作用域，如单例、原型等。\n\nlazyInit：表示类是否懒加载。\n\ninitMethodName：表示Bean初始化时要执行的方法。\n\ndestroyMethodName：表示Bean销毁时要执行的方法。\n\n# 2.1.2 合并BeanDefinition\n\nSpring中支持父子BeanDefinition，child会继承parent上定义的属性。\n\n# 2.1.3 加载类\n\n加载BeanDefinition所对应的class。\n\n# 2.1.4 实例化前（扩展点）\n\nBeanDefinition对应的类成功加载后，就可以实例化对象了。但是在Spring中，实例化对象之前，Spring提供了一个扩展点：InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()\n\n\n\n如果按上面例子，在实例化前直接返回一个自己定义的对象，则表示不需要Spring来实例化了，并且后面的Spring依赖注入也不会进行，会跳过一些步骤，直接执行到 初始化后 这一步。\n\n# 2.1.5 实例化\n\n根据BeanDefinition去创建一个对象。\n\n1.BeanDefinition中是否设置了Supplier，如果设置了则调用Supplier的get()得到对象。\n\n2.BeanDefinition中是否设置了factoryMethod，如果设置了则调用工厂方法得到对象。\n\n3.创建对象前，推断构造方法。\n\n# 2.1.6 BeanDefinition的后置处理（扩展点）\n\nBean对象实例化出来之后，接下来可以给对象属性赋值了。但是在赋值之前，Spring又提供了一个扩展点可以对此时的BeanDefinition进行加工：\n\nMergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()\n\n\n\n# 2.1.7 实例化后（扩展点）\n\n处理完BeanDefinition,Spring还提供一个扩展点处理实例对象：\n\nInstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()\n\n\n\n# 2.1.8 处理属性\n\n处理@Autowired、@Resource、@Value等注解，通过以下扩展点实现：\n\nInstantiatiionAwareBeanPostProcessor.postProcessProperties()\n\n我们甚至可以以此实现一个自己的注入功能，如：\n\n\n\n# 2.1.9 执行Aware（扩展点）\n\n完成属性赋值后，Spring会执行一些回调，包括：\n\n1.BeanNameAware：回传beanName给bean对象。\n\n2.BeanClassLoaderAware：回传classLoader给bean对象。\n\n3.BeanFactoryAware：回传beanFactory给对象。\n\n# 2.1.10 初始化前（扩展点）\n\nSpring提供的一个扩展点：\n\nBeanPostProcessor.postProcessBeforeInitialization()\n\n\n\n在Spring源码中：\n\n1.InitDestroyAnnotationBeanPostProcessor会在初始化前这个步骤中执行**@PostConstruct**的方法。\n\n2.ApplicationContextAwareProcessor会在初始化前这个步骤进行其他Aware的回调：\n\n1）EnvironmentAware：回传环境变量\n\n2）EmbeddedValueResolverAware：回传占位符解析器\n\n3）ResourceLoaderAware：回传资源加载器\n\n4）ApplicationEventPublisherAware：回传事件发布器\n\n5）MessageSourceAware：回传国际化资源\n\n6）ApplicationStartupAware：回传应用其他监听对象，可忽略\n\n7）ApplicationContextAware：回传Spring容器ApplicationContext\n\n# 2.1.11 初始化\n\n1.当前Bean对象是否实现了InitializingBean接口，实现了就调用其**afterPropertiesSet()**方法。\n\n2.执行BeanDefinition中指定的初始化方法。\n\n\n\n# 2.1.12 初始化后（扩展点）\n\nBean创建生命周期中的最后一个步骤，Spring提供的一个扩展点：\n\nBeanPostProcessor.postProcessAfterInitialization()\n\n\n\n可以在这个步骤中对Bean进行最终处理。\n\nSpring中的AOP就是基于初始化后实现的。初始化后返回的对象才是最终的Bean对象。\n\n\n# 2.2 Bean的销毁过程\n\nBean销毁是发生在Spring容器关闭过程中的。\n\n1.在Bean创建过程中，最后（初始化后）有一个步骤去判断当前创建的Bean是不是DisposableBean：\n\n1）当前Bean是否实现了DisposableBean接口。\n\n2）当前Bean是否实现了AutoCloseable接口。\n\n3）BeanDefinition中是否指定了destroyMethod。\n\n4）调用DestructionAwareBeanPostProcessor.requiresDestruction(bean)进行判断。\n\n5）把符合上述任意一个条件的Bean适配成DisposableBeanAdapter对象，并存入disposableBeans中。其中disposableBeans是一个LinkedHashMap。\n\n2.在Spring容器关闭过程时：\n\n1）首先发布ContextClosedEvent事件。\n\n2）调用lifecycleProcessor的onCloese()方法。\n\n3）遍历disposableBeans销毁单例Bean。\n\n\n# 2.3 什么是循环依赖？\n\nA创建时 --\x3e 需要B --\x3e B去创建时 --\x3e 需要A，从而产生循环。\n\n\n\n如何打破循环，加个中间人（缓存）\n\n\n\n实际上就是使用了三级缓存解决循环依赖。\n\n\n# 2.4 详细讲下三级缓存？\n\n1.singletonObjects（一级缓存：单例池）：缓存经过了完整生命周期的bean。\n\n2.earlySingletonObjects（二级缓存）：缓存未经过完整生命周期的bean，只要某个bean出现了循环依赖，就会提前把这个暂时未经过完整生命周期的bean放入earlySingletonObjects中（这个bean如果要经过AOP，那么就会把代理对象放入earlySingletonObjects中，否则就是把原始对象放入earlySingletonObjects），即使是代理对象，代理对象所代理的原始对象也是没有经过完整生命周期的。\n\n3.singletonFactories（三级缓存）：缓存的是一个Lambda表达式。在每个Bean的生成过程中，经过实例化得到一个原始对象后，都会提前基于原始对象暴露一个Lambda表达式，并保存到三级缓存中（这个Lambda表达式可能用到也可能用不到，如果当前Bean没有出现循环依赖，那么这个Lambda表达式没用）。如果当前bean在依赖注入时发现出现了循环依赖，则从三级缓存中拿到Lambda表达式，并执行Lambda表达式得到一个对象，并把得到的对象放入二级缓存。\n\n4.其实还要一个缓存，就是earlyProxyReferences，它用来记录某个原始对象是否进行过AOP了。\n\n\n# 2.5 为什么需要第三级缓存？\n\n主要为了处理AOP的问题。\n\n如果没有第三级缓存earlySingletonObjects，则每个bean在依赖注入之前都要去进行AOP的操作，不符合bean的生命周期步骤设计，即AOP对象是在初始化之后生成。\n\n有第三级缓存，则没有循环依赖的需要AOP对象可以按bean的生命周期步骤进行，有循环依赖的需要AOP对象在依赖注入时通过三级缓存中Lambda表达式获取AOP对象放入二级缓存。初始化后要生成AOP对象时去判断是否已经生成过，已生成则不再处理。\n\n\n\n\n# 3、Mybatis\n\n\n# 3.0 Mybatis常见问题\n\n# 3.0.1 Mybatis是如何进行分页的？分页插件的原理是什么？\n\n1.Mybatis使用RowBounds对象进行分页，它是针对结果集进行的内存分页。\n\n2.分页插件的原理是使用Mybatis提供的插件接口，实现自定义插件，可以在插件的拦截方法内拦截待执行的sql，然后重写sql来完成物理分页。\n\n# 3.0.2 Mybatis有哪些动态sql标签？执行原理？\n\nMybatis提供了9种动态sql标签：trim、where、set、foreach、if、choose、when、otherwise、bind\n\n# 3.0.3 Mybatis Xml映射文件中有哪些常见标签？\n\nselect、insert、update、delete、resultMap、parameterMap、sql、include，加上动态sql9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段。\n\n# 3.0.4 聊一下Mybatis的一级、二级缓存？\n\n一级缓存：Mybatis的一级缓存是利用SqlSession实现的，同样的sql，如果在同一个SqlSession执行，就会利用一级缓存，提高查询效率。\n\n二级缓存：存储作用域为Mapper(Namespace)，可自定义存储源，如redis。\n\n# 3.0.5 Mybatis一对一、一对多的关联查询？\n\n\n\n\n\n\n# 3.1 Mybatis插件\n\n# 3.1.1 Mybatis插件的运行原理？\n\nMybatis使用JDK的动态代理，为指定的接口生成代理对象，实现接口方法拦截功能。Mybatis仅支持4种指定接口的插件，分别是：ParameterHandler、ResultSetHandler、StatementHandler、Executor。\n\n# 3.1.2 如何编写一个Mybatis插件？\n\n实现Mybatis的Interceptor接口并重写intercept()方法，然后给插件编写注解，指定要拦截哪一个接口的哪些方法即可。另外还需要在配置文件中配置好编写的插件。\n\n\n\n',normalizedContent:'# spring\n\n\n# 1、springmvc\n\n\n# 1.1 什么是springmvc？简单说下你的理解？\n\nspringmvc是一个轻量级的web框架。\n\nspringmvc把web应用分成几个清晰的模块，分别是model、view、controller。\n\nspringmvc可以使用各种视图技术，不仅仅局限于jsp。\n\n\n# 1.2 讲下springmvc的执行流程？\n\n\n\n1.客户端发送请求到前端控制器dispatcheservlet。\n\n2.dispatcheservlet通过处理器映射器handlermapping获取处理器handler。（处理器映射器返回处理器执行链，包含处理器handler和拦截器handlerinterceptor）。\n\n3.dispatcheservlet通过处理器适配器handleradapter执行handler。（handler也就是controller）\n\n4.handler执行完后返回modelandview给到dispatcheservlet。\n\n5.dispatcheservlet将modelandview传给viewresolver（视图解析器）做解析。\n\n6.viewresolver（视图解析器）解析完返回view视图对象给到dispatcherservlet。\n\n7.dispatcherservlet把model数据填充到view试图对象中。\n\n8.响应用户。\n\n\n# 1.3 springmvc怎么样设定重定向和转发的？\n\n（1）转发：在返回值前面加"forward:"，譬如"forward:user.do?name=method4"\n\n（2）重定向：在返回值前面加"redirect:"，譬如"redirect:http://www.baidu.com"\n\n\n# 1.4 springmvc常用的注解有哪些？\n\n**@requestmapping：**用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中的所有响应请求的方法都是以该地址作为父路径。\n\n**@requestbody：**注解实现接收http请求的json数据，将json转换为java对象。\n\n**@responsebody：**注解实现将conreoller方法返回对象转化为json对象响应给客户。\n\n\n# 1.5 spingmvc中控制器的注解一般用哪个？\n\n一般用@controller注解，也可以使用@restcontroller。\n\n@restcontroller注解相当于@responsebody ＋ @controller，表示是表现层，除此之外，一般不用别的注解代替。\n\n\n# 1.6 如何解决post请求中文乱码问题，get的又如何处理呢？\n\n（1）解决post请求乱码问题：\n\n在web.xml中配置一个characterencodingfilter过滤器，设置成utf-8。\n\n\n\n（2）get请求中文参数出现乱码解决方法有两个：\n\n① 修改tomcat配置文件添加编码与工程编码一致，如下：\n\n\n\n② 另外一种方法对参数进行重新编码：\n\n\n\niso8859-1是tomcat默认编码，需要将tomcat编码后的内容按utf-8编码。\n\n\n# 1.7 springmvc控制器是不是单例？如果是，有什么问题？\n\n1.是单例模式。\n\n2.在多线程访问的时候有线程安全问题。\n\n3.解决方案是在控制器里面不能写可变状态量，如果需要这些可变状态，可以使用threadlocal机制解决，为每个线程单独生成一份变量副本，独立操作，互不影响。\n\n\n# 1.8 如果在拦截请求中，我想拦截get方式提交的方法，怎么配置？\n\n可以在@requestmapping注解里面加上method=requestmethod.get。\n\n\n# 1.9 怎样在方法里面得到request，或者session？\n\n直接在方法的形参中声明request，springmvc就自动把request对象传入。\n\n\n# 2、spring\n\n\n# 2.0 spring常见问题\n\n# 2.0.1 beanfactory与factorybean的区别？\n\n1.beanfactory:ioc容器的核心接口，负责生产和管理spring中的bean。\n\napplicationcontext就是beanfactory的一种，继承了beanfactory的功能，又扩展了很多其他功能。\n\n\n\n2.factorybean：也是一个接口，通过实现factorybean接口，可以创建一个我们自己定义的bean，这个bean只会经过spring的bean生命周期步骤中的初始化后，其他生命周期步骤不会经过。spring整合mybatis的时候，就是通过factorybean的方式，将mybatis中的sql对应的接口转化成spring的bean对象。\n\n\n\n# 2.0.2 beanfactory与applicationcontext的区别？\n\napplicationcontext由beanfactory派生而来，拥有比beanfactory更多的功能，比如：\n\n1.支持国际化功能。\n\n2.支持事件机制（发布订阅）。\n\n3.支持底层资源访问，可以用来加载多个resource。\n\n4.支持web应用。\n\n# 2.0.3 spring整合mybatis后为什么会导致一级缓存失效？\n\nmybatis的一级缓存是利用sqlsession实现的，同样的sql，如果在同一个sqlsession执行，就会利用一级缓存，提高查询效率。\n\nspring整合mybatis后，执行方法时，如果方法没有加@transactional注解，那么方法里面执行sql时，每个sql要执行时都会先生成一个新的sqlsession去执行该sql，所以一级缓存会失效。如果加上@transactional注解，即开启事务，则同个方法内多个sql使用的是同一个sqlsession，从而一级缓存能生效。\n\n\n# 2.1 bean的生成过程\n\n# 2.1.1 生成beandefinition\n\nspring启动的时候会进行扫描，扫描指定包路径下的所有.class文件，并得到beandefinition的set集合。（spring源码中将class文件包装成resource对象，遍历每个resource对象。解析.class文件利用的是asm技术，并没有加载这个类到jvm。）\n\n什么是beandefinition？\n\nbean定义，存在很多属性来描述一个bean的特点。比如：\n\nclass：表示bean类型。\n\nscope：表示bean的作用域，如单例、原型等。\n\nlazyinit：表示类是否懒加载。\n\ninitmethodname：表示bean初始化时要执行的方法。\n\ndestroymethodname：表示bean销毁时要执行的方法。\n\n# 2.1.2 合并beandefinition\n\nspring中支持父子beandefinition，child会继承parent上定义的属性。\n\n# 2.1.3 加载类\n\n加载beandefinition所对应的class。\n\n# 2.1.4 实例化前（扩展点）\n\nbeandefinition对应的类成功加载后，就可以实例化对象了。但是在spring中，实例化对象之前，spring提供了一个扩展点：instantiationawarebeanpostprocessor.postprocessbeforeinstantiation()\n\n\n\n如果按上面例子，在实例化前直接返回一个自己定义的对象，则表示不需要spring来实例化了，并且后面的spring依赖注入也不会进行，会跳过一些步骤，直接执行到 初始化后 这一步。\n\n# 2.1.5 实例化\n\n根据beandefinition去创建一个对象。\n\n1.beandefinition中是否设置了supplier，如果设置了则调用supplier的get()得到对象。\n\n2.beandefinition中是否设置了factorymethod，如果设置了则调用工厂方法得到对象。\n\n3.创建对象前，推断构造方法。\n\n# 2.1.6 beandefinition的后置处理（扩展点）\n\nbean对象实例化出来之后，接下来可以给对象属性赋值了。但是在赋值之前，spring又提供了一个扩展点可以对此时的beandefinition进行加工：\n\nmergedbeandefinitionpostprocessor.postprocessmergedbeandefinition()\n\n\n\n# 2.1.7 实例化后（扩展点）\n\n处理完beandefinition,spring还提供一个扩展点处理实例对象：\n\ninstantiationawarebeanpostprocessor.postprocessafterinstantiation()\n\n\n\n# 2.1.8 处理属性\n\n处理@autowired、@resource、@value等注解，通过以下扩展点实现：\n\ninstantiatiionawarebeanpostprocessor.postprocessproperties()\n\n我们甚至可以以此实现一个自己的注入功能，如：\n\n\n\n# 2.1.9 执行aware（扩展点）\n\n完成属性赋值后，spring会执行一些回调，包括：\n\n1.beannameaware：回传beanname给bean对象。\n\n2.beanclassloaderaware：回传classloader给bean对象。\n\n3.beanfactoryaware：回传beanfactory给对象。\n\n# 2.1.10 初始化前（扩展点）\n\nspring提供的一个扩展点：\n\nbeanpostprocessor.postprocessbeforeinitialization()\n\n\n\n在spring源码中：\n\n1.initdestroyannotationbeanpostprocessor会在初始化前这个步骤中执行**@postconstruct**的方法。\n\n2.applicationcontextawareprocessor会在初始化前这个步骤进行其他aware的回调：\n\n1）environmentaware：回传环境变量\n\n2）embeddedvalueresolveraware：回传占位符解析器\n\n3）resourceloaderaware：回传资源加载器\n\n4）applicationeventpublisheraware：回传事件发布器\n\n5）messagesourceaware：回传国际化资源\n\n6）applicationstartupaware：回传应用其他监听对象，可忽略\n\n7）applicationcontextaware：回传spring容器applicationcontext\n\n# 2.1.11 初始化\n\n1.当前bean对象是否实现了initializingbean接口，实现了就调用其**afterpropertiesset()**方法。\n\n2.执行beandefinition中指定的初始化方法。\n\n\n\n# 2.1.12 初始化后（扩展点）\n\nbean创建生命周期中的最后一个步骤，spring提供的一个扩展点：\n\nbeanpostprocessor.postprocessafterinitialization()\n\n\n\n可以在这个步骤中对bean进行最终处理。\n\nspring中的aop就是基于初始化后实现的。初始化后返回的对象才是最终的bean对象。\n\n\n# 2.2 bean的销毁过程\n\nbean销毁是发生在spring容器关闭过程中的。\n\n1.在bean创建过程中，最后（初始化后）有一个步骤去判断当前创建的bean是不是disposablebean：\n\n1）当前bean是否实现了disposablebean接口。\n\n2）当前bean是否实现了autocloseable接口。\n\n3）beandefinition中是否指定了destroymethod。\n\n4）调用destructionawarebeanpostprocessor.requiresdestruction(bean)进行判断。\n\n5）把符合上述任意一个条件的bean适配成disposablebeanadapter对象，并存入disposablebeans中。其中disposablebeans是一个linkedhashmap。\n\n2.在spring容器关闭过程时：\n\n1）首先发布contextclosedevent事件。\n\n2）调用lifecycleprocessor的oncloese()方法。\n\n3）遍历disposablebeans销毁单例bean。\n\n\n# 2.3 什么是循环依赖？\n\na创建时 --\x3e 需要b --\x3e b去创建时 --\x3e 需要a，从而产生循环。\n\n\n\n如何打破循环，加个中间人（缓存）\n\n\n\n实际上就是使用了三级缓存解决循环依赖。\n\n\n# 2.4 详细讲下三级缓存？\n\n1.singletonobjects（一级缓存：单例池）：缓存经过了完整生命周期的bean。\n\n2.earlysingletonobjects（二级缓存）：缓存未经过完整生命周期的bean，只要某个bean出现了循环依赖，就会提前把这个暂时未经过完整生命周期的bean放入earlysingletonobjects中（这个bean如果要经过aop，那么就会把代理对象放入earlysingletonobjects中，否则就是把原始对象放入earlysingletonobjects），即使是代理对象，代理对象所代理的原始对象也是没有经过完整生命周期的。\n\n3.singletonfactories（三级缓存）：缓存的是一个lambda表达式。在每个bean的生成过程中，经过实例化得到一个原始对象后，都会提前基于原始对象暴露一个lambda表达式，并保存到三级缓存中（这个lambda表达式可能用到也可能用不到，如果当前bean没有出现循环依赖，那么这个lambda表达式没用）。如果当前bean在依赖注入时发现出现了循环依赖，则从三级缓存中拿到lambda表达式，并执行lambda表达式得到一个对象，并把得到的对象放入二级缓存。\n\n4.其实还要一个缓存，就是earlyproxyreferences，它用来记录某个原始对象是否进行过aop了。\n\n\n# 2.5 为什么需要第三级缓存？\n\n主要为了处理aop的问题。\n\n如果没有第三级缓存earlysingletonobjects，则每个bean在依赖注入之前都要去进行aop的操作，不符合bean的生命周期步骤设计，即aop对象是在初始化之后生成。\n\n有第三级缓存，则没有循环依赖的需要aop对象可以按bean的生命周期步骤进行，有循环依赖的需要aop对象在依赖注入时通过三级缓存中lambda表达式获取aop对象放入二级缓存。初始化后要生成aop对象时去判断是否已经生成过，已生成则不再处理。\n\n\n\n\n# 3、mybatis\n\n\n# 3.0 mybatis常见问题\n\n# 3.0.1 mybatis是如何进行分页的？分页插件的原理是什么？\n\n1.mybatis使用rowbounds对象进行分页，它是针对结果集进行的内存分页。\n\n2.分页插件的原理是使用mybatis提供的插件接口，实现自定义插件，可以在插件的拦截方法内拦截待执行的sql，然后重写sql来完成物理分页。\n\n# 3.0.2 mybatis有哪些动态sql标签？执行原理？\n\nmybatis提供了9种动态sql标签：trim、where、set、foreach、if、choose、when、otherwise、bind\n\n# 3.0.3 mybatis xml映射文件中有哪些常见标签？\n\nselect、insert、update、delete、resultmap、parametermap、sql、include，加上动态sql9个标签，其中<sql>为sql片段标签，通过<include>标签引入sql片段。\n\n# 3.0.4 聊一下mybatis的一级、二级缓存？\n\n一级缓存：mybatis的一级缓存是利用sqlsession实现的，同样的sql，如果在同一个sqlsession执行，就会利用一级缓存，提高查询效率。\n\n二级缓存：存储作用域为mapper(namespace)，可自定义存储源，如redis。\n\n# 3.0.5 mybatis一对一、一对多的关联查询？\n\n\n\n\n\n\n# 3.1 mybatis插件\n\n# 3.1.1 mybatis插件的运行原理？\n\nmybatis使用jdk的动态代理，为指定的接口生成代理对象，实现接口方法拦截功能。mybatis仅支持4种指定接口的插件，分别是：parameterhandler、resultsethandler、statementhandler、executor。\n\n# 3.1.2 如何编写一个mybatis插件？\n\n实现mybatis的interceptor接口并重写intercept()方法，然后给插件编写注解，指定要拦截哪一个接口的哪些方法即可。另外还需要在配置文件中配置好编写的插件。\n\n\n\n',charsets:{cjk:!0},lastUpdated:"2022/05/01, 17:19:34",lastUpdatedTimestamp:1651396774e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"后端",link:"/web/",items:[{text:"知识整理",link:"/pages/5aa878/"},{text:"学习笔记",link:"/pages/8292d8/"}]},{text:"运维",link:"/ui/",items:[{text:"容器技术",link:"/pages/035670/"},{text:"服务器",link:"/pages/0a83b083bdf257cb/"}]},{text:"技术",link:"/technology/",items:[{text:"技术文档",link:"/pages/9a7ee40fc232253e/"},{text:"GitHub技巧",link:"/pages/4c778760be26d8b3/"}]},{text:"更多",link:"/more/",items:[{text:"学习",link:"/pages/f2a556/"},{text:"面试",link:"/pages/aea6571b7a8bae86/"},{text:"心情杂货",link:"/pages/2d615df9a36a98ed/"},{text:"实用技巧",link:"/pages/baaa02/"},{text:"友情链接",link:"/friends/"}]},{text:"关于",link:"/about/"},{text:"收藏",link:"/pages/beb6c0bd8a66cea6/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],sidebarDepth:2,logo:"/img/tx.png",repo:"liuwenkai01",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01.前端.md","后端","/web/"],["02.页面.md","运维","/ui/"],["03.技术.md","技术","/technology/"],["04.更多.md","更多","/more/"]],catalogue:{"前端":"/web/","页面":"/ui/","技术":"/technology/","更多":"/more/","知识整理":"/index/知识整理/","学习笔记":"/note/学习笔记/"},"/01.后端/":[["00.知识整理.md","知识整理","/index/知识整理/"],["01.学习笔记.md","学习笔记","/note/学习笔记/"]],"/02.运维/":[{title:"容器技术",collapsable:!0,children:[["01.容器技术/01.Jenkins教程.md","Jenkins教程","/pages/035670/"]]}],"/03.技术/":[{title:"技术文档",collapsable:!0,children:[["01.技术文档/01.Git使用手册.md","Git使用手册","/pages/9a7ee40fc232253e"],["01.技术文档/02.Markdown使用教程.md","Markdown使用教程","/pages/ad247c4332211551"],["01.技术文档/15.yaml语言教程.md","yaml语言教程","/pages/4e8444e2d534d14f"]]},{title:"GitHub技巧",collapsable:!0,children:[["02.GitHub技巧/01.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/pages/4c778760be26d8b3"],["02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md","GitHub Actions 实现自动部署静态博客","/pages/6b9d359ec5aa5019"],["02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md","GitHub Actions 定时运行代码：每天定时百度链接推送","/pages/f44d2f9ad04ab8d3"],["02.GitHub技巧/10.GitHub加速下载项目的方法.md","GitHub加速下载项目的方法","/pages/95331c6a9613faf8"]]}],"/04.更多/":[["99.友情链接.md","友情链接","/friends"]],"/05.关于/":[["01.关于.md","关于","/about/"]],"/06.收藏夹/":[["01.技术网站.md","网站","/pages/beb6c0bd8a66cea6/"]],"/学习笔记/":[{title:"类加载器&JVM",collapsable:!0,children:[["00.类加载器&JVM/00.JVM知识图谱.md","jvm","/pages/90c423/"]]},{title:"《Git》学习笔记",collapsable:!0,children:[{title:"手册",collapsable:!0,children:[["70.《Git》学习笔记/10.手册/00.常用Git命令清单.md","常用Git命令清单","/pages/8292d8/"],["70.《Git》学习笔记/10.手册/03.Git变基合并.md","Git变基合并","/pages/c10281/"],["70.《Git》学习笔记/10.手册/06.Git命令思维导图.md","Git命令思维导图","/pages/4cbc21/"]]},{title:"文档笔记",collapsable:!0,children:[["70.《Git》学习笔记/20.文档笔记/10.Git基础与命令.md","Git基础与命令","/pages/635088/"],["70.《Git》学习笔记/20.文档笔记/20.Git分支-分支原理.md","Git分支-分支原理","/pages/4bef1a/"],["70.《Git》学习笔记/20.文档笔记/30.Git分支的新建与合并-分支操作.md","Git分支的新建与合并-分支操作","/pages/ea5a8c/"],["70.《Git》学习笔记/20.文档笔记/40.Git分支管理-查看分支.md","Git分支管理-查看分支","/pages/a399b3/"],["70.《Git》学习笔记/20.文档笔记/50.Git分支开发工作流.md","Git分支开发工作流","/pages/49ee30/"],["70.《Git》学习笔记/20.文档笔记/60.Git分支-远程分支.md","Git分支-远程分支","/pages/574d62/"],["70.《Git》学习笔记/20.文档笔记/70.Git分支-变基.md","Git分支-变基","/pages/3a3247/"],["70.《Git》学习笔记/20.文档笔记/80.Git工具-查看修订版本.md","Git工具-查看修订版本","/pages/c984d1/"],["70.《Git》学习笔记/20.文档笔记/90.Git工具-交互式暂存.md","Git工具-交互式暂存","/pages/76d859/"],["70.《Git》学习笔记/20.文档笔记/100.Git工具-重写历史.md","Git工具-重写历史","/pages/1832fe/"],["70.《Git》学习笔记/20.文档笔记/110.Git工具-重置揭密.md","Git工具-重置揭密","/pages/d9e9c6/"]]}]}],"/知识整理/":[["01.java基础.md","java基础","/pages/5aa878/"],["02.jvm.md","JVM","/pages/98788c/"],["03.设计模式.md","设计模式","/pages/f8ee2e/"],["04.排序算法.md","排序算法","/pages/86f5d7/"],["05.系统架构设计.md","系统架构设计","/pages/427643/"],["06.机器配置.md","机器配置","/pages/4a8a37/"],["07.定时任务.md","定时任务","/pages/67b177/"],["08.分布式.md","分布式","/pages/c0fe60/"],["09.关系型数据库.md","关系型数据库","/pages/d130fe/"],["10.网络.md","网络","/pages/451590/"],["11.消息中间件.md","消息中间件","/pages/e1ba65/"],["12.Elasticsearch.md","Elasticsearch","/pages/649d86/"],["13.redis.md","redis","/pages/26e33d/"],["14.spring.md","spring","/pages/172a2f/"]]},author:{name:"liuwenkai",link:"https://github.com/liuwenkai01"},blogger:{avatar:"/img/tx.jpeg",name:"Kevin",slogan:"后端大佬，从业JAVA后端开发10年+经验"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:610725422@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/liuwenkai01"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2019,copyrightInfo:'Kevin | <a href="https://github.com/liuwenkai01/blob/master/LICENSE" target="_blank">MIT License</a>'},extendFrontmatter:{author:{name:"liuwenkai01",link:"https://github.com/liuwenkai01"}},htmlModules:{homeSidebarB:""}},locales:{"/":{lang:"zh-CN",title:"Kevin's blog",description:"专注后端技术",path:"/"}}},dl=(t(211),t(212),t(147),t(222)),ul=t(223),hl=(t(388),t(235),t(42));var pl={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,i=e.home;return!(t||!1===r||!0===i)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(hl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(hl.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(hl.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,i){var a=n[r].frontmatter,o=a.categories,s=a.tags;"array"===Object(hl.n)(o)&&o.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(hl.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},i=0,a=n.length;i<a;i++)r(i);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var i in n.tags)t.push({key:i,length:n.tags[i].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Pi.component(dl.default),Pi.component(ul.default);function ml(n){return n.toString().padStart(2,"0")}t(393);Pi.component("Badge",(function(){return Promise.all([t.e(0),t.e(3)]).then(t.bind(null,529))})),Pi.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,222))})),Pi.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,223))}));t(394);var gl,fl,vl,bl,yl=Object.defineProperty,xl=Object.getOwnPropertySymbols,kl=Object.prototype.hasOwnProperty,wl=Object.prototype.propertyIsEnumerable,_l=(n,e,t)=>e in n?yl(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,El=(n,e)=>{for(var t in e||(e={}))kl.call(e,t)&&_l(n,t,e[t]);if(xl)for(var t of xl(e))wl.call(e,t)&&_l(n,t,e[t]);return n},Tl=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Al=(n,e,t)=>(Tl(n,e,"read from private field"),t?t.call(n):e.get(n)),Il=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},jl=(n,e,t,r)=>(Tl(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t);const Sl=class{constructor(n,e,t,r=!0){Il(this,gl,void 0),Il(this,fl,void 0),jl(this,gl,{width:0,height:0});const{el:i,ctx:a}=Sl.initCanvas(n);this.el=i,this.ctx=a,jl(this,fl,r),this.size={width:e||window.innerWidth,height:t||window.innerHeight}}get size(){return El({},Al(this,gl))}set size({width:n,height:e}){var t;if(Al(this,gl).width===n&&Al(this,gl).height===e)return;Al(this,gl).width=n,Al(this,gl).height=e;const r=null!=(t=Al(this,fl)?window.devicePixelRatio:1)?t:1;this.el.width=Math.round(Al(this,gl).width*r),this.el.height=Math.round(Al(this,gl).height*r),this.el.style.width=Al(this,gl).width+"px",this.el.style.height=Al(this,gl).height+"px",Al(this,fl)&&this.ctx.scale(r,r)}clear(){Sl.clearCanvas(this.ctx,El({},Al(this,gl)))}to(n){n.ctx.drawImage(this.el,0,0,Al(this,gl).width,Al(this,gl).height)}handleResize(n){this.size={width:window.innerWidth,height:window.innerHeight}}static setCanvasStyle(n,e,t){const r=n.style,{zIndex:i=0,opacity:a=1}=e;r.position="fixed",r.top="0",r.left="0",r.zIndex=i.toString(),r.width=(t?t.width:n.width).toString()+"px",r.height=(t?t.height:n.height).toString()+"px",1!==a&&(r.opacity=a.toString()),r.pointerEvents="none"}static initCanvas(n){n||(n=document.createElement("canvas"));const e=n.getContext("2d");return{el:n,ctx:e}}static createOffscreenCanvas(){return new Sl}static clearCanvas(n,e){const{width:t,height:r}=e;n.clearRect(0,0,t,r)}};let zl=Sl;gl=new WeakMap,fl=new WeakMap;class Cl{constructor(n,e,t,r=!0,i=!0,a={zIndex:0,opacity:1}){Il(this,vl,void 0),Il(this,bl,void 0),jl(this,vl,new zl(n,e,t,r)),zl.setCanvasStyle(Al(this,vl).el,a,{width:e,height:t}),jl(this,bl,i?new zl(void 0,e,t,r):null)}get size(){return Al(this,vl).size}draw(n){var e;const t=null!=(e=Al(this,bl))?e:Al(this,vl);t.clear(),n(t.ctx,El({},t.size))}render(){Al(this,bl)&&(Al(this,vl).clear(),Al(this,bl).to(Al(this,vl)))}handleResize(n){Al(this,vl).handleResize(n),Al(this,bl)&&Al(this,bl).handleResize(n)}clear(){Al(this,vl).clear(),Al(this,bl)&&Al(this,bl).clear()}}vl=new WeakMap,bl=new WeakMap;var $l,Ol=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},Pl=(n,e,t)=>(Ol(n,e,"read from private field"),t?t.call(n):e.get(n));class Dl{constructor(){var n,e,t,r;((n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)})(this,$l,void 0),n=this,e=$l,t=new Map,Ol(n,e,"write to private field"),r?r.call(n,t):e.set(n,t)}add(n,e){var t;Pl(this,$l).has(n)||Pl(this,$l).set(n,new Set),null==(t=Pl(this,$l).get(n))||t.add(e)}start(n){if(Pl(this,$l).has(n))for(const e of Pl(this,$l).get(n))window.addEventListener(n,e)}stop(n){if(Pl(this,$l).has(n))for(const e of Pl(this,$l).get(n))window.removeEventListener(n,e)}startAll(){for(const n of Pl(this,$l).keys())this.start(n)}stopAll(){for(const n of Pl(this,$l).keys())this.stop(n)}clear(){Pl(this,$l).clear()}}$l=new WeakMap;class Ml{static randomFloat(n,e){return Math.random()*(e-n)+n}static randomInt(n,e){return Math.floor(Ml.randomFloat(n,e))}static choice(n){const e=n.length;return n[Math.floor(e*Math.random())]}static color(n="0123456789ABCDEF"){return"#"+Ml.choice(n)+Ml.choice(n)+Ml.choice(n)+Ml.choice(n)+Ml.choice(n)+Ml.choice(n)}}var Rl,Gl,Bl,Ll,ql,Hl,Nl,Fl,Ul,Vl,Jl,Wl,Ql,Kl,Yl,Xl,Zl,nc,ec,tc,rc,ic,ac,oc=(n,e,t)=>{if(!e.has(n))throw TypeError("Cannot "+t)},sc=(n,e,t)=>(oc(n,e,"read from private field"),t?t.call(n):e.get(n)),lc=(n,e,t)=>{if(e.has(n))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(n):e.set(n,t)},cc=(n,e,t,r)=>(oc(n,e,"write to private field"),r?r.call(n,t):e.set(n,t),t),dc=(n,e,t)=>(oc(n,e,"access private method"),t);class uc{constructor({size:n=90}={},e={}){lc(this,Hl),lc(this,Fl),lc(this,Vl),lc(this,Wl),lc(this,Kl),lc(this,Xl),lc(this,nc),lc(this,tc),lc(this,ic),lc(this,Rl,void 0),lc(this,Gl,void 0),lc(this,Bl,new Dl),lc(this,Ll,null),lc(this,ql,0),cc(this,Rl,n),cc(this,Gl,e)}mount(n){cc(this,Ll,new Cl(n,window.innerWidth,window.innerHeight,!0,!0,sc(this,Gl))),dc(this,Hl,Nl).call(this),dc(this,Kl,Yl).call(this),function(n,{leftColor:e="#fff",rightColor:t="#444",leftBgColor:r="#35495e",rightBgColor:i="#00ffc0"}={}){console.log(`%c ${n} %c v0.3.0 a51a037 %c`,`background: ${r}; padding: 2px; color: ${e}; font-weight: bold; text-transform: uppercase;`,`background: ${i}; padding: 2px; color: ${t}; font-weight: bold; text-transform: uppercase;`,"background: transparent")}("Theme Ribbon 🎗️",{leftBgColor:"#b300b2"})}unmount(){sc(this,Ll).clear(),dc(this,Fl,Ul).call(this)}}Rl=new WeakMap,Gl=new WeakMap,Bl=new WeakMap,Ll=new WeakMap,ql=new WeakMap,Hl=new WeakSet,Nl=function(){/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?sc(this,Bl).add("touchstart",dc(this,Wl,Ql).bind(this)):sc(this,Bl).add("mousedown",dc(this,Wl,Ql).bind(this)),sc(this,Bl).add("resize",function(n,e,t){var r,i,a;void 0===e&&(e=50),void 0===t&&(t={});var o=null!=(r=t.isImmediate)&&r,s=null!=(i=t.callback)&&i,l=t.maxWait,c=Date.now(),d=[];function u(){if(void 0!==l){var n=Date.now()-c;if(n+e>=l)return l-n}return e}var h=function(){var e=[].slice.call(arguments),t=this;return new Promise((function(r,i){var l=o&&void 0===a;if(void 0!==a&&clearTimeout(a),a=setTimeout((function(){if(a=void 0,c=Date.now(),!o){var r=n.apply(t,e);s&&s(r),d.forEach((function(n){return(0,n.resolve)(r)})),d=[]}}),u()),l){var h=n.apply(t,e);return s&&s(h),r(h)}d.push({resolve:r,reject:i})}))};return h.cancel=function(n){void 0!==a&&clearTimeout(a),d.forEach((function(e){return(0,e.reject)(n)})),d=[]},h}(dc(this,Vl,Jl).bind(this),500)),sc(this,Bl).startAll()},Fl=new WeakSet,Ul=function(){sc(this,Bl).stopAll(),sc(this,Bl).clear()},Vl=new WeakSet,Jl=function(n){sc(this,Ll).handleResize(n),dc(this,Kl,Yl).call(this)},Wl=new WeakSet,Ql=function(n){dc(this,Kl,Yl).call(this)},Kl=new WeakSet,Yl=function(){sc(this,Ll).draw((n,e)=>{dc(this,Xl,Zl).call(this,n,e)}),sc(this,Ll).render()},Xl=new WeakSet,Zl=function(n,e){const{width:t,height:r}=e,i=[{x:0,y:.7*r+sc(this,Rl)},{x:0,y:.7*r-sc(this,Rl)}];for(;i[1].x<t+sc(this,Rl);)dc(this,nc,ec).call(this,n,i)},nc=new WeakSet,ec=function(n,e){const t=sc(this,Rl),r=e[0],i=e[1],a={x:i.x+Ml.randomFloat(-.25,1.75)*t,y:dc(this,ic,ac).call(this,i.y)};n.beginPath(),n.moveTo(r.x,r.y),n.lineTo(i.x,i.y),n.lineTo(a.x,a.y),n.closePath(),n.fillStyle=dc(this,tc,rc).call(this),n.fill(),e[0]=i,e[1]=a},tc=new WeakSet,rc=function(){const n=2*Math.PI;return cc(this,ql,sc(this,ql)+.02*n),cc(this,ql,sc(this,ql)%n),"#"+(127*Math.cos(sc(this,ql))+128<<16|127*Math.cos(sc(this,ql)+n/3)+128<<8|127*Math.cos(sc(this,ql)+n/3*2)+128).toString(16).padStart(6,"0")},ic=new WeakSet,ac=function(n){const{width:e,height:t}=sc(this,Ll).size,r=n+Ml.randomFloat(-1.1,.9)*sc(this,Rl);return r>t||r<0?dc(this,ic,ac).call(this,n):r};var hc={name:"Ribbon",data:function(){return{ribbon:new uc({size:90},{opacity:.8,zIndex:-1})}},mounted:function(){this.ribbon.mount(this.$el)},beforeDestroy:function(){this.ribbon.unmount()}},pc=Object(ol.a)(hc,(function(){var n=this.$createElement;return(this._self._c||n)("canvas",{attrs:{id:"vuepress-canvas-ribbon"}})}),[],!1,null,null,null).exports,mc=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,i=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(ml(n.getUTCMonth()+1),"-").concat(ml(n.getUTCDate())," ").concat(ml(n.getUTCHours()),":").concat(ml(n.getUTCMinutes()),":").concat(ml(n.getUTCSeconds()))}(r)),i?n.author=i:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(pl)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},{},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Ribbon",pc)}],gc=["Ribbon"];t(215);function fc(n,e){return(fc=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(216),t(217);function vc(n){return(vc=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function bc(n,e){if(e&&("object"===Io(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function yc(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=vc(n);if(e){var i=vc(this).constructor;t=Reflect.construct(r,arguments,i)}else t=r.apply(this,arguments);return bc(this,t)}}var xc=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&fc(n,e)}(t,n);var e=yc(t);function t(){return us(this,t),e.apply(this,arguments)}return ps(t)}(function(){function n(){us(this,n),this.store=new Pi({data:{state:{}}})}return ps(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Pi.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(xc.prototype,{getPageAsyncComponent:No,getLayoutAsyncComponent:Fo,getAsyncComponent:Uo,getVueComponent:Vo});var kc={install:function(n){var e=new xc;n.$vuepress=e,n.prototype.$vuepress=e}};function wc(n){n.beforeEach((function(e,t,r){if(_c(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var i=e.path.replace(/\/$/,"")+".html";_c(n,i)?r(i):r()}else r();else{var a=e.path+"/",o=e.path+".html";_c(n,o)?r(o):_c(n,a)?r(a):r()}}))}function _c(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Ec={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Wo("pageKey",e),Pi.component(e)||Pi.component(e,No(e)),Pi.component(e)?n(e):n("")}},Tc={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},Ac={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ic=(t(395),t(396),Object(ol.a)(Ac,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function jc(){return(jc=i(regeneratorRuntime.mark((function n(e){var t,r,i,a;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:cl.routerBase||cl.base,wc(r=new To({base:t,mode:"history",fallback:!1,routes:ll,scrollBehavior:function(n,e,t){return t||(n.hash?!Pi.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),i={},n.prev=4,n.next=7,Promise.all(mc.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Pi,options:i,router:r,siteData:cl,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return a=new Pi(Object.assign(i,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},gc.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:a,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Pi.config.productionTip=!1,Pi.use(To),Pi.use(kc),Pi.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Pi;Ao(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),i=new r,a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(i)),o={};return Object.keys(a).reduce((function(n,e){return e.startsWith("$")&&(n[e]=a[e].get),n}),o),{computed:o}}((function(n){return function(){function e(){us(this,e)}return ps(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var i in r)"/"===i?e=r[i]:0===this.$page.path.indexOf(i)&&(n=r[i]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),cl)),Pi.component("Content",Ec),Pi.component("ContentSlotsDistributor",Tc),Pi.component("OutboundLink",Ic),Pi.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Pi.component("Layout",Fo("Layout")),Pi.component("NotFound",Fo("NotFound")),Pi.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"5bd5f75"},function(n){return jc.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);